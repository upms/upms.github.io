<!DOCTYPE html>
<html lang="en">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="Java 面试题库-B（含答案）" />
    <meta name="hexo-theme-A4" content="v1.9.8" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title></title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
    
   
<link rel="stylesheet" href="/css/lightgallery-bundle.min.css">


   
        
<link rel="stylesheet" href="/css/custom.css">

    

<meta name="generator" content="Hexo 7.1.1"></head>
    
    

    
    



    

    
    




    
    

    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <style>
            .header-img {
                width: 56px;
                height: auto;
                object-fit: cover; /* 保持图片比例 */
                transition: transform 0.3s ease-in-out; 
                border-radius: 0; 
            }
            
        </style>
        <img 
            alt="^-^" 
            cache-control="max-age=86400" 
            class="header-img" 
            src="/img/favicon.webp" 
        />
        <div class="header-content">
            <a class="logo" href="/"></a> 
            <span class="description"></span> 
        </div>
    </div>
    
   
    <ul class="nav">
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    Java 面试题库-B（含答案）
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                    <span>最近更新：2025-05-27</span> 
                
                
                    
                        &nbsp; | &nbsp;
                    
                     <span>字数总计：23.1k</span>
                
                
                
            </div>
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-spring-%E4%BA%8B%E5%8A%A1-aop%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="post-toc-text"> 1、Spring、事务、AOP相关注解</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-java%E5%9F%BA%E7%A1%80%E7%BB%A7%E6%89%BF-%E6%8E%A5%E5%8F%A3-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="post-toc-text"> 2、java基础(继承、接口、多线程)</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="post-toc-text"> 3、正则表达式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95-%E4%B8%89%E8%8C%83%E5%BC%8F-gbase-%E5%A4%A7%E6%95%B0%E6%8D%AE"><span class="post-toc-text"> 4、数据库(索引、三范式、Gbase、大数据)</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4-vim%E6%93%8D%E4%BD%9C-%E6%9D%83%E9%99%90"><span class="post-toc-text"> 5、Linux(基础命令、vim操作、权限)</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AAint%E6%95%B0%E7%BB%84-%E6%95%B0%E7%BB%84%E5%86%85%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%8A%A0-%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC-%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E4%B8%BA-10000-%E5%88%B010000-%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%91%E5%8C%85%E5%90%AB3%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="post-toc-text"> 6、编程题  给定一个int数组 数组内三个数相加 求最大值  数据范围为-10000 到10000 数组最少包含3个数字</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="post-toc-text"> 思路：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%96%B9%E6%B3%95-1%E6%9A%B4%E5%8A%9B%E6%B3%95"><span class="post-toc-text"> 方法 1：暴力法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%96%B9%E6%B3%95-2%E6%8E%92%E5%BA%8F%E6%B3%95"><span class="post-toc-text"> 方法 2：排序法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="post-toc-text"> 解释：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="post-toc-text"> 测试用例：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93"><span class="post-toc-text"> 总结：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="post-toc-text"> 7、linux基础命令</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-spring%E4%B8%8Espringboot%E6%B3%A8%E8%A7%A3"><span class="post-toc-text"> 8、spring与springboot注解</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#spring-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="post-toc-text"> Spring 常用注解</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#spring-boot-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="post-toc-text"> Spring Boot 常用注解</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9-%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD"><span class="post-toc-text"> 9、重写与重载</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-%E9%87%8D%E5%86%99override"><span class="post-toc-text"> 1. 重写（Override）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%89%B9%E7%82%B9"><span class="post-toc-text"> 特点：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="post-toc-text"> 示例：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-%E9%87%8D%E8%BD%BDoverload"><span class="post-toc-text"> 2. 重载（Overload）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="post-toc-text"> 特点：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="post-toc-text"> 示例：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%87%8D%E5%86%99-vs-%E9%87%8D%E8%BD%BD"><span class="post-toc-text"> 重写 vs 重载</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="post-toc-text"> 总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#10-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="post-toc-text"> 10、接口与抽象类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-%E6%8E%A5%E5%8F%A3interface"><span class="post-toc-text"> 1. 接口（Interface）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%89%B9%E7%82%B9-3"><span class="post-toc-text"> 特点：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="post-toc-text"> 示例：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-%E6%8A%BD%E8%B1%A1%E7%B1%BBabstract-class"><span class="post-toc-text"> 2. 抽象类（Abstract Class）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%89%B9%E7%82%B9-4"><span class="post-toc-text"> 特点：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="post-toc-text"> 示例：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8E%A5%E5%8F%A3-vs-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="post-toc-text"> 接口 vs 抽象类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="post-toc-text"> 如何选择？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="post-toc-text"> 总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#11-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="post-toc-text"> 11、构造方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9"><span class="post-toc-text"> 构造方法的特点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="post-toc-text"> 构造方法的语法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="post-toc-text"> 示例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="post-toc-text"> 1. 无参构造方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-%E5%B8%A6%E5%8F%82%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="post-toc-text"> 2. 带参构造方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="post-toc-text"> 3. 构造方法重载</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-%E4%BD%BF%E7%94%A8-this-%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="post-toc-text"> 4. 使用 this() 调用其他构造方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="post-toc-text"> 构造方法的作用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="post-toc-text"> 注意事项</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="post-toc-text"> 总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#12-%E9%9D%99%E6%80%81%E7%B1%BB"><span class="post-toc-text"> 12、静态类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BBstatic-nested-class"><span class="post-toc-text"> 1. 静态内部类（Static Nested Class）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%89%B9%E7%82%B9-5"><span class="post-toc-text"> 特点：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A4%BA%E4%BE%8B-6"><span class="post-toc-text"> 示例：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-%E5%B7%A5%E5%85%B7%E7%B1%BButility-class"><span class="post-toc-text"> 2. 工具类（Utility Class）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%89%B9%E7%82%B9-6"><span class="post-toc-text"> 特点：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A4%BA%E4%BE%8B-7"><span class="post-toc-text"> 示例：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="post-toc-text"> 静态类的使用场景</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="post-toc-text"> 注意事项</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="post-toc-text"> 总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#13-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%AD%89%E7%AD%89"><span class="post-toc-text"> 13、权限修饰符等等</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-public"><span class="post-toc-text"> 1. public</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A4%BA%E4%BE%8B-8"><span class="post-toc-text"> 示例：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-protected"><span class="post-toc-text"> 2. protected</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A4%BA%E4%BE%8B-9"><span class="post-toc-text"> 示例：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-default%E5%8C%85%E7%A7%81%E6%9C%89"><span class="post-toc-text"> 3. default（包私有）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A4%BA%E4%BE%8B-10"><span class="post-toc-text"> 示例：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-private"><span class="post-toc-text"> 4. private</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A4%BA%E4%BE%8B-11"><span class="post-toc-text"> 示例：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E6%80%BB%E7%BB%93"><span class="post-toc-text"> 权限修饰符的总结</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="post-toc-text"> 其他相关概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-final-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="post-toc-text"> 1. final 修饰符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A4%BA%E4%BE%8B-12"><span class="post-toc-text"> 示例：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-static-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="post-toc-text"> 2. static 修饰符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A4%BA%E4%BE%8B-13"><span class="post-toc-text"> 示例：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-abstract-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="post-toc-text"> 3. abstract 修饰符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A4%BA%E4%BE%8B-14"><span class="post-toc-text"> 示例：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="post-toc-text"> 总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#14-springboot%E6%B3%A8%E8%A7%A3"><span class="post-toc-text"> 14、springboot注解</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#15-%E7%BA%BF%E7%A8%8B%E5%91%BD%E4%BB%A4"><span class="post-toc-text"> 15、线程命令</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#16-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0"><span class="post-toc-text"> 16、接口与抽象类、继承实现</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BBabstract-class"><span class="post-toc-text"> 抽象类（Abstract Class）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8E%A5%E5%8F%A3interface"><span class="post-toc-text"> 接口（Interface）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="post-toc-text"> 继承与实现的比较</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="post-toc-text"> 示例代码</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#17-mysqloracle"><span class="post-toc-text"> 17、mysql.oracle</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-%E5%BC%80%E6%94%BE%E6%80%A7%E4%B8%8E%E8%AE%B8%E5%8F%AF"><span class="post-toc-text"> 1. 开放性与许可</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7"><span class="post-toc-text"> 2. 性能与可扩展性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-%E6%88%90%E6%9C%AC"><span class="post-toc-text"> 3. 成本</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%94%AF%E6%8C%81"><span class="post-toc-text"> 4. 生态系统与支持</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%89%B9%E6%80%A7"><span class="post-toc-text"> 5. 功能与特性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="post-toc-text"> 6. 兼容性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-%E5%AD%A6%E4%B9%A0%E6%9B%B2%E7%BA%BF"><span class="post-toc-text"> 7. 学习曲线</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#18-%E4%B8%8D%E6%98%AF%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%80%89%E9%A1%B9"><span class="post-toc-text"> 18、不是基础数据类型的选项</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#19-%E5%B1%9E%E4%BA%8E%E7%BA%BF%E7%A8%8B%E5%91%BD%E4%BB%A4%E5%A4%9A%E9%80%89"><span class="post-toc-text"> 19、属于线程命令多选</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#20-%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3%E7%94%9F%E6%95%88%E7%9A%84%E9%80%89%E9%A1%B9"><span class="post-toc-text"> 20、事务注解生效的选项</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#21-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E6%8F%8F%E8%BF%B0%E6%AD%A3%E7%A1%AE%E7%9A%84"><span class="post-toc-text"> 21、接口与抽象类、继承实现描述正确的</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#22-oracle-%E5%88%86%E9%A1%B5-%E9%82%A3%E4%BA%9B%E9%80%89%E9%A1%B9%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84"><span class="post-toc-text"> 22、oracle 分页 那些选项是正确的</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8-rownum-%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5"><span class="post-toc-text"> 使用 ROWNUM 进行分页</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8-offset-fetch-%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5"><span class="post-toc-text"> 使用 OFFSET FETCH 进行分页</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3"><span class="post-toc-text"> 注意事项</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#23-%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95-%E4%B8%89%E4%B8%AA%E9%83%BD%E5%AE%8C%E5%85%A8%E7%94%9F%E6%95%88%E7%9A%84%E9%80%89%E9%A1%B9"><span class="post-toc-text"> 23、组合索引 三个都完全生效的选项</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#24-java%E6%BA%90%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D"><span class="post-toc-text"> 24、java源文件扩展名</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#25-%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6"><span class="post-toc-text"> 25、类成员访问控制符</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#26-%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="post-toc-text"> 26、三种基本控制结构</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#27-linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%8F%8F%E8%BF%B0-3~4%E9%81%93%E5%B7%A6%E5%8F%B3"><span class="post-toc-text"> 27、Linux文件权限描述、3~4道左右</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#28-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%82%E5%B8%B8%E7%A0%81"><span class="post-toc-text"> 28、服务器异常码</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#29-java%E5%B8%B8%E9%87%8F%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="post-toc-text"> 29、java常量的修饰符</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#30-aop%E7%BB%84%E6%88%90"><span class="post-toc-text"> 30、AOP组成</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#31-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8F%8F%E8%BF%B0"><span class="post-toc-text"> 31、抽象类描述</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#32-sql%E6%9F%A5%E8%AF%A2%E9%A2%985~8%E9%81%93%E9%A2%98%E8%80%83%E5%AF%9F%E5%9F%BA%E7%A1%80%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="post-toc-text"> 32、SQL查询题5~8道题，考察基础的查询和数据库基础知识</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#33-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="post-toc-text"> 33、基础算法排序复杂度</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#34-java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%A2%98%E8%80%83%E5%AF%9F"><span class="post-toc-text"> 34、java设计模式题考察</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#35-%E9%9D%99%E6%80%81%E7%B1%BB%E4%BF%AE%E9%A5%B0"><span class="post-toc-text"> 35、静态类修饰</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#36-java%E9%9B%86%E5%90%882~3%E9%81%93%E9%A2%98"><span class="post-toc-text"> 36、java集合2~3道题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3"><span class="post-toc-text"> 主要接口</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="post-toc-text"> 实现类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="post-toc-text"> 其他工具类</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#37-redis%E7%9B%B8%E5%85%B3-2~3%E9%81%93%E9%A2%98"><span class="post-toc-text"> 37、redis相关 2~3道题</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#38-%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="post-toc-text"> 38、#{}和${}区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#39-mybatis-xml%E6%96%87%E4%BB%B6%E4%B8%AD%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98"><span class="post-toc-text"> 39、mybatis xml文件中标签问题</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#40-springbootapplication%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E6%B3%A8%E8%A7%A3"><span class="post-toc-text"> 40、@springbootapplication包含哪些注解</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#41-linux%E6%96%87%E4%BB%B6%E8%B5%8B%E6%9D%83744%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="post-toc-text"> 41、Linux文件赋权744是什么意思</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#42-linux%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%AE%9E%E6%97%B6%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%91%BD%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88"><span class="post-toc-text"> 42、Linux查看当前实时进程的命令是什么</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#43-vi%E7%BC%96%E8%BE%91%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%88%A04%E8%A1%8C%E8%B7%9F%E5%85%A8%E5%88%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="post-toc-text"> 43、vi编辑文件模式下删4行跟全删的命令分别是什么</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#44-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%E6%93%8D%E4%BD%9C%E5%A6%82%E4%BD%95%E4%B8%8D%E5%BD%B1%E5%93%8Ddml%E6%93%8D%E4%BD%9C"><span class="post-toc-text"> 44、数据库进行数据清理操作如何不影响dml操作</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#45-linux%E5%91%BD%E4%BB%A4%E5%92%8C%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="post-toc-text"> 45、linux命令和权限问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="post-toc-text"> 基本命令</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="post-toc-text"> 权限管理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-4"><span class="post-toc-text"> 注意事项</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#46-java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="post-toc-text"> 46、java基础语法 接口、抽象类、继承关系</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8E%A5%E5%8F%A3interface-2"><span class="post-toc-text"> 接口（Interface）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BBabstract-class-2"><span class="post-toc-text"> 抽象类（Abstract Class）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BBinheritance"><span class="post-toc-text"> 继承关系（Inheritance）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="post-toc-text"> 多重继承与接口</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-5"><span class="post-toc-text"> 注意事项</span></a></li></ol></li></ol>
            
        
        <div class=".article-gallery"><h2 id="1-spring-事务-aop相关注解"><a class="markdownIt-Anchor" href="#1-spring-事务-aop相关注解"></a> 1、Spring、事务、AOP相关注解</h2>
<ol>
<li class="lvl-3"><strong>Spring事务管理相关注解</strong>
<ul class="lvl-2">
<li class="lvl-5"><code>@Transactional</code>: 用于声明事务，可以应用于类或方法上。若应用于类，则类中所有方法均受事务管理；若应用于方法，则仅该方法受事务管理。</li>
<li class="lvl-5">相关属性包括：
<ul class="lvl-4">
<li class="lvl-7"><code>value</code>: 指定事务管理器的bean名称。</li>
<li class="lvl-7"><code>transactionManager</code>: 指定事务管理器。</li>
<li class="lvl-7"><code>timeout</code>: 设置事务超时时间。</li>
<li class="lvl-7"><code>readOnly</code>: 指定事务是否为只读。</li>
<li class="lvl-7"><code>rollbackFor</code>: 指定遇到指定异常时回滚事务。</li>
<li class="lvl-7"><code>noRollbackFor</code>: 指定遇到指定异常时不回滚事务。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3"><strong>Spring AOP相关注解</strong>
<ul class="lvl-2">
<li class="lvl-5"><code>@Aspect</code>: 定义一个切面。</li>
<li class="lvl-5"><code>@Pointcut</code>: 定义切点，用于指定哪些方法可以被通知。</li>
<li class="lvl-5">通知注解：
<ul class="lvl-4">
<li class="lvl-7"><code>@Before</code>: 在方法执行前执行通知。</li>
<li class="lvl-7"><code>@After</code>: 不论方法执行是否成功，都在方法执行后执行通知。</li>
<li class="lvl-7"><code>@AfterReturning</code>: 在方法成功执行后执行通知。</li>
<li class="lvl-7"><code>@AfterThrowing</code>: 在方法抛出异常后执行通知。</li>
<li class="lvl-7"><code>@Around</code>: 在方法执行前后执行通知，可以控制方法的执行。</li>
</ul>
</li>
<li class="lvl-5"><code>@Order</code>: 指定切面的执行顺序。</li>
<li class="lvl-5"><code>@EnableAspectJAutoProxy</code>: 启用AspectJ自动代理，使切面生效。<br />
<strong>最终答案</strong><br />
<strong>Spring中与事务、AOP相关的注解主要包括@Transactional、@Aspect、@Pointcut、@Before、@After、@AfterReturning、@AfterThrowing、@Around、@Order和@EnableAspectJAutoProxy。</strong></li>
</ul>
</li>
</ol>
<h2 id="2-java基础继承-接口-多线程"><a class="markdownIt-Anchor" href="#2-java基础继承-接口-多线程"></a> 2、java基础(继承、接口、多线程)</h2>
<p>继承：允许子类复用父类的代码，并可以扩展或重写父类的方法。</p>
<p>接口：定义了一组方法，实现接口的类必须提供这些方法的具体实现。</p>
<p>多线程：允许程序同时执行多个任务，可以通过继承 Thread 类或实现 Runnable 接口来创建线程。</p>
<h2 id="3-正则表达式"><a class="markdownIt-Anchor" href="#3-正则表达式"></a> 3、正则表达式</h2>
<p>正则表达式是一种用于匹配和处理文本的强大工具。它可以用于验证输入、提取信息、替换文本等操作。</p>
<h2 id="4-数据库索引-三范式-gbase-大数据"><a class="markdownIt-Anchor" href="#4-数据库索引-三范式-gbase-大数据"></a> 4、数据库(索引、三范式、Gbase、大数据)</h2>
<p>索引：用于提高数据库查询性能的一种数据结构。可以加速数据检索，减少磁盘 I/O。</p>
<p>三范式：数据库设计的基本原则，包括第一范式（确保每列都是原子性的）、第二范式（确保表中的每个非主属性完全依赖于主键）和第三范式（确保表中的每个非主属性不依赖于其他非主属性）。</p>
<p>Gbase：一种关系型数据库管理系统，具有高性能、高可用性和可扩展性。</p>
<p>大数据：指处理和分析大规模数据的技术和方法。大数据技术包括分布式计算、数据存储和分析等。</p>
<h2 id="5-linux基础命令-vim操作-权限"><a class="markdownIt-Anchor" href="#5-linux基础命令-vim操作-权限"></a> 5、Linux(基础命令、vim操作、权限)</h2>
<p>基础命令：包括文件和目录操作、进程管理、网络配置等。</p>
<p>vim操作：是一个强大的文本编辑器，用于编辑文本文件。</p>
<p>权限：Linux系统中的文件和目录权限控制，包括所有者、组和其他用户的读、写和执行权限。</p>
<h2 id="6-编程题-给定一个int数组-数组内三个数相加-求最大值-数据范围为-10000-到10000-数组最少包含3个数字"><a class="markdownIt-Anchor" href="#6-编程题-给定一个int数组-数组内三个数相加-求最大值-数据范围为-10000-到10000-数组最少包含3个数字"></a> 6、编程题  给定一个int数组 数组内三个数相加 求最大值  数据范围为-10000 到10000 数组最少包含3个数字</h2>
<p>要解决这个问题，我们可以通过遍历数组中的所有可能的三元组，计算它们的和，并找到其中的最大值。由于数组的长度可能很大，我们需要确保算法的效率。</p>
<h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路：</h3>
<ol>
<li class="lvl-3">
<p><strong>暴力法</strong>：直接遍历所有可能的三元组，计算它们的和，并记录最大值。这种方法的时间复杂度为 O(n^3)，适用于小规模数据。</p>
</li>
<li class="lvl-3">
<p><strong>排序法</strong>：先对数组进行排序，然后固定一个数，使用双指针法找到另外两个数，使得三数之和最大。这种方法的时间复杂度为 O(n^2)，适用于大规模数据。</p>
</li>
</ol>
<h3 id="方法-1暴力法"><a class="markdownIt-Anchor" href="#方法-1暴力法"></a> 方法 1：暴力法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxThreeSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxThreeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">currentSum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[k];</span><br><span class="line">                    <span class="keyword">if</span> (currentSum &gt; maxSum) &#123;</span><br><span class="line">                        maxSum = currentSum;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Maximum three sum is: &quot;</span> + maxThreeSum(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法-2排序法"><a class="markdownIt-Anchor" href="#方法-2排序法"></a> 方法 2：排序法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxThreeSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxThreeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 最大的三个数之和</span></span><br><span class="line">        <span class="keyword">return</span> nums[n - <span class="number">1</span>] + nums[n - <span class="number">2</span>] + nums[n - <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Maximum three sum is: &quot;</span> + maxThreeSum(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解释"><a class="markdownIt-Anchor" href="#解释"></a> 解释：</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>暴力法</strong>：通过三重循环遍历所有可能的三元组，计算它们的和，并记录最大值。这种方法简单直接，但时间复杂度较高。</p>
</li>
<li class="lvl-2">
<p><strong>排序法</strong>：先对数组进行排序，然后直接取最后三个数相加，因为它们是数组中最大的三个数。这种方法的时间复杂度主要由排序决定，为 O(n log n)，比暴力法更高效。</p>
</li>
</ul>
<h3 id="测试用例"><a class="markdownIt-Anchor" href="#测试用例"></a> 测试用例：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;Maximum three sum is: &quot;</span> + maxThreeSum(nums1)); <span class="comment">// 输出 12</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] nums2 = &#123;-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;Maximum three sum is: &quot;</span> + maxThreeSum(nums2)); <span class="comment">// 输出 -6</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] nums3 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;Maximum three sum is: &quot;</span> + maxThreeSum(nums3)); <span class="comment">// 输出 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果数组长度较小（例如小于 100），可以使用暴力法。</p>
</li>
<li class="lvl-2">
<p>如果数组长度较大，建议使用排序法，因为它更高效。</p>
</li>
</ul>
<h2 id="7-linux基础命令"><a class="markdownIt-Anchor" href="#7-linux基础命令"></a> 7、linux基础命令</h2>
<ol>
<li class="lvl-3">
<p><strong>文件和目录操作</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>ls</code>：列出目录中的文件和子目录。</li>
<li class="lvl-5"><code>cd</code>：改变当前工作目录。</li>
<li class="lvl-5"><code>mkdir</code>：创建新目录。</li>
<li class="lvl-5"><code>rm</code>：删除文件或目录。</li>
<li class="lvl-5"><code>cp</code>：复制文件或目录。</li>
<li class="lvl-5"><code>mv</code>：移动或重命名文件或目录。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>文件内容操作</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>cat</code>：显示文件内容。</li>
<li class="lvl-5"><code>head</code>：显示文件开头的内容。</li>
<li class="lvl-5"><code>tail</code>：显示文件结尾的内容。</li>
<li class="lvl-5"><code>grep</code>：在文件中搜索文本。</li>
<li class="lvl-5"><code>sed</code>：对文件进行编辑。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>进程管理</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>ps</code>：列出当前正在运行的进程。</li>
<li class="lvl-5"><code>kill</code>：终止进程。</li>
<li class="lvl-5"><code>top</code>：显示实时进程状态。</li>
<li class="lvl-5"><code>bg</code>：将后台进程置于前台运行。</li>
<li class="lvl-5"><code>fg</code>：将后台进程置于前台运行。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>网络配置</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>ifconfig</code>：显示网络接口信息。</li>
<li class="lvl-5"><code>ping</code>：测试网络连接。</li>
<li class="lvl-5"><code>netstat</code>：显示网络连接、路由表和网络接口状态。</li>
<li class="lvl-5"><code>ssh</code>：远程登录到另一台计算机。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>用户和权限</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>whoami</code>：显示当前用户。</li>
<li class="lvl-5"><code>su</code>：切换用户。</li>
<li class="lvl-5"><code>chmod</code>：更改文件或目录的权限。</li>
<li class="lvl-5"><code>chown</code>：更改文件或目录的所有者。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>系统信息</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>uname</code>：显示系统信息。</li>
<li class="lvl-5"><code>uptime</code>：显示</li>
<li class="lvl-5"><code>free</code>：显示系统内存使用情况。</li>
<li class="lvl-5"><code>df</code>：显示磁盘空间使用情况。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>文件压缩和解压</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>tar</code>：创建、提取和压缩文件。</li>
<li class="lvl-5"><code>gzip</code>：压缩文件。</li>
<li class="lvl-5"><code>gunzip</code>：解压缩文件。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>文件搜索</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>find</code>：在文件系统中搜索文件。</li>
<li class="lvl-5"><code>locate</code>：快速查找文件。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>系统管理</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>reboot</code>：重启系统。</li>
<li class="lvl-5"><code>shutdown</code>：关闭系统。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>系统日志</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6"><code>dmesg</code>：显示系统启动信息。</li>
<li class="lvl-6"><code>journalctl</code>：显示系统日志。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>磁盘管理</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6"><code>fdisk</code>：管理磁盘分区。</li>
<li class="lvl-6"><code>mkfs</code>：格式化磁盘分区。</li>
<li class="lvl-6"><code>mount</code>：挂载文件系统。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>服务管理</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6"><code>systemctl</code>：管理系统服务。</li>
<li class="lvl-6"><code>service</code>：管理系统服务（旧版）。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>包管理</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6"><code>apt</code>：Ubuntu 和 Debian 系统的包管理工具。</li>
<li class="lvl-6"><code>yum</code>：Red Hat 和 CentOS 系统的包管理工具。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>系统更新</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6"><code>apt-get update</code>：更新软件包列表。</li>
<li class="lvl-6"><code>apt-get upgrade</code>：升级已安装的软件包。</li>
<li class="lvl-6"><code>yum update</code>：更新软件包列表。</li>
<li class="lvl-6"><code>yum upgrade</code>：升级已安装的软件包。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>系统监控</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6"><code>top</code>：显示实时进程状态。</li>
<li class="lvl-6"><code>htop</code>：交互式进程查看器。</li>
<li class="lvl-6"><code>vmstat</code>：显示虚拟内存统计信息。</li>
<li class="lvl-6"><code>iostat</code>：显示磁盘 I/O 统计信息。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>系统优化</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6"><code>sysctl</code>：调整系统内核参数。</li>
<li class="lvl-6"><code>tune2fs</code>：调整文件系统参数。</li>
<li class="lvl-6"><code>sysbench</code>：性能测试工具。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>系统安全</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6"><code>firewall-cmd</code>：管理防火墙。</li>
<li class="lvl-6"><code>iptables</code>：管理防火墙规则。</li>
<li class="lvl-6"><code>auditd</code>：系统审计。</li>
</ul>
</li>
</ol>
<h2 id="8-spring与springboot注解"><a class="markdownIt-Anchor" href="#8-spring与springboot注解"></a> 8、spring与springboot注解</h2>
<p>Spring 和 Spring Boot 提供了大量的注解来简化开发，以下是一些常见的注解及其用途：</p>
<h3 id="spring-常用注解"><a class="markdownIt-Anchor" href="#spring-常用注解"></a> Spring 常用注解</h3>
<ol>
<li class="lvl-3">
<p><strong>@Component</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于标记一个类为 Spring 的组件（Bean），Spring 会自动扫描并管理这些组件。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>@Service</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于标记一个类为服务层组件，通常用于业务逻辑层。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>@Repository</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于标记一个类为数据访问层组件，通常用于 DAO 层。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>@Controller</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于标记一个类为控制器组件，通常用于 MVC 模式中的控制器层。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>@Autowired</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于自动注入依赖，Spring 会自动找到匹配的 Bean 并注入。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>@Qualifier</strong></p>
<ul class="lvl-2">
<li class="lvl-5">当有多个相同类型的 Bean 时，用于指定具体的 Bean。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>@Configuration</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于标记一个类为配置类，通常与 <code>@Bean</code> 注解一起使用。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>@Bean</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于在配置类中定义一个 Bean，Spring 会管理这个 Bean 的生命周期。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>@Value</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于注入配置文件中的属性值。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@Scope</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于指定 Bean 的作用域，如 <code>singleton</code>、<code>prototype</code> 等。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@PostConstruct</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于标记一个方法，该方法在 Bean 初始化后执行。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@PreDestroy</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于标记一个方法，该方法在 Bean 销毁前执行。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@RequestMapping</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于映射 HTTP 请求到控制器方法。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@RequestParam</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于将 HTTP 请求参数绑定到方法参数。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@PathVariable</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于将 URL 中的模板变量绑定到方法参数。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@ResponseBody</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于将方法返回值直接写入 HTTP 响应体。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@RequestBody</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于将 HTTP 请求体绑定到方法参数。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@Transactional</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于声明事务管理，通常用于服务层方法。</li>
</ul>
</li>
</ol>
<h3 id="spring-boot-常用注解"><a class="markdownIt-Anchor" href="#spring-boot-常用注解"></a> Spring Boot 常用注解</h3>
<ol>
<li class="lvl-3">
<p><strong>@SpringBootApplication</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于标记一个类为 Spring Boot 应用的入口类，相当于 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code> 的组合。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>@EnableAutoConfiguration</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于启用 Spring Boot 的自动配置机制。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>@ComponentScan</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于指定 Spring 扫描组件的包路径。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>@RestController</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于标记一个类为 RESTful 控制器，相当于 <code>@Controller</code> 和 <code>@ResponseBody</code> 的组合。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>@GetMapping</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于映射 HTTP GET 请求到控制器方法。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>@PostMapping</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于映射 HTTP POST 请求到控制器方法。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>@PutMapping</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于映射 HTTP PUT 请求到控制器方法。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>@DeleteMapping</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于映射 HTTP DELETE 请求到控制器方法。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>@ConfigurationProperties</strong></p>
<ul class="lvl-2">
<li class="lvl-5">用于将配置文件中的属性绑定到一个 Java 对象。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@ConditionalOnProperty</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于根据配置文件中的属性条件来决定是否加载某个 Bean。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@ConditionalOnMissingBean</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于在某个 Bean 不存在时加载另一个 Bean。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@ConditionalOnClass</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于在某个类存在时加载某个 Bean。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@ConditionalOnMissingClass</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于在某个类不存在时加载某个 Bean。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@EnableConfigurationProperties</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于启用 <code>@ConfigurationProperties</code> 注解的功能。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@EnableScheduling</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于启用 Spring 的定时任务功能。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@Scheduled</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于标记一个方法为定时任务。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@Async</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于标记一个方法为异步执行。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@EnableCaching</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于启用 Spring 的缓存功能。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@Cacheable</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于标记一个方法的返回值可以被缓存。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@CacheEvict</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于标记一个方法可以清除缓存。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@CachePut</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于标记一个方法可以更新缓存。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@EnableWebSecurity</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于启用 Spring Security 的 Web 安全配置。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@EnableGlobalMethodSecurity</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于启用 Spring Security 的方法级安全配置。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@PreAuthorize</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于在方法执行前进行权限检查。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@PostAuthorize</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于在方法执行后进行权限检查。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@EnableJpaRepositories</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于启用 Spring Data JPA 的仓库功能。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@Entity</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于标记一个类为 JPA 实体。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@Table</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于指定 JPA 实体对应的数据库表。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@Id</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于标记 JPA 实体的主键字段。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@GeneratedValue</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于指定 JPA 实体主键的生成策略。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@Column</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于指定 JPA 实体字段对应的数据库列。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@Query</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于在 Spring Data JPA 中定义自定义查询。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@EnableTransactionManagement</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于启用 Spring 的事务管理功能。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@EnableAspectJAutoProxy</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于启用 Spring 的 AOP 功能。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@Aspect</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于标记一个类为切面。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@Pointcut</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于定义切点表达式。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@Before</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于在目标方法执行前执行切面逻辑。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@After</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于在目标方法执行后执行切面逻辑。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@Around</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于在目标方法执行前后执行切面逻辑。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@AfterReturning</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于在目标方法成功返回后执行切面逻辑。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@AfterThrowing</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于在目标方法抛出异常后执行切面逻辑。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@EnableDiscoveryClient</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于启用 Spring Cloud 的服务发现功能。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@EnableFeignClients</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于启用 Spring Cloud 的 Feign 客户端功能。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@EnableCircuitBreaker</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于启用 Spring Cloud 的断路器功能。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@HystrixCommand</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于标记一个方法为 Hystrix 命令。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@EnableZuulProxy</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于启用 Spring Cloud 的 Zuul 代理功能。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@EnableConfigServer</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于启用 Spring Cloud 的配置服务器功能。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@EnableEurekaServer</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于启用 Spring Cloud 的 Eureka 服务器功能。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@EnableHystrixDashboard</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于启用 Spring Cloud 的 Hystrix 仪表盘功能。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>@EnableTurbine</strong></p>
<ul class="lvl-2">
<li class="lvl-6">用于启用 Spring Cloud 的 Turbine 功能。</li>
</ul>
</li>
</ol>
<p>这些注解可以帮助开发者更高效地构建 Spring 和 Spring Boot 应用。</p>
<h2 id="9-重写与重载"><a class="markdownIt-Anchor" href="#9-重写与重载"></a> 9、重写与重载</h2>
<p><strong>重写（Override）</strong> 和 <strong>重载（Overload）</strong> 是 Java 中两个重要的概念，它们都与方法有关，但用途和行为完全不同。</p>
<hr />
<h3 id="1-重写override"><a class="markdownIt-Anchor" href="#1-重写override"></a> 1. <strong>重写（Override）</strong></h3>
<p>重写是指子类重新定义父类中已有的方法，以满足子类的特定需求。重写的方法必须与父类方法具有相同的 <strong>方法签名</strong>（方法名、参数列表和返回类型）。</p>
<h4 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>发生在继承关系中</strong>：子类重写父类的方法。</p>
</li>
<li class="lvl-2">
<p><strong>方法签名必须一致</strong>：方法名、参数列表和返回类型必须相同。</p>
</li>
<li class="lvl-2">
<p><strong>访问权限不能更严格</strong>：子类方法的访问权限不能比父类方法更严格（例如，父类方法是 <code>protected</code>，子类方法可以是 <code>public</code>，但不能是 <code>private</code>）。</p>
</li>
<li class="lvl-2">
<p><strong>异常不能更宽泛</strong>：子类方法抛出的异常不能比父类方法抛出的异常更宽泛。</p>
</li>
<li class="lvl-2">
<p><strong>使用 <code>@Override</code> 注解</strong>：建议在重写方法上添加 <code>@Override</code> 注解，以便编译器检查是否正确重写。</p>
</li>
</ul>
<h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        myDog.makeSound(); <span class="comment">// 输出: Dog barks</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="2-重载overload"><a class="markdownIt-Anchor" href="#2-重载overload"></a> 2. <strong>重载（Overload）</strong></h3>
<p>重载是指在同一个类中定义多个方法，它们具有相同的名字但不同的参数列表（参数类型、参数数量或参数顺序不同）。重载的方法可以根据传入的参数自动调用合适的方法。</p>
<h4 id="特点-2"><a class="markdownIt-Anchor" href="#特点-2"></a> 特点：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>发生在同一个类中</strong>：方法名相同，但参数列表不同。</p>
</li>
<li class="lvl-2">
<p><strong>返回值类型可以不同</strong>：重载不关心返回值类型，只关心参数列表。</p>
</li>
<li class="lvl-2">
<p><strong>访问权限可以不同</strong>：重载方法的访问权限可以不同。</p>
</li>
<li class="lvl-2">
<p><strong>与继承无关</strong>：重载不涉及继承关系。</p>
</li>
</ul>
<h4 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="comment">// 方法 1：两个整数相加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法 2：三个整数相加（参数数量不同）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法 3：两个浮点数相加（参数类型不同）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        System.out.println(calc.add(<span class="number">1</span>, <span class="number">2</span>));          <span class="comment">// 输出: 3</span></span><br><span class="line">        System.out.println(calc.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));      <span class="comment">// 输出: 6</span></span><br><span class="line">        System.out.println(calc.add(<span class="number">1.5</span>, <span class="number">2.5</span>));      <span class="comment">// 输出: 4.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="重写-vs-重载"><a class="markdownIt-Anchor" href="#重写-vs-重载"></a> 重写 vs 重载</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>重写（Override）</th>
<th>重载（Overload）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>定义位置</strong></td>
<td>子类重写父类的方法</td>
<td>同一个类中定义多个同名方法</td>
</tr>
<tr>
<td><strong>方法签名</strong></td>
<td>必须相同（方法名、参数列表、返回类型）</td>
<td>必须不同（参数列表不同）</td>
</tr>
<tr>
<td><strong>访问权限</strong></td>
<td>不能比父类方法更严格</td>
<td>可以不同</td>
</tr>
<tr>
<td><strong>返回值类型</strong></td>
<td>必须相同</td>
<td>可以不同</td>
</tr>
<tr>
<td><strong>异常</strong></td>
<td>不能抛出更宽泛的异常</td>
<td>可以不同</td>
</tr>
<tr>
<td><strong>作用</strong></td>
<td>实现多态，子类定制父类行为</td>
<td>提供方法的多版本，适应不同的参数需求</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>重写</strong> 用于子类重新定义父类方法，实现多态。</p>
</li>
<li class="lvl-2">
<p><strong>重载</strong> 用于在同一个类中提供多个方法版本，适应不同的参数需求。</p>
</li>
</ul>
<p>两者都是 Java 中实现代码复用和灵活性的重要机制。</p>
<h2 id="10-接口与抽象类"><a class="markdownIt-Anchor" href="#10-接口与抽象类"></a> 10、接口与抽象类</h2>
<p><strong>接口（Interface）</strong> 和 <strong>抽象类（Abstract Class）</strong> 是 Java 中两种重要的抽象机制，它们都可以用来定义规范和约束子类的行为，但它们在设计目的和使用场景上有显著的区别。</p>
<hr />
<h3 id="1-接口interface"><a class="markdownIt-Anchor" href="#1-接口interface"></a> 1. <strong>接口（Interface）</strong></h3>
<p>接口是一种完全抽象的类，用于定义一组方法规范，但不提供具体的实现。接口的核心目的是定义 <strong>“能做什么”</strong>，而不是 <strong>“怎么做”</strong>。</p>
<h4 id="特点-3"><a class="markdownIt-Anchor" href="#特点-3"></a> 特点：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>方法默认是抽象的</strong>：接口中的方法默认是 <code>public abstract</code> 的（Java 8 之前）。</p>
</li>
<li class="lvl-2">
<p><strong>不能包含具体实现</strong>：Java 8 之前，接口中的方法不能有方法体；Java 8 之后，可以使用 <code>default</code> 方法提供默认实现。</p>
</li>
<li class="lvl-2">
<p><strong>支持多继承</strong>：一个类可以实现多个接口。</p>
</li>
<li class="lvl-2">
<p><strong>字段默认是常量</strong>：接口中的字段默认是 <code>public static final</code> 的（即常量）。</p>
</li>
<li class="lvl-2">
<p><strong>用于定义行为规范</strong>：接口通常用于定义一组相关的行为规范，例如 <code>Runnable</code>、<code>Comparable</code> 等。</p>
</li>
</ul>
<h4 id="示例-3"><a class="markdownIt-Anchor" href="#示例-3"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123; <span class="comment">// Java 8 的默认方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is sleeping&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.makeSound(); <span class="comment">// 输出: Dog barks</span></span><br><span class="line">        dog.sleep();      <span class="comment">// 输出: Animal is sleeping</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="2-抽象类abstract-class"><a class="markdownIt-Anchor" href="#2-抽象类abstract-class"></a> 2. <strong>抽象类（Abstract Class）</strong></h3>
<p>抽象类是一种介于普通类和接口之间的类，它可以包含抽象方法（没有方法体）和具体方法（有方法体）。抽象类的核心目的是定义 <strong>“是什么”</strong> 和 <strong>“能做什么”</strong>。</p>
<h4 id="特点-4"><a class="markdownIt-Anchor" href="#特点-4"></a> 特点：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>可以包含抽象方法和具体方法</strong>：抽象类可以定义抽象方法（子类必须实现），也可以定义具体方法（子类可以直接继承）。</p>
</li>
<li class="lvl-2">
<p><strong>不能实例化</strong>：抽象类不能直接创建对象，必须通过子类实例化。</p>
</li>
<li class="lvl-2">
<p><strong>单继承</strong>：一个类只能继承一个抽象类。</p>
</li>
<li class="lvl-2">
<p><strong>可以包含字段和构造方法</strong>：抽象类可以定义字段和构造方法，用于初始化状态。</p>
</li>
<li class="lvl-2">
<p><strong>用于定义通用逻辑</strong>：抽象类通常用于定义一些通用的逻辑，供子类复用。</p>
</li>
</ul>
<h4 id="示例-4"><a class="markdownIt-Anchor" href="#示例-4"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123; <span class="comment">// 具体方法</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot; is sleeping&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>);</span><br><span class="line">        dog.makeSound(); <span class="comment">// 输出: Dog barks</span></span><br><span class="line">        dog.sleep();    <span class="comment">// 输出: Buddy is sleeping</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="接口-vs-抽象类"><a class="markdownIt-Anchor" href="#接口-vs-抽象类"></a> 接口 vs 抽象类</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>接口（Interface）</th>
<th>抽象类（Abstract Class）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>方法实现</strong></td>
<td>Java 8 之前只能有抽象方法；Java 8 之后可以有默认方法和静态方法</td>
<td>可以包含抽象方法和具体方法</td>
</tr>
<tr>
<td><strong>字段</strong></td>
<td>只能是常量（<code>public static final</code>）</td>
<td>可以是普通字段</td>
</tr>
<tr>
<td><strong>构造方法</strong></td>
<td>不能有构造方法</td>
<td>可以有构造方法</td>
</tr>
<tr>
<td><strong>继承</strong></td>
<td>支持多继承（一个类可以实现多个接口）</td>
<td>单继承（一个类只能继承一个抽象类）</td>
</tr>
<tr>
<td><strong>设计目的</strong></td>
<td>定义行为规范（“能做什么”）</td>
<td>定义通用逻辑和部分实现（“是什么”和“能做什么”）</td>
</tr>
<tr>
<td><strong>实例化</strong></td>
<td>不能实例化</td>
<td>不能实例化</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>定义一组行为规范，例如 <code>Runnable</code>、<code>Comparable</code></td>
<td>定义通用逻辑，例如模板方法模式</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="如何选择"><a class="markdownIt-Anchor" href="#如何选择"></a> 如何选择？</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>使用接口的场景</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">需要定义一组行为规范，且不关心具体实现。</li>
<li class="lvl-4">需要实现多继承。</li>
<li class="lvl-4">希望定义一组常量（接口中的字段默认是常量）。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>使用抽象类的场景</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">需要定义一些通用的逻辑，供子类复用。</li>
<li class="lvl-4">需要定义部分方法的实现，同时保留一些抽象方法供子类实现。</li>
<li class="lvl-4">需要定义字段或构造方法。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>接口</strong> 更注重行为规范，适合定义“能做什么”。</p>
</li>
<li class="lvl-2">
<p><strong>抽象类</strong> 更注重通用逻辑，适合定义“是什么”和“能做什么”。</p>
</li>
</ul>
<p>在实际开发中，接口和抽象类可以结合使用，例如通过抽象类实现接口的部分方法，再由子类完成剩余的实现。</p>
<h2 id="11-构造方法"><a class="markdownIt-Anchor" href="#11-构造方法"></a> 11、构造方法</h2>
<p><strong>构造方法（Constructor）</strong> 是 Java 中用于创建和初始化对象的特殊方法。它的名称必须与类名完全相同，且没有返回值类型（连 <code>void</code> 也没有）。构造方法在对象创建时自动调用，用于初始化对象的状态（例如为字段赋值）。</p>
<hr />
<h3 id="构造方法的特点"><a class="markdownIt-Anchor" href="#构造方法的特点"></a> 构造方法的特点</h3>
<ol>
<li class="lvl-3">
<p><strong>名称与类名相同</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">构造方法的名称必须与类名完全一致。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>没有返回值类型</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">构造方法没有返回值类型，甚至不能写 <code>void</code>。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>自动调用</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">当使用 <code>new</code> 关键字创建对象时，构造方法会自动调用。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>可以重载</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">一个类可以有多个构造方法（重载），只要它们的参数列表不同。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>默认构造方法</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">如果一个类没有显式定义构造方法，Java 会提供一个默认的无参构造方法。</li>
<li class="lvl-5">如果定义了任意一个构造方法，Java 将不再提供默认的无参构造方法。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>可以调用其他构造方法</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">使用 <code>this()</code> 可以在一个构造方法中调用同一个类的其他构造方法。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>不能被继承</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">构造方法不能被继承，子类必须定义自己的构造方法。</li>
</ul>
</li>
</ol>
<hr />
<h3 id="构造方法的语法"><a class="markdownIt-Anchor" href="#构造方法的语法"></a> 构造方法的语法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassName</span><span class="params">(参数列表)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="示例-5"><a class="markdownIt-Anchor" href="#示例-5"></a> 示例</h3>
<h4 id="1-无参构造方法"><a class="markdownIt-Anchor" href="#1-无参构造方法"></a> 1. 无参构造方法</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is barking&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 调用无参构造方法</span></span><br><span class="line">        dog.bark(); <span class="comment">// 输出: Unknown is barking</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-带参构造方法"><a class="markdownIt-Anchor" href="#2-带参构造方法"></a> 2. 带参构造方法</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is barking&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>); <span class="comment">// 调用带参构造方法</span></span><br><span class="line">        dog.bark(); <span class="comment">// 输出: Buddy is barking</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-构造方法重载"><a class="markdownIt-Anchor" href="#3-构造方法重载"></a> 3. 构造方法重载</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带一个参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带两个参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is barking and is &quot;</span> + age + <span class="string">&quot; years old&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 调用无参构造方法</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>); <span class="comment">// 调用带一个参数的构造方法</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Max&quot;</span>, <span class="number">3</span>); <span class="comment">// 调用带两个参数的构造方法</span></span><br><span class="line"></span><br><span class="line">        dog1.bark(); <span class="comment">// 输出: Unknown is barking and is 0 years old</span></span><br><span class="line">        dog2.bark(); <span class="comment">// 输出: Buddy is barking and is 0 years old</span></span><br><span class="line">        dog3.bark(); <span class="comment">// 输出: Max is barking and is 3 years old</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-使用-this-调用其他构造方法"><a class="markdownIt-Anchor" href="#4-使用-this-调用其他构造方法"></a> 4. 使用 <code>this()</code> 调用其他构造方法</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;Unknown&quot;</span>, <span class="number">0</span>); <span class="comment">// 调用带两个参数的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带两个参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is barking and is &quot;</span> + age + <span class="string">&quot; years old&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 调用无参构造方法</span></span><br><span class="line">        dog.bark(); <span class="comment">// 输出: Unknown is barking and is 0 years old</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="构造方法的作用"><a class="markdownIt-Anchor" href="#构造方法的作用"></a> 构造方法的作用</h3>
<ol>
<li class="lvl-3">
<p><strong>初始化对象状态</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">构造方法用于为对象的字段赋初始值。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>强制初始化</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">通过定义带参构造方法，可以强制调用者在创建对象时提供必要的参数。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>代码复用</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">使用 <code>this()</code> 可以在构造方法中调用其他构造方法，避免重复代码。</li>
</ul>
</li>
</ol>
<hr />
<h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3>
<ol>
<li class="lvl-3">
<p><strong>默认构造方法</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">如果类中没有定义任何构造方法，Java 会提供一个默认的无参构造方法。</li>
<li class="lvl-5">如果定义了任意一个构造方法，Java 将不再提供默认的无参构造方法。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>继承中的构造方法</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">子类的构造方法默认会调用父类的无参构造方法（通过 <code>super()</code>）。</li>
<li class="lvl-5">如果父类没有无参构造方法，子类必须显式调用父类的带参构造方法。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>私有构造方法</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">如果将构造方法定义为 <code>private</code>，则该类不能通过 <code>new</code> 关键字实例化。通常用于单例模式或工具类。</li>
</ul>
</li>
</ol>
<hr />
<h3 id="总结-4"><a class="markdownIt-Anchor" href="#总结-4"></a> 总结</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>构造方法是用于创建和初始化对象的特殊方法。</p>
</li>
<li class="lvl-2">
<p>构造方法可以重载，支持多种初始化方式。</p>
</li>
<li class="lvl-2">
<p>使用 <code>this()</code> 可以在构造方法中调用其他构造方法，实现代码复用。</p>
</li>
<li class="lvl-2">
<p>构造方法在对象创建时自动调用，是初始化对象状态的关键机制。</p>
</li>
</ul>
<h2 id="12-静态类"><a class="markdownIt-Anchor" href="#12-静态类"></a> 12、静态类</h2>
<p>在 Java 中，<strong>静态类（Static Class）</strong> 并不是一个独立的概念，但可以通过以下两种方式实现类似的功能：</p>
<ol>
<li class="lvl-3">
<p><strong>静态内部类（Static Nested Class）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">静态内部类是定义在另一个类内部的静态类。</li>
<li class="lvl-5">它不依赖于外部类的实例，可以直接通过外部类名访问。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>工具类（Utility Class）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">工具类是一个包含静态方法和静态字段的类，通常用于提供通用的功能。</li>
<li class="lvl-5">工具类的构造方法通常是私有的，防止实例化。</li>
</ul>
</li>
</ol>
<p>下面分别详细介绍这两种方式。</p>
<hr />
<h3 id="1-静态内部类static-nested-class"><a class="markdownIt-Anchor" href="#1-静态内部类static-nested-class"></a> 1. <strong>静态内部类（Static Nested Class）</strong></h3>
<p>静态内部类是定义在另一个类内部的静态类。它与外部类的实例无关，可以直接通过外部类名访问。</p>
<h4 id="特点-5"><a class="markdownIt-Anchor" href="#特点-5"></a> 特点：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>不依赖外部类实例</strong>：静态内部类不持有外部类的引用，因此可以直接创建。</p>
</li>
<li class="lvl-2">
<p><strong>可以直接访问外部类的静态成员</strong>：静态内部类可以访问外部类的静态字段和方法。</p>
</li>
<li class="lvl-2">
<p><strong>不能访问外部类的非静态成员</strong>：静态内部类不能直接访问外部类的实例字段和方法。</p>
</li>
</ul>
<h4 id="示例-6"><a class="markdownIt-Anchor" href="#示例-6"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="string">&quot;Static Field&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">instanceField</span> <span class="operator">=</span> <span class="string">&quot;Instance Field&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNestedClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Accessing static field: &quot;</span> + staticField);</span><br><span class="line">            <span class="comment">// System.out.println(instanceField); // 错误：不能访问外部类的实例字段</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建静态内部类的实例</span></span><br><span class="line">        OuterClass.<span class="type">StaticNestedClass</span> <span class="variable">nested</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>.StaticNestedClass();</span><br><span class="line">        nested.print(); <span class="comment">// 输出: Accessing static field: Static Field</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="2-工具类utility-class"><a class="markdownIt-Anchor" href="#2-工具类utility-class"></a> 2. <strong>工具类（Utility Class）</strong></h3>
<p>工具类是一种常见的静态类实现方式。它通常包含一组静态方法和静态字段，用于提供通用的功能。工具类的构造方法通常是私有的，防止实例化。</p>
<h4 id="特点-6"><a class="markdownIt-Anchor" href="#特点-6"></a> 特点：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>构造方法私有化</strong>：防止工具类被实例化。</p>
</li>
<li class="lvl-2">
<p><strong>所有方法和字段都是静态的</strong>：工具类的方法和字段通常都是静态的，可以直接通过类名调用。</p>
</li>
<li class="lvl-2">
<p><strong>不可继承</strong>：工具类通常被声明为 <code>final</code>，防止被继承。</p>
</li>
</ul>
<h4 id="示例-7"><a class="markdownIt-Anchor" href="#示例-7"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MathUtils</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法，防止实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MathUtils</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;Utility class cannot be instantiated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法：计算两个数的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法：计算两个数的乘积</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> MathUtils.add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 调用静态方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> MathUtils.multiply(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 调用静态方法</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum); <span class="comment">// 输出: Sum: 30</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Product: &quot;</span> + product); <span class="comment">// 输出: Product: 200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="静态类的使用场景"><a class="markdownIt-Anchor" href="#静态类的使用场景"></a> 静态类的使用场景</h3>
<ol>
<li class="lvl-3">
<p><strong>静态内部类的使用场景</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">当某个类只对另一个类有用时，可以将其定义为静态内部类。</li>
<li class="lvl-5">静态内部类不依赖外部类的实例，适合作为工具类或辅助类。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>工具类的使用场景</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">当需要提供一组通用的静态方法时，可以使用工具类。</li>
<li class="lvl-5">工具类通常用于数学计算、字符串处理、日期处理等场景。</li>
</ul>
</li>
</ol>
<hr />
<h3 id="注意事项-2"><a class="markdownIt-Anchor" href="#注意事项-2"></a> 注意事项</h3>
<ol>
<li class="lvl-3">
<p><strong>静态内部类与普通内部类的区别</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">普通内部类持有外部类的引用，而静态内部类不持有。</li>
<li class="lvl-5">普通内部类不能定义静态成员（除非是常量），而静态内部类可以。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>工具类的设计原则</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">工具类的构造方法应私有化，防止实例化。</li>
<li class="lvl-5">工具类的方法和字段应尽量设计为静态的。</li>
<li class="lvl-5">工具类通常声明为 <code>final</code>，防止被继承。</li>
</ul>
</li>
</ol>
<hr />
<h3 id="总结-5"><a class="markdownIt-Anchor" href="#总结-5"></a> 总结</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>静态内部类</strong>：不依赖外部类实例，可以直接访问外部类的静态成员。</p>
</li>
<li class="lvl-2">
<p><strong>工具类</strong>：提供一组静态方法，构造方法私有化，防止实例化。</p>
</li>
<li class="lvl-2">
<p>静态类和工具类是 Java 中实现代码复用和模块化的重要方式，适合用于封装通用功能。</p>
</li>
</ul>
<h2 id="13-权限修饰符等等"><a class="markdownIt-Anchor" href="#13-权限修饰符等等"></a> 13、权限修饰符等等</h2>
<p>在 Java 中，<strong>权限修饰符（Access Modifiers）</strong> 用于控制类、方法、字段和构造方法的访问权限。Java 提供了四种权限修饰符，分别是：</p>
<ol>
<li class="lvl-3">
<p><strong><code>public</code></strong>：公开的，任何地方都可以访问。</p>
</li>
<li class="lvl-3">
<p><strong><code>protected</code></strong>：受保护的，同一包内或子类中可以访问。</p>
</li>
<li class="lvl-3">
<p><strong><code>default</code>（包私有）</strong>：默认的，同一包内可以访问。</p>
</li>
<li class="lvl-3">
<p><strong><code>private</code></strong>：私有的，只有本类中可以访问。</p>
</li>
</ol>
<p>下面详细介绍这些权限修饰符的使用场景和规则。</p>
<hr />
<h3 id="1-public"><a class="markdownIt-Anchor" href="#1-public"></a> 1. <strong><code>public</code></strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>作用范围</strong>：任何地方都可以访问。</p>
</li>
<li class="lvl-2">
<p><strong>适用场景</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">类的公开接口（如工具类的方法）。</li>
<li class="lvl-4">需要被其他包或类广泛使用的类、方法或字段。</li>
</ul>
</li>
</ul>
<h4 id="示例-8"><a class="markdownIt-Anchor" href="#示例-8"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name; <span class="comment">// 公开字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123; <span class="comment">// 公开方法</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        dog.name = <span class="string">&quot;Buddy&quot;</span>; <span class="comment">// 访问公开字段</span></span><br><span class="line">        dog.eat(); <span class="comment">// 调用公开方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="2-protected"><a class="markdownIt-Anchor" href="#2-protected"></a> 2. <strong><code>protected</code></strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>作用范围</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">同一包内的类可以访问。</li>
<li class="lvl-4">子类可以访问（即使子类不在同一包中）。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>适用场景</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">需要被子类继承和重写的方法或字段。</li>
<li class="lvl-4">同一包内的类需要共享的成员。</li>
</ul>
</li>
</ul>
<h4 id="示例-9"><a class="markdownIt-Anchor" href="#示例-9"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name; <span class="comment">// 受保护字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123; <span class="comment">// 受保护方法</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is barking&quot;</span>); <span class="comment">// 访问父类的受保护字段</span></span><br><span class="line">        eat(); <span class="comment">// 调用父类的受保护方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="3-default包私有"><a class="markdownIt-Anchor" href="#3-default包私有"></a> 3. <strong><code>default</code>（包私有）</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>作用范围</strong>：同一包内的类可以访问。</p>
</li>
<li class="lvl-2">
<p><strong>适用场景</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">包内共享的类、方法或字段。</li>
<li class="lvl-4">不希望被包外访问的成员。</li>
</ul>
</li>
</ul>
<h4 id="示例-10"><a class="markdownIt-Anchor" href="#示例-10"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123; <span class="comment">// 默认权限（包私有）</span></span><br><span class="line">    String name; <span class="comment">// 默认权限字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123; <span class="comment">// 默认权限方法</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        dog.name = <span class="string">&quot;Buddy&quot;</span>; <span class="comment">// 访问默认权限字段</span></span><br><span class="line">        dog.eat(); <span class="comment">// 调用默认权限方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="4-private"><a class="markdownIt-Anchor" href="#4-private"></a> 4. <strong><code>private</code></strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>作用范围</strong>：只有本类中可以访问。</p>
</li>
<li class="lvl-2">
<p><strong>适用场景</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">类的内部实现细节（如字段、工具方法）。</li>
<li class="lvl-4">不希望被外部类访问的成员。</li>
</ul>
</li>
</ul>
<h4 id="示例-11"><a class="markdownIt-Anchor" href="#示例-11"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 私有字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123; <span class="comment">// 私有方法</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="comment">// 公开方法，用于访问私有字段</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performAction</span><span class="params">()</span> &#123;</span><br><span class="line">        eat(); <span class="comment">// 调用私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        dog.setName(<span class="string">&quot;Buddy&quot;</span>); <span class="comment">// 通过公开方法访问私有字段</span></span><br><span class="line">        dog.performAction(); <span class="comment">// 调用公开方法，间接调用私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="权限修饰符的总结"><a class="markdownIt-Anchor" href="#权限修饰符的总结"></a> 权限修饰符的总结</h3>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一包内</th>
<th>子类（不同包）</th>
<th>其他包</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public</code></td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
</tr>
<tr>
<td><code>default</code></td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><code>private</code></td>
<td>✔️</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="其他相关概念"><a class="markdownIt-Anchor" href="#其他相关概念"></a> 其他相关概念</h3>
<h4 id="1-final-修饰符"><a class="markdownIt-Anchor" href="#1-final-修饰符"></a> 1. <strong><code>final</code> 修饰符</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>作用</strong>：用于修饰类、方法或字段，表示不可改变。</p>
<ul class="lvl-2">
<li class="lvl-4"><code>final</code> 类：不能被继承。</li>
<li class="lvl-4"><code>final</code> 方法：不能被子类重写。</li>
<li class="lvl-4"><code>final</code> 字段：常量，值不能被修改。</li>
</ul>
</li>
</ul>
<h4 id="示例-12"><a class="markdownIt-Anchor" href="#示例-12"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MathUtils</span> &#123; <span class="comment">// final 类，不能被继承</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>; <span class="comment">// final 字段，常量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123; <span class="comment">// final 方法，不能重写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;This is a final method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="2-static-修饰符"><a class="markdownIt-Anchor" href="#2-static-修饰符"></a> 2. <strong><code>static</code> 修饰符</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>作用</strong>：用于修饰类、方法或字段，表示与类相关，而不是与实例相关。</p>
<ul class="lvl-2">
<li class="lvl-4"><code>static</code> 方法：可以直接通过类名调用。</li>
<li class="lvl-4"><code>static</code> 字段：类的所有实例共享同一个字段。</li>
<li class="lvl-4"><code>static</code> 内部类：不依赖外部类的实例。</li>
</ul>
</li>
</ul>
<h4 id="示例-13"><a class="markdownIt-Anchor" href="#示例-13"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// static 字段，共享</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123; <span class="comment">// static 方法</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123; <span class="comment">// static 方法</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Counter.increment(); <span class="comment">// 调用 static 方法</span></span><br><span class="line">        System.out.println(Counter.getCount()); <span class="comment">// 输出: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="3-abstract-修饰符"><a class="markdownIt-Anchor" href="#3-abstract-修饰符"></a> 3. <strong><code>abstract</code> 修饰符</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>作用</strong>：用于修饰类或方法，表示抽象。</p>
<ul class="lvl-2">
<li class="lvl-4"><code>abstract</code> 类：不能实例化，只能被继承。</li>
<li class="lvl-4"><code>abstract</code> 方法：没有方法体，必须由子类实现。</li>
</ul>
</li>
</ul>
<h4 id="示例-14"><a class="markdownIt-Anchor" href="#示例-14"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123; <span class="comment">// 抽象类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123; <span class="comment">// 实现抽象方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="总结-6"><a class="markdownIt-Anchor" href="#总结-6"></a> 总结</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>权限修饰符</strong>：控制类、方法、字段和构造方法的访问权限。</p>
</li>
<li class="lvl-2">
<p><strong><code>final</code></strong>：表示不可改变。</p>
</li>
<li class="lvl-2">
<p><strong><code>static</code></strong>：表示与类相关，而不是与实例相关。</p>
</li>
<li class="lvl-2">
<p><strong><code>abstract</code></strong>：表示抽象，需要子类实现。</p>
</li>
</ul>
<p>合理使用这些修饰符可以提高代码的安全性、可维护性和可扩展性。</p>
<h2 id="14-springboot注解"><a class="markdownIt-Anchor" href="#14-springboot注解"></a> 14、springboot注解</h2>
<p>见 8、spring与springboot注解</p>
<h2 id="15-线程命令"><a class="markdownIt-Anchor" href="#15-线程命令"></a> 15、线程命令</h2>
<p>Java中的线程命令主要包括以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">start()</span><br><span class="line">run()</span><br><span class="line">join()</span><br><span class="line">join(<span class="type">long</span> millis)</span><br><span class="line">join(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span><br><span class="line">sleep(<span class="type">long</span> millis)</span><br><span class="line">sleep(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span><br><span class="line"><span class="keyword">yield</span>()</span><br><span class="line">interrupt()</span><br><span class="line">isInterrupted()</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span></span><br><span class="line">isAlive()</span><br><span class="line">getId()</span><br><span class="line">getName()</span><br><span class="line">setName(String name)</span><br><span class="line">getPriority()</span><br><span class="line">setPriority(<span class="type">int</span> priority)</span><br><span class="line">isDaemon()</span><br><span class="line">setDaemon(<span class="type">boolean</span> on)</span><br><span class="line">currentThread()</span><br><span class="line">getAllStackTraces()</span><br><span class="line">getStackTrace()</span><br><span class="line">holdsLock(Object obj)</span><br><span class="line">enumerate(Thread[] tarray) <span class="comment">// 已过时</span></span><br><span class="line">activeCount() <span class="comment">// 已过时</span></span><br><span class="line">stop() <span class="comment">// 已废弃</span></span><br><span class="line">suspend() <span class="comment">// 已废弃</span></span><br><span class="line">resume() <span class="comment">// 已废弃</span></span><br><span class="line">LockSupport.park()</span><br><span class="line">LockSupport.unpark(Thread thread)</span><br></pre></td></tr></table></figure>
<p>这些方法用于创建、启动、控制和监控线程，以及管理线程的状态和属性。</p>
<p>其中，<br />
<code>start()</code>方法用于启动线程，<br />
<code>run()</code>方法包含线程的执行代码。<br />
<code>join()</code>方法使当前线程等待另一个线程完成执行，<br />
<code>sleep()</code>方法用于暂停当前线程的执行指定时间。<br />
<code>yield()</code>方法则用于暂停当前线程，让其他线程有机会执行。<br />
<code>interrupt()</code>方法用于中断线程的执行，而<code>isInterrupted()</code>方法用于检查线程是否被中断。<br />
<code>currentThread()</code>方法返回当前执行的线程，<code>getName()</code>和<code>setName(String name)</code>方法用于获取和设置线程的名字。<code>getPriority()</code>和<code>setPriority(int priority)</code>方法用于获取和设置线程的优先级。<br />
<code>isDaemon()</code>和<code>setDaemon(boolean on)</code>方法用于检查和设置线程是否为守护线程。<br />
<code>getId()</code>方法返回线程的ID，<code>isAlive()</code>方法检查线程是否还在执行。<br />
<code>getStackTrace()</code>方法获取线程的堆栈跟踪，<code>holdsLock(Object obj)</code>方法检查线程是否持有指定对象的监视器锁。<br />
<code>enumerate(Thread[] tarray)</code>和<code>activeCount()</code>方法用于枚举和计数活动的线程，但它们已过时。<br />
<code>stop()</code>、<code>suspend()</code>和<code>resume()</code>方法用于控制线程，但它们已废弃，不推荐使用。<br />
<code>LockSupport.park()</code>和<code>LockSupport.unpark(Thread thread)</code>方法用于线程的阻塞和唤醒。</p>
<p>Java线程命令主要包括 <code>start()</code>、<code>run()</code>、<code>join()</code>、<code>sleep()</code>、<code>yield()</code>、<code>interrupt()</code>、<code>isInterrupted()</code>、<code>currentThread()</code>、<code>getName()</code>、<code>setName(String name)</code>、<code>getPriority()</code>、<code>setPriority(int priority)</code>、<code>isDaemon()</code>、<code>setDaemon(boolean on)</code>、<code>getId()</code>、<code>isAlive()</code>、<code>getStackTrace()</code>、<code>holdsLock(Object obj)</code>，以及<code>LockSupport</code>类的<code>park()</code>和<code>unpark(Thread thread)</code>方法。</p>
<h2 id="16-接口与抽象类-继承实现"><a class="markdownIt-Anchor" href="#16-接口与抽象类-继承实现"></a> 16、接口与抽象类、继承实现</h2>
<p>接口与抽象类是Java中实现抽象和多态的两种不同方式，它们在继承和实现方面有一些关键的区别。</p>
<h3 id="抽象类abstract-class"><a class="markdownIt-Anchor" href="#抽象类abstract-class"></a> 抽象类（Abstract Class）</h3>
<ol>
<li class="lvl-3">
<p><strong>定义</strong>：抽象类是用<code>abstract</code>关键字定义的类，它可以包含抽象方法（没有方法体的方法）和具体方法（有方法体的方法）。</p>
</li>
<li class="lvl-3">
<p><strong>继承</strong>：其他类可以通过<code>extends</code>关键字继承抽象类。如果一个类继承了抽象类，它必须实现抽象类中所有的抽象方法，除非它自己也是一个抽象类。</p>
</li>
<li class="lvl-3">
<p><strong>构造器</strong>：抽象类可以有构造器，子类在继承抽象类时必须调用父类的构造器。</p>
</li>
<li class="lvl-3">
<p><strong>实例化</strong>：抽象类不能被实例化，只能被继承。</p>
</li>
<li class="lvl-3">
<p><strong>单继承</strong>：Java中的类只能继承一个抽象类，因为Java不支持多继承。</p>
</li>
</ol>
<h3 id="接口interface"><a class="markdownIt-Anchor" href="#接口interface"></a> 接口（Interface）</h3>
<ol>
<li class="lvl-3">
<p><strong>定义</strong>：接口是用<code>interface</code>关键字定义的，它只包含抽象方法（默认是<code>public abstract</code>）和常量（默认是<code>public static final</code>）。</p>
</li>
<li class="lvl-3">
<p><strong>实现</strong>：类通过<code>implements</code>关键字实现接口。一个类可以实现多个接口。</p>
</li>
<li class="lvl-3">
<p><strong>方法体</strong>：接口中的方法默认是没有方法体的，但Java 8及以后版本允许接口中包含默认方法（<code>default</code>关键字）和静态方法（<code>static</code>关键字），这些方法有方法体。</p>
</li>
<li class="lvl-3">
<p><strong>构造器</strong>：接口不能有构造器。</p>
</li>
<li class="lvl-3">
<p><strong>实例化</strong>：接口不能被实例化，只能被实现。</p>
</li>
<li class="lvl-3">
<p><strong>多实现</strong>：一个类可以实现多个接口，从而实现多重继承的效果。</p>
</li>
</ol>
<h3 id="继承与实现的比较"><a class="markdownIt-Anchor" href="#继承与实现的比较"></a> 继承与实现的比较</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>继承</strong>：一个类只能继承一个抽象类，继承关系表示“是一个”（is-a）的关系。</p>
</li>
<li class="lvl-2">
<p><strong>实现</strong>：一个类可以实现多个接口，实现关系表示“具有”（has-a）或“能够做”（can-do）的关系。</p>
</li>
</ul>
<h3 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类示例</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123; <span class="comment">// 具体方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;This animal eats.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口示例</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Movable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Movable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car is moving.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个类实现多个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Movable</span>, Flyable &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird is walking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结来说，抽象类和接口都是用于实现抽象和多态的工具，但它们在语法和使用场景上有一些重要的区别。抽象类更适合用于表示类的层次结构，而接口则更适合用于定义类的行为能力。</p>
<h2 id="17-mysqloracle"><a class="markdownIt-Anchor" href="#17-mysqloracle"></a> 17、mysql.oracle</h2>
<p>MySQL和Oracle是两种不同的关系型数据库管理系统（RDBMS），它们在架构、性能、可扩展性、成本和生态系统等方面都有所不同。以下是MySQL和Oracle的一些关键区别：</p>
<h3 id="1-开放性与许可"><a class="markdownIt-Anchor" href="#1-开放性与许可"></a> 1. 开放性与许可</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>MySQL</strong>：MySQL是一个开源数据库，采用GNU通用公共许可证（GPL）发布。这意味着用户可以自由地使用、修改和分发MySQL软件。</p>
</li>
<li class="lvl-2">
<p><strong>Oracle</strong>：Oracle数据库是一个闭源商业数据库，用户需要购买许可证才能使用。Oracle提供了多种许可证选项，包括企业版、标准版和Express Edition等。</p>
</li>
</ul>
<h3 id="2-性能与可扩展性"><a class="markdownIt-Anchor" href="#2-性能与可扩展性"></a> 2. 性能与可扩展性</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>MySQL</strong>：MySQL以其高性能和可扩展性而闻名，特别适合Web应用和中小型应用。它支持多种存储引擎，如InnoDB和MyISAM，可以根据不同的需求选择合适的存储引擎。</p>
</li>
<li class="lvl-2">
<p><strong>Oracle</strong>：Oracle数据库以其强大的性能和可扩展性著称，能够处理非常大的数据集和高并发的事务处理。它在企业级应用中广泛使用，特别是在需要高可用性和复杂事务处理的环境中。</p>
</li>
</ul>
<h3 id="3-成本"><a class="markdownIt-Anchor" href="#3-成本"></a> 3. 成本</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>MySQL</strong>：由于MySQL是开源的，它的使用成本相对较低。除了软件本身免费外，还有大量的社区支持和第三方服务提供商。</p>
</li>
<li class="lvl-2">
<p><strong>Oracle</strong>：Oracle数据库的许可证费用较高，尤其是对于企业级用户。此外，还需要考虑硬件、支持和服务的成本。</p>
</li>
</ul>
<h3 id="4-生态系统与支持"><a class="markdownIt-Anchor" href="#4-生态系统与支持"></a> 4. 生态系统与支持</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>MySQL</strong>：MySQL有一个活跃的社区，提供了大量的文档、教程和第三方工具。它也得到了许多开源项目和框架的支持。</p>
</li>
<li class="lvl-2">
<p><strong>Oracle</strong>：Oracle数据库拥有一个庞大的生态系统，包括各种工具、应用程序和专业服务。Oracle公司提供了全面的技术支持和咨询服务。</p>
</li>
</ul>
<h3 id="5-功能与特性"><a class="markdownIt-Anchor" href="#5-功能与特性"></a> 5. 功能与特性</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>MySQL</strong>：MySQL提供了基本的关系型数据库功能，包括事务支持、存储过程、触发器等。它也支持JSON数据类型和全文搜索等功能。</p>
</li>
<li class="lvl-2">
<p><strong>Oracle</strong>：Oracle数据库提供了丰富的高级功能，包括复杂的查询优化、高级安全性、数据仓库、商务智能、云计算集成等。</p>
</li>
</ul>
<h3 id="6-兼容性"><a class="markdownIt-Anchor" href="#6-兼容性"></a> 6. 兼容性</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>MySQL</strong>：MySQL兼容多种操作系统，包括Linux、Windows、macOS等。它也支持多种编程语言和开发框架。</p>
</li>
<li class="lvl-2">
<p><strong>Oracle</strong>：Oracle数据库同样兼容多种操作系统，并且提供了广泛的编程语言和开发框架支持。</p>
</li>
</ul>
<h3 id="7-学习曲线"><a class="markdownIt-Anchor" href="#7-学习曲线"></a> 7. 学习曲线</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>MySQL</strong>：由于其简单易用，MySQL的学习曲线相对较陡，适合初学者和小型项目。</p>
</li>
<li class="lvl-2">
<p><strong>Oracle</strong>：Oracle数据库功能强大，但也相对复杂，学习曲线较陡峭，适合有经验的数据库管理员和开发人员。</p>
</li>
</ul>
<p>选择MySQL还是Oracle取决于具体的应用需求、预算、技术支持和生态系统等因素。对于许多Web应用和中小型企业，MySQL是一个经济实惠且功能强大的选择。而对于需要高级功能、高可用性和企业级支持的大型企业，Oracle数据库可能是更好的选择。</p>
<h2 id="18-不是基础数据类型的选项"><a class="markdownIt-Anchor" href="#18-不是基础数据类型的选项"></a> 18、不是基础数据类型的选项</h2>
<p>Java是一种静态类型的语言，它有八种基本数据类型，这些类型直接由Java虚拟机（JVM）支持。以下是Java的基本数据类型及其描述：</p>
<ol>
<li class="lvl-3">
<p><strong>byte</strong>：8位有符号整数类型，范围从-128到127。</p>
</li>
<li class="lvl-3">
<p><strong>short</strong>：16位有符号整数类型，范围从-32,768到32,767。</p>
</li>
<li class="lvl-3">
<p><strong>int</strong>：32位有符号整数类型，范围从-2,147,483,648到2,147,483,647。</p>
</li>
<li class="lvl-3">
<p><strong>long</strong>：64位有符号整数类型，范围从-9,223,372,036,854,775,808到9,223,372,036,854,775,807。</p>
</li>
<li class="lvl-3">
<p><strong>float</strong>：32位单精度浮点数类型，遵循IEEE 754标准。</p>
</li>
<li class="lvl-3">
<p><strong>double</strong>：64位双精度浮点数类型，遵循IEEE 754标准。</p>
</li>
<li class="lvl-3">
<p><strong>char</strong>：16位无符号Unicode字符类型，范围从’\u0000’（即0）到’\uffff’（即65,535）。</p>
</li>
<li class="lvl-3">
<p><strong>boolean</strong>：表示真（true）或假（false）的类型。</p>
</li>
</ol>
<p>这些基本数据类型在Java中用于声明变量，它们各自有不同的用途和存储需求。例如，<code>int</code>通常用于大多数整数计算，而<code>float</code>和<code>double</code>用于需要小数的计算。<code>char</code>用于表示单个字符，<code>boolean</code>用于表示逻辑值。</p>
<h2 id="19-属于线程命令多选"><a class="markdownIt-Anchor" href="#19-属于线程命令多选"></a> 19、属于线程命令多选</h2>
<p>见 15、线程命令</p>
<h2 id="20-事务注解生效的选项"><a class="markdownIt-Anchor" href="#20-事务注解生效的选项"></a> 20、事务注解生效的选项</h2>
<p>在Java中，事务注解通常用于声明性事务管理，特别是在使用Spring框架时。要使事务注解生效，需要满足以下几个条件：</p>
<ol>
<li class="lvl-3">
<p><strong>启用事务管理</strong>：首先，你需要在Spring配置文件中启用事务管理。可以通过XML配置或Java配置来实现。例如，使用Java配置时，可以创建一个配置类并添加<code>@EnableTransactionManagement</code>注解：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 配置类的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>配置数据源和事务管理器</strong>：你需要配置数据源（DataSource）和事务管理器（TransactionManager）。例如，使用Spring JDBC时，可以配置DataSource和DataSourceTransactionManager：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DriverManagerDataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DriverManagerDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">transactionManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>使用事务注解</strong>：在需要事务管理的方法上使用<code>@Transactional</code>注解。例如：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyDao myDao;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myTransactionalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑代码</span></span><br><span class="line">        myDao.saveData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>注解的传播行为</strong>：<code>@Transactional</code>注解可以指定事务的传播行为、隔离级别、超时时间等属性。例如：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED, timeout = 30)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myTransactionalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 业务逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>事务的异常处理</strong>：默认情况下，<code>@Transactional</code>注解会回滚运行时异常（RuntimeException）和错误（Error），但不会回滚检查性异常（Checked Exception）。你可以通过<code>rollbackFor</code>和<code>noRollbackFor</code>属性来指定回滚和不回滚的异常类型。例如：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;SQLException.class&#125;, noRollbackFor = &#123;CustomException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myTransactionalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 业务逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>事务的代理机制</strong>：Spring使用代理机制来实现事务管理。这意味着事务注解只能作用于公共方法上，并且只有通过代理对象调用这些方法时，事务才会生效。如果你在同一个类内部调用带有<code>@Transactional</code>注解的方法，事务可能不会生效。</p>
</li>
</ol>
<p>通过以上步骤，你可以使事务注解在Spring应用程序中生效，从而实现声明性事务管理。</p>
<h2 id="21-接口与抽象类-继承实现描述正确的"><a class="markdownIt-Anchor" href="#21-接口与抽象类-继承实现描述正确的"></a> 21、接口与抽象类、继承实现描述正确的</h2>
<p>见 16、接口与抽象类、继承实现</p>
<h2 id="22-oracle-分页-那些选项是正确的"><a class="markdownIt-Anchor" href="#22-oracle-分页-那些选项是正确的"></a> 22、oracle 分页 那些选项是正确的</h2>
<p>在 Oracle 数据库中，分页查询通常使用 <code>ROWNUM</code> 或 <code>OFFSET FETCH</code> 子句来实现。以下是这两种方法的详细说明：</p>
<h3 id="使用-rownum-进行分页"><a class="markdownIt-Anchor" href="#使用-rownum-进行分页"></a> 使用 <code>ROWNUM</code> 进行分页</h3>
<p><code>ROWNUM</code> 是 Oracle 数据库中的一个伪列，用于限制查询结果的行数。要实现分页，可以结合子查询来使用 <code>ROWNUM</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> a.<span class="operator">*</span>, ROWNUM rnum <span class="keyword">FROM</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> your_conditions</span><br><span class="line">    ) a</span><br><span class="line">    <span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span> :endRow</span><br><span class="line">) <span class="keyword">WHERE</span> rnum <span class="operator">&gt;=</span> :startRow;</span><br></pre></td></tr></table></figure>
<p>在这个查询中：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>:startRow</code> 是要返回的第一行的行号。</p>
</li>
<li class="lvl-2">
<p><code>:endRow</code> 是要返回的最后一行的行号。</p>
</li>
</ul>
<p>例如，要获取第 11 到第 20 行，可以将 <code>:startRow</code> 设置为 11，<code>:endRow</code> 设置为 20。</p>
<h3 id="使用-offset-fetch-进行分页"><a class="markdownIt-Anchor" href="#使用-offset-fetch-进行分页"></a> 使用 <code>OFFSET FETCH</code> 进行分页</h3>
<p>Oracle 12c 及以上版本支持 <code>OFFSET FETCH</code> 子句，这使得分页查询更加直观和简洁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table</span><br><span class="line"><span class="keyword">WHERE</span> your_conditions</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> your_order_columns</span><br><span class="line"><span class="keyword">OFFSET</span> :<span class="keyword">offset</span> <span class="keyword">ROWS</span> <span class="keyword">FETCH</span> NEXT :pageSize <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br></pre></td></tr></table></figure>
<p>在这个查询中：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>:offset</code> 是要跳过的行数。</p>
</li>
<li class="lvl-2">
<p><code>:pageSize</code> 是要返回的行数。</p>
</li>
</ul>
<p>例如，要获取第 2 页，每页 10 行，可以将 <code>:offset</code> 设置为 10，<code>:pageSize</code> 设置为 10。</p>
<h3 id="注意事项-3"><a class="markdownIt-Anchor" href="#注意事项-3"></a> 注意事项</h3>
<ol>
<li class="lvl-3">
<p><strong>性能考虑</strong>：对于大数据量的表，使用 <code>ROWNUM</code> 进行分页可能会导致性能问题，因为 Oracle 需要生成所有行的 <code>ROWNUM</code>，然后过滤出需要的行。<code>OFFSET FETCH</code> 在性能上通常更好，因为它可以更有效地利用索引。</p>
</li>
<li class="lvl-3">
<p><strong>排序</strong>：无论是使用 <code>ROWNUM</code> 还是 <code>OFFSET FETCH</code>，都应该在 <code>ORDER BY</code> 子句中指定排序条件，以确保分页结果的正确性。</p>
</li>
<li class="lvl-3">
<p><strong>绑定变量</strong>：在实际应用中，建议使用绑定变量（<code>:startRow</code>, <code>:endRow</code>, <code>:offset</code>, <code>:pageSize</code>）来防止 SQL 注入，并提高查询的性能。</p>
</li>
<li class="lvl-3">
<p><strong>兼容性</strong>：<code>OFFSET FETCH</code> 子句仅在 Oracle 12c 及以上版本中可用。如果使用的是早期版本，只能使用 <code>ROWNUM</code> 进行分页。<br />
通过以上方法，你可以在 Oracle 数据库中实现分页查询。选择哪种方法取决于你的具体需求和 Oracle 数据库的版本。</p>
</li>
</ol>
<h2 id="23-组合索引-三个都完全生效的选项"><a class="markdownIt-Anchor" href="#23-组合索引-三个都完全生效的选项"></a> 23、组合索引 三个都完全生效的选项</h2>
<p>在 Oracle 数据库中，组合索引（也称为复合索引）是由多个列组成的索引。要确保组合索引中的所有列都能完全生效，需要满足以下条件：</p>
<ol>
<li class="lvl-3">
<p><strong>查询条件中包含索引的所有列</strong>：要让组合索引的所有列都生效，查询的 <code>WHERE</code> 子句中必须包含索引中的所有列。例如，如果有一个组合索引 <code>(A, B, C)</code>，那么查询条件中必须包含 <code>A</code>, <code>B</code>, 和 <code>C</code> 的条件。</p>
</li>
<li class="lvl-3">
<p><strong>查询条件中包含索引的前缀列</strong>：组合索引是基于列的顺序创建的，Oracle 可以使用索引的前缀列进行查询。例如，对于组合索引 <code>(A, B, C)</code>，查询条件中包含 <code>A</code> 和 <code>B</code> 的条件时，索引 <code>(A, B, C)</code> 仍然可以被使用，但只有 <code>A</code> 和 <code>B</code> 列会生效，<code>C</code> 列不会被使用。</p>
</li>
<li class="lvl-3">
<p><strong>查询条件中包含索引的全部列，并且列的顺序与索引一致</strong>：为了确保组合索引的所有列都生效，查询条件中不仅需要包含索引中的所有列，而且这些列的顺序应该与索引的顺序一致。例如，对于组合索引 <code>(A, B, C)</code>，查询条件应该是 <code>WHERE A = ? AND B = ? AND C = ?</code>。</p>
</li>
<li class="lvl-3">
<p><strong>避免使用函数或表达式</strong>：在查询条件中，如果对索引列使用函数或表达式，Oracle 可能无法使用该索引。例如，<code>WHERE UPPER(A) = 'VALUE'</code> 会阻止 Oracle 使用索引 <code>(A, B, C)</code>。</p>
</li>
<li class="lvl-3">
<p><strong>避免使用 <code>OR</code> 条件</strong>：如果查询条件中使用 <code>OR</code> 连接不同的条件，Oracle 可能无法有效地使用组合索引。在这种情况下，可能需要考虑使用位图索引或其他优化技术。</p>
</li>
<li class="lvl-3">
<p><strong>确保列的数据类型匹配</strong>：查询条件中列的数据类型必须与索引列的数据类型匹配。例如，如果索引列 <code>A</code> 是 <code>VARCHAR2</code> 类型，那么查询条件中 <code>A</code> 的值也应该是 <code>VARCHAR2</code> 类型。</p>
</li>
<li class="lvl-3">
<p><strong>避免使用通配符在前</strong>：在 <code>LIKE</code> 查询中，如果通配符（<code>%</code> 或 <code>_</code>）位于搜索模式的开头，Oracle 可能无法使用索引。例如，<code>WHERE A LIKE '%value'</code> 会阻止 Oracle 使用索引 <code>(A, B, C)</code>。<br />
通过满足以上条件，可以确保组合索引中的所有列都能完全生效，从而提高查询性能。在实际应用中，建议使用 <code>EXPLAIN PLAN</code> 或 <code>DBMS_XPLAN</code> 来分析查询计划，确保索引被正确使用。</p>
</li>
</ol>
<h2 id="24-java源文件扩展名"><a class="markdownIt-Anchor" href="#24-java源文件扩展名"></a> 24、java源文件扩展名</h2>
<ol>
<li class="lvl-3">
<p><strong>Java源文件的扩展名</strong></p>
<ul class="lvl-2">
<li class="lvl-5">Java源文件的扩展名是 <code>.java</code>。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Java源文件的结构</strong></p>
<ul class="lvl-2">
<li class="lvl-5">一个Java源文件通常包含一个公共类（<code>public class</code>），类名应与文件名相同。</li>
<li class="lvl-5">文件中可以包含多个非公共类。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>编译和运行</strong></p>
<ul class="lvl-2">
<li class="lvl-5">使用Java编译器 <code>javac</code> 将 <code>.java</code> 文件编译成字节码文件 <code>.class</code>。</li>
<li class="lvl-5">使用Java虚拟机 <code>java</code> 运行字节码文件。</li>
</ul>
</li>
</ol>
<p><strong>结论</strong><br />
Java源文件的扩展名是 <code>.java</code>。</p>
<h2 id="25-类成员访问控制符"><a class="markdownIt-Anchor" href="#25-类成员访问控制符"></a> 25、类成员访问控制符</h2>
<ol>
<li class="lvl-3">
<p><strong>类成员访问控制符</strong></p>
<ul class="lvl-2">
<li class="lvl-5">Java提供了四种访问控制符来控制类成员（字段和方法）的访问权限：
<ul class="lvl-4">
<li class="lvl-7"><code>public</code>: 公共的，可以被任何其他类访问。</li>
<li class="lvl-7"><code>private</code>: 私有的，只能被同一类中的代码访问。</li>
<li class="lvl-7"><code>protected</code>: 受保护的，可以被同一包中的类和所有子类访问。</li>
<li class="lvl-7">默认（无修饰符）: 可以被同一包中的类访问。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>访问控制符的使用</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><code>public</code> 通常用于类、方法和常量，以便它们可以被外部类访问。</li>
<li class="lvl-5"><code>private</code> 通常用于类的内部实现细节，不希望被外部类访问。</li>
<li class="lvl-5"><code>protected</code> 用于允许子类访问某些方法或字段，同时限制外部类的访问。</li>
<li class="lvl-5">默认访问控制符用于在同一包内共享类成员，而不希望它们被其他包中的类访问。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>访问控制的重要性</strong></p>
<ul class="lvl-2">
<li class="lvl-5">访问控制有助于封装，即隐藏类的内部实现细节，只暴露必要的接口。</li>
<li class="lvl-5">它提高了代码的可维护性和可扩展性，因为修改内部实现不会影响外部代码。</li>
</ul>
</li>
</ol>
<p><strong>结论</strong><br />
Java类成员的访问控制符包括 <code>public</code>、<code>private</code>、<code>protected</code> 和默认（无修饰符），它们用于控制类成员的访问权限，从而实现封装和提高代码的可维护性。</p>
<h2 id="26-三种基本控制结构"><a class="markdownIt-Anchor" href="#26-三种基本控制结构"></a> 26、三种基本控制结构</h2>
<ol>
<li class="lvl-3">
<p><strong>控制结构概述</strong></p>
<ul class="lvl-2">
<li class="lvl-5">控制结构决定了程序的执行流程，确保代码按照预定的逻辑顺序执行。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>三种基本控制结构</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>顺序结构</strong>
<ul class="lvl-4">
<li class="lvl-7">程序按照代码的书写顺序依次执行每个语句，没有分支或循环。</li>
</ul>
</li>
<li class="lvl-5"><strong>选择结构</strong>
<ul class="lvl-4">
<li class="lvl-7">根据条件的真假选择不同的执行路径。</li>
<li class="lvl-7">常用的关键字包括 <code>if</code>、<code>if-else</code> 和 <code>switch</code>。</li>
</ul>
</li>
<li class="lvl-5"><strong>循环结构</strong>
<ul class="lvl-4">
<li class="lvl-7">重复执行某一段代码，直到满足特定条件为止。</li>
<li class="lvl-7">常用的关键字包括 <code>for</code>、<code>while</code> 和 <code>do-while</code>。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>控制结构的作用</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>顺序结构</strong>：确保代码按部就班地执行，是最基础的执行方式。</li>
<li class="lvl-5"><strong>选择结构</strong>：使程序能够根据不同的条件做出决策，增强程序的灵活性。</li>
<li class="lvl-5"><strong>循环结构</strong>：提高代码的重复利用率，避免冗余代码的出现。</li>
</ul>
</li>
</ol>
<p><strong>结论</strong><br />
<strong>Java中的三种基本控制结构是顺序结构、选择结构和循环结构。</strong></p>
<h2 id="27-linux文件权限描述-3~4道左右"><a class="markdownIt-Anchor" href="#27-linux文件权限描述-3~4道左右"></a> 27、Linux文件权限描述、3~4道左右</h2>
<ol>
<li class="lvl-3">
<p><strong>Linux文件权限概述</strong></p>
<ul class="lvl-2">
<li class="lvl-5">在Linux文件系统中，每个文件和目录都拥有权限设置，用于控制不同用户对文件或目录的访问和操作。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>权限类别</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>用户（User）</strong>：文件或目录的所有者，通常是指创建该文件或目录的用户。</li>
<li class="lvl-5"><strong>组（Group）</strong>：一组用户，具有相同的权限级别。</li>
<li class="lvl-5"><strong>其他（Others）</strong>：系统中不属于用户或组的其他所有用户。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>权限类型</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>读（Read）</strong>：允许查看文件内容或列出目录内容。</li>
<li class="lvl-5"><strong>写（Write）</strong>：允许修改文件内容或目录中的文件。</li>
<li class="lvl-5"><strong>执行（Execute）</strong>：允许执行文件或进入目录。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>权限表示方法</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>符号表示法</strong></p>
<ul class="lvl-4">
<li class="lvl-7">使用10个字符表示，第一个字符表示文件类型（例如，<code>-</code>表示普通文件，<code>d</code>表示目录）。</li>
<li class="lvl-7">接下来的九个字符分为三组，每组三个字符，分别表示用户、组和其他的权限。</li>
<li class="lvl-7">每个权限用<code>r</code>（读）、<code>w</code>（写）、<code>x</code>（执行）或<code>-</code>（无权限）表示。</li>
<li class="lvl-7">例如，<code>-rwxr--r--</code>表示一个普通文件，所有者有读、写、执行权限，组和其他用户只有读权限。</li>
</ul>
</li>
<li class="lvl-5">
<p><strong>数字表示法</strong></p>
<ul class="lvl-4">
<li class="lvl-7">使用三位数字表示，每位数字对应用户、组和其他的权限。</li>
<li class="lvl-7">读、写、执行权限分别对应4、2、1。</li>
<li class="lvl-7">将每类权限的数字相加得到该类的权限值。</li>
<li class="lvl-7">例如，<code>rwx</code>对应<code>4+2+1=7</code>，<code>r--</code>对应<code>4+0+0=4</code>，因此<code>-rwxr--r--</code>的数字权限为<code>744</code>。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>权限示例</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>符号权限 <code>-rwxr--r--</code></strong></p>
<ul class="lvl-4">
<li class="lvl-7">文件类型：普通文件</li>
<li class="lvl-7">所有者权限：读、写、执行（<code>rwx</code>）</li>
<li class="lvl-7">组权限：读（<code>r--</code>）</li>
<li class="lvl-7">其他用户权限：读（<code>r--</code>）</li>
<li class="lvl-7">数字权限：<code>744</code></li>
</ul>
</li>
<li class="lvl-5">
<p><strong>符号权限 <code>drwxr-xr-x</code></strong></p>
<ul class="lvl-4">
<li class="lvl-7">文件类型：目录</li>
<li class="lvl-7">所有者权限：读、写、执行（<code>rwx</code>）</li>
<li class="lvl-7">组权限：读、执行（<code>r-x</code>）</li>
<li class="lvl-7">其他用户权限：读、执行（<code>r-x</code>）</li>
<li class="lvl-7">数字权限：<code>755</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>结论</strong><br />
<strong>Linux文件权限分为用户、组和其他三类，每类包括读、写和执行三种权限。权限可以用符号表示法（如 <code>-rwxr--r--</code>）或数字表示法（如 <code>744</code>）来描述。符号表示法中，第一个字符表示文件类型，后面的字符分为三组，每组三个字符分别表示用户、组和其他的权限。数字表示法中，读、写、执行分别对应4、2、1，每个类别的权限数字相加得到总的权限值。</strong></p>
<h2 id="28-服务器异常码"><a class="markdownIt-Anchor" href="#28-服务器异常码"></a> 28、服务器异常码</h2>
<ol>
<li class="lvl-3">
<p><strong>服务器异常码概述</strong></p>
<ul class="lvl-2">
<li class="lvl-5">服务器异常码，也称为HTTP状态码，是服务器响应客户端请求时返回的三位数字代码，用于表示请求的处理结果。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>常见异常码分类</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>信息性状态码（100-199）</strong></p>
<ul class="lvl-4">
<li class="lvl-7">100 Continue：服务器已接收到请求的初始部分，客户端应继续发送剩余部分。</li>
<li class="lvl-7">101 Switching Protocols：服务器根据客户端的请求切换协议。</li>
</ul>
</li>
<li class="lvl-5">
<p><strong>成功状态码（200-299）</strong></p>
<ul class="lvl-4">
<li class="lvl-7">200 OK：请求成功，服务器已成功处理请求。</li>
<li class="lvl-7">201 Created：请求成功，且服务器已创建一个新的资源。</li>
<li class="lvl-7">204 No Content：服务器成功处理了请求，但没有返回任何内容。</li>
</ul>
</li>
<li class="lvl-5">
<p><strong>重定向状态码（300-399）</strong></p>
<ul class="lvl-4">
<li class="lvl-7">301 Moved Permanently：请求的资源已永久移动到新位置。</li>
<li class="lvl-7">302 Found：请求的资源临时移动到新位置。</li>
<li class="lvl-7">304 Not Modified：资源未修改，客户端可以使用缓存的版本。</li>
</ul>
</li>
<li class="lvl-5">
<p><strong>客户端错误状态码（400-499）</strong></p>
<ul class="lvl-4">
<li class="lvl-7">400 Bad Request：请求语法错误，服务器无法理解。</li>
<li class="lvl-7">401 Unauthorized：请求要求用户的身份认证。</li>
<li class="lvl-7">403 Forbidden：服务器理解请求，但拒绝执行。</li>
<li class="lvl-7">404 Not Found：请求的资源不存在。</li>
<li class="lvl-7">405 Method Not Allowed：请求方法不被允许。</li>
</ul>
</li>
<li class="lvl-5">
<p><strong>服务器错误状态码（500-599）</strong></p>
<ul class="lvl-4">
<li class="lvl-7">500 Internal Server Error：服务器内部错误，无法完成请求。</li>
<li class="lvl-7">502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效响应。</li>
<li class="lvl-7">503 Service Unavailable：服务器暂时无法处理请求，可能过一段时间会恢复正常。</li>
<li class="lvl-7">504 Gateway Timeout：服务器作为网关或代理，等待上游服务器响应超时。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>异常码的作用</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>诊断问题</strong>：帮助开发者和系统管理员诊断和解决网络问题。</li>
<li class="lvl-5"><strong>用户体验</strong>：向用户传达请求的结果，如资源未找到或服务器繁忙。</li>
<li class="lvl-5"><strong>自动化处理</strong>：允许客户端根据状态码自动重试或采取其他行动。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>处理常见异常码的策略</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>404 Not Found</strong>：</p>
<ul class="lvl-4">
<li class="lvl-7">检查URL是否正确。</li>
<li class="lvl-7">确认资源是否已移动或删除。</li>
<li class="lvl-7">更新链接或提供替代资源。</li>
</ul>
</li>
<li class="lvl-5">
<p><strong>500 Internal Server Error</strong>：</p>
<ul class="lvl-4">
<li class="lvl-7">检查服务器日志以获取更多信息。</li>
<li class="lvl-7">确认服务器资源是否充足。</li>
<li class="lvl-7">重启服务器或应用服务。</li>
</ul>
</li>
<li class="lvl-5">
<p><strong>503 Service Unavailable</strong>：</p>
<ul class="lvl-4">
<li class="lvl-7">检查服务器负载情况。</li>
<li class="lvl-7">增加服务器资源或扩展容量。</li>
<li class="lvl-7">提供维护通知或预计恢复时间。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>结论</strong><br />
<strong>服务器异常码是HTTP协议中用于表示服务器响应状态的三位数字代码，分为信息性、成功、重定向、客户端错误和服务器错误五类。这些码帮助诊断网络问题、改善用户体验，并指导客户端如何处理响应。常见的异常码如404 Not Found和500 Internal Server Error需要根据具体情况采取相应的解决策略。</strong></p>
<h2 id="29-java常量的修饰符"><a class="markdownIt-Anchor" href="#29-java常量的修饰符"></a> 29、java常量的修饰符</h2>
<p>在Java中，常量通常使用<code>final</code>关键字来修饰，表示其值在初始化后不能被改变。为了提高代码的可读性和维护性，常量通常还使用<code>public</code>和<code>static</code>关键字来修饰，使得它们可以被类的实例共享，并且可以通过类名直接访问，而不需要创建类的实例。<br />
因此，一个典型的Java常量定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MY_CONSTANT</span> <span class="operator">=</span> <span class="string">&quot;ConstantValue&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>public</code>修饰符表示该常量是公共的，可以被其他类访问。</p>
</li>
<li class="lvl-2">
<p><code>static</code>修饰符表示该常量是类级别的，而不是实例级别的，因此可以通过类名直接访问。</p>
</li>
<li class="lvl-2">
<p><code>final</code>修饰符表示该常量的值在初始化后不能被改变。<br />
需要注意的是，虽然<code>final</code>关键字可以单独使用来创建常量，但通常会与<code>public</code>和<code>static</code>一起使用，以确保常量的可见性和共享性。</p>
</li>
</ul>
<h2 id="30-aop组成"><a class="markdownIt-Anchor" href="#30-aop组成"></a> 30、AOP组成</h2>
<p>AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，旨在通过将横切关注点（cross-cutting concerns）与业务逻辑分离，来提高代码的模块化和可维护性。AOP通常由以下几个核心概念组成：</p>
<ol>
<li class="lvl-3">
<p><strong>切面（Aspect）</strong>：<br />
切面是横切关注点的模块化，它封装了与多个类相关的行为。例如，日志记录、事务管理、安全性检查等都可以被封装为切面。</p>
</li>
<li class="lvl-3">
<p><strong>连接点（Join Point）</strong>：<br />
连接点是在程序执行过程中能够插入切面代码的点。在Java中，连接点通常是方法的调用、方法的执行、异常的抛出等。</p>
</li>
<li class="lvl-3">
<p><strong>切入点（Pointcut）</strong>：<br />
切入点是一个匹配连接点的谓词，它定义了切面将在哪些连接点上执行。切人点通常使用表达式来定义，例如，可以指定在所有以“get”开头的方法上执行切面代码。</p>
</li>
<li class="lvl-3">
<p><strong>通知（Advice）</strong>：<br />
通知是切面在切入点执行的代码。根据通知在连接点执行的时间，通知可以分为几种类型：</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>前置通知（Before Advice）</strong>：在方法执行之前执行。</li>
<li class="lvl-5"><strong>后置通知（After Advice）</strong>：无论方法是否成功完成，都在方法执行之后执行。</li>
<li class="lvl-5"><strong>返回通知（After Returning Advice）</strong>：在方法成功完成并返回结果后执行。</li>
<li class="lvl-5"><strong>异常通知（After Throwing Advice）</strong>：在方法抛出异常后执行。</li>
<li class="lvl-5"><strong>环绕通知（Around Advice）</strong>：在方法执行前后都执行，可以控制方法的执行。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>引入（Introduction）</strong>：<br />
引入允许切面为现有的类添加新的方法或属性，而不需要修改类的源代码。这可以用来实现接口或添加新的行为。</p>
</li>
<li class="lvl-3">
<p><strong>织入（Weaving）</strong>：<br />
织入是将切面代码插入到目标对象中的过程。织入可以在编译时、类加载时或运行时进行。</p>
</li>
</ol>
<p>AOP的实现通常依赖于一个AOP框架，如Spring AOP或AspectJ。这些框架提供了实现AOP所需的基础设施和工具，使得开发者可以更容易地将切面集成到他们的应用程序中。</p>
<h2 id="31-抽象类描述"><a class="markdownIt-Anchor" href="#31-抽象类描述"></a> 31、抽象类描述</h2>
<p>抽象类（Abstract Class）是面向对象编程中的一种概念，它允许开发者定义一些未实现的方法和成员变量，供子类继承并实现。抽象类不能被实例化，只能被继承。抽象类的主要目的是为了一组相关类提供一个公共的接口和部分实现，从而提高代码的可维护性和可扩展性。</p>
<p>抽象类的特点包括：</p>
<ol>
<li class="lvl-3">
<p><strong>抽象方法（Abstract Method）</strong>：<br />
抽象方法是没有实现的方法，它们只声明了方法的签名（方法名、参数列表和返回类型），而没有方法体。子类必须实现所有继承的抽象方法，除非子类本身也是抽象类。</p>
</li>
<li class="lvl-3">
<p><strong>具体方法（Concrete Method）</strong>：<br />
抽象类中可以包含具体的方法，这些方法有完整的实现，子类可以直接使用或重写这些方法。</p>
</li>
<li class="lvl-3">
<p><strong>构造器（Constructor）</strong>：<br />
抽象类可以有构造器，用于初始化抽象类的成员变量。子类在创建实例时，会调用抽象类的构造器。</p>
</li>
<li class="lvl-3">
<p><strong>成员变量</strong>：<br />
抽象类可以包含成员变量，这些变量可以是具体变量或抽象变量（通过抽象方法间接定义）。</p>
</li>
<li class="lvl-3">
<p><strong>继承</strong>：<br />
抽象类可以被子类继承，子类必须实现抽象类中的所有抽象方法，除非子类本身也是抽象类。</p>
</li>
<li class="lvl-3">
<p><strong>接口实现</strong>：<br />
抽象类可以实现一个或多个接口，提供接口方法的部分或全部实现。</p>
</li>
</ol>
<p>抽象类与接口有一些相似之处，但它们在目的和使用上有所不同。接口主要用于定义契约，而抽象类可以提供部分实现和共享代码。在Java中，一个类可以继承多个接口，但只能继承一个抽象类。</p>
<p>使用抽象类可以促进代码的复用和扩展，同时确保子类实现必要的功能。抽象类是实现开闭原则（对扩展开放，对修改关闭）的重要手段之一。</p>
<h2 id="32-sql查询题5~8道题考察基础的查询和数据库基础知识"><a class="markdownIt-Anchor" href="#32-sql查询题5~8道题考察基础的查询和数据库基础知识"></a> 32、SQL查询题5~8道题，考察基础的查询和数据库基础知识</h2>
<p><strong>SQL基础查询题目</strong><br />
以下是一些基础的SQL查询题目，旨在考察学生的数据库基础知识和SQL查询能力。</p>
<hr />
<ol>
<li class="lvl-3">
<p><strong>查询所有学生的姓名和年龄。</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>查询年龄大于18岁的学生的信息。</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>查询学生的平均年龄。</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(age) <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>查询学生信息，并按年龄降序排列。</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>查询每个班级的学生人数。</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> class_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>查询姓名中包含“王”字的学生。</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%王%&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>查询班级ID在1、2、3的学生。</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> class_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>查询所有唯一的班级ID。</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> class_id <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr />
<p><strong>假设的数据库表结构：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    age <span class="type">INT</span>,</span><br><span class="line">    class_id <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这些题目涵盖了SELECT、FROM、WHERE、ORDER BY、GROUP BY、LIKE、IN以及DISTINCT等基础SQL子句，有助于学生巩固数据库基础知识和提升SQL查询能力。</p>
<h2 id="33-基础算法排序复杂度"><a class="markdownIt-Anchor" href="#33-基础算法排序复杂度"></a> 33、基础算法排序复杂度</h2>
<p><strong>基础算法排序复杂度总结</strong><br />
以下是几种常见基础算法的排序复杂度总结：</p>
<ol>
<li class="lvl-3">
<p><strong>冒泡排序</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>时间复杂度</strong>：
<ul class="lvl-4">
<li class="lvl-10">最好情况：O(n)</li>
<li class="lvl-10">平均情况：O(n²)</li>
<li class="lvl-10">最坏情况：O(n²)</li>
</ul>
</li>
<li class="lvl-6"><strong>空间复杂度</strong>：O(1)</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>选择排序</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>时间复杂度</strong>：O(n²)</li>
<li class="lvl-6"><strong>空间复杂度</strong>：O(1)</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>插入排序</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>时间复杂度</strong>：
<ul class="lvl-4">
<li class="lvl-10">最好情况：O(n)</li>
<li class="lvl-10">平均情况：O(n²)</li>
<li class="lvl-10">最坏情况：O(n²)</li>
</ul>
</li>
<li class="lvl-6"><strong>空间复杂度</strong>：O(1)</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>快速排序</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>时间复杂度</strong>：
<ul class="lvl-4">
<li class="lvl-10">最好情况：O(n log n)</li>
<li class="lvl-10">平均情况：O(n log n)</li>
<li class="lvl-10">最坏情况：O(n²)</li>
</ul>
</li>
<li class="lvl-6"><strong>空间复杂度</strong>：O(log n)</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>归并排序</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>时间复杂度</strong>：O(n log n)</li>
<li class="lvl-6"><strong>空间复杂度</strong>：O(n)</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>堆排序</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>时间复杂度</strong>：O(n log n)</li>
<li class="lvl-6"><strong>空间复杂度</strong>：O(1)</li>
</ul>
</li>
</ol>
<hr />
<p>这些排序算法的时间和空间复杂度总结了它们在不同情况下的性能表现，有助于在实际应用中选择合适的排序方法。</p>
<h2 id="34-java设计模式题考察"><a class="markdownIt-Anchor" href="#34-java设计模式题考察"></a> 34、java设计模式题考察</h2>
<p><strong>Java设计模式题考察</strong><br />
Java设计模式是软件开发中常用的一套解决方案，用于解决特定类型的问题。在面试或考试中，Java设计模式的考察通常包括以下几个方面：</p>
<ol>
<li class="lvl-3">
<p><strong>单例模式（Singleton Pattern）</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>定义</strong>：确保一个类只有一个实例，并提供一个全局访问点。</li>
<li class="lvl-6"><strong>实现方式</strong>：
<ul class="lvl-4">
<li class="lvl-10">饿汉式（Eager Initialization）</li>
<li class="lvl-10">懒汉式（Lazy Initialization）</li>
<li class="lvl-10">双重检查锁定（Double-Checked Locking）</li>
<li class="lvl-10">静态内部类（Static Inner Class）</li>
</ul>
</li>
<li class="lvl-6"><strong>优缺点</strong>：
<ul class="lvl-4">
<li class="lvl-10">优点：控制资源的使用，避免资源浪费。</li>
<li class="lvl-10">缺点：单例模式可能会隐藏类之间的耦合关系，违反单一职责原则。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>工厂模式（Factory Pattern）</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>简单工厂模式（Simple Factory）</strong>
<ul class="lvl-4">
<li class="lvl-10"><strong>定义</strong>：一个工厂类根据传入的参数创建不同实例。</li>
</ul>
</li>
<li class="lvl-6"><strong>工厂方法模式（Factory Method）</strong>
<ul class="lvl-4">
<li class="lvl-10"><strong>定义</strong>：定义一个创建产品对象的工厂方法，由子类决定实例化哪一个具体类。</li>
</ul>
</li>
<li class="lvl-6"><strong>抽象工厂模式（Abstract Factory）</strong>
<ul class="lvl-4">
<li class="lvl-10"><strong>定义</strong>：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</li>
</ul>
</li>
<li class="lvl-6"><strong>优缺点</strong>：
<ul class="lvl-4">
<li class="lvl-10">优点：增加新的产品族或产品等级结构比较方便。</li>
<li class="lvl-10">缺点：增加新的产品族时需要修改抽象工厂的接口。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>观察者模式（Observer Pattern）</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>定义</strong>：定义对象之间的一对多依赖关系，当一个对象状态改变时，所有依赖它的对象都会收到通知并自动更新。</li>
<li class="lvl-6"><strong>实现方式</strong>：
<ul class="lvl-4">
<li class="lvl-10">使用<code>java.util.Observable</code>和<code>java.util.Observer</code>接口。</li>
<li class="lvl-10">手动实现通知机制。</li>
</ul>
</li>
<li class="lvl-6"><strong>优缺点</strong>：
<ul class="lvl-4">
<li class="lvl-10">优点：解耦了发布者和观察者，支持广播通信。</li>
<li class="lvl-10">缺点：观察者列表的维护需要额外的管理。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>策略模式（Strategy Pattern）</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>定义</strong>：定义一系列算法，将每个算法封装起来，并使它们可以互换。</li>
<li class="lvl-6"><strong>实现方式</strong>：
<ul class="lvl-4">
<li class="lvl-10">定义一个策略接口，包含具体算法的方法。</li>
<li class="lvl-10">实现具体策略类。</li>
<li class="lvl-10">定义一个上下文类，使用具体策略类。</li>
</ul>
</li>
<li class="lvl-6"><strong>优缺点</strong>：
<ul class="lvl-4">
<li class="lvl-10">优点：算法可以独立于使用它的客户变化，易于扩展。</li>
<li class="lvl-10">缺点：增加了系统中类的数量。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>装饰器模式（Decorator Pattern）</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>定义</strong>：动态地给一个对象添加一些额外的职责，而不改变其接口。</li>
<li class="lvl-6"><strong>实现方式</strong>：
<ul class="lvl-4">
<li class="lvl-10">定义一个接口，包含组件的行为。</li>
<li class="lvl-10">实现具体组件类。</li>
<li class="lvl-10">实现装饰器类，继承接口并包含一个组件实例。</li>
</ul>
</li>
<li class="lvl-6"><strong>优缺点</strong>：
<ul class="lvl-4">
<li class="lvl-10">优点：可以动态地添加或移除职责，保持了系统的灵活性。</li>
<li class="lvl-10">缺点：可能会导致类的数量增加。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>适配器模式（Adapter Pattern）</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>定义</strong>：将一个类的接口转换成客户期望的另一个接口，使得原本接口不兼容的类可以一起工作。</li>
<li class="lvl-6"><strong>实现方式</strong>：
<ul class="lvl-4">
<li class="lvl-10">类适配器：使用多继承。</li>
<li class="lvl-10">对象适配器：使用组合。</li>
</ul>
</li>
<li class="lvl-6"><strong>优缺点</strong>：
<ul class="lvl-4">
<li class="lvl-10">优点：提高了类的复用性，减少了类之间的耦合。</li>
<li class="lvl-10">缺点：增加了系统的复杂性。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>代理模式（Proxy Pattern）</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>定义</strong>：为其他对象提供一个代理以控制对这个对象的访问。</li>
<li class="lvl-6"><strong>类型</strong>：
<ul class="lvl-4">
<li class="lvl-10">远程代理</li>
<li class="lvl-10">虚拟代理</li>
<li class="lvl-10">保护代理</li>
<li class="lvl-10">智能引用代理</li>
</ul>
</li>
<li class="lvl-6"><strong>优缺点</strong>：
<ul class="lvl-4">
<li class="lvl-10">优点：可以控制对真实对象的访问，增加功能。</li>
<li class="lvl-10">缺点：增加了系统的复杂性。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>职责链模式（Chain of Responsibility Pattern）</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>定义</strong>：将请求沿着链传递，直到有一个处理者处理它。</li>
<li class="lvl-6"><strong>实现方式</strong>：
<ul class="lvl-4">
<li class="lvl-10">定义一个处理者接口，包含处理请求的方法。</li>
<li class="lvl-10">实现具体处理者类，决定是否处理请求并转发给下一个处理者。</li>
</ul>
</li>
<li class="lvl-6"><strong>优缺点</strong>：
<ul class="lvl-4">
<li class="lvl-10">优点：降低了对象之间的耦合，增强系统的灵活性。</li>
<li class="lvl-10">缺点：请求可能不会被处理，难以追踪。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>命令模式（Command Pattern）</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>定义</strong>：将请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化。</li>
<li class="lvl-6"><strong>实现方式</strong>：
<ul class="lvl-4">
<li class="lvl-10">定义一个命令接口，包含执行命令的方法。</li>
<li class="lvl-10">实现具体命令类，绑定接收者和行为。</li>
<li class="lvl-10">定义一个调用者类，持有命令对象并执行命令。</li>
</ul>
</li>
<li class="lvl-6"><strong>优缺点</strong>：
<ul class="lvl-4">
<li class="lvl-10">优点：解耦了请求的发送者和执行者，支持请求的排队和日志记录。</li>
<li class="lvl-10">缺点：可能会导致系统中有大量具体命令类。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>迭代器模式（Iterator Pattern）</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>定义</strong>：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露其内部的表示。</li>
<li class="lvl-6"><strong>实现方式</strong>：
<ul class="lvl-4">
<li class="lvl-10">定义一个迭代器接口，包含访问元素的方法。</li>
<li class="lvl-10">实现具体迭代器类。</li>
<li class="lvl-10">定义一个聚合接口，包含创建迭代器的方法。</li>
<li class="lvl-10">实现具体聚合类。</li>
</ul>
</li>
<li class="lvl-6"><strong>优缺点</strong>：
<ul class="lvl-4">
<li class="lvl-10">优点：支持以不同的方式遍历聚合对象，增加新的遍历方式比较方便。</li>
<li class="lvl-10">缺点：增加了系统的复杂性。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>在考察Java设计模式时，通常会要求考生理解各种模式的定义、适用场景、实现方式以及优缺点。此外，还可能要求考生编写代码实现特定的设计模式，或者分析现有代码中使用的设计模式。通过这些考察，可以评估考生对设计模式的理解和应用能力。</p>
<h2 id="35-静态类修饰"><a class="markdownIt-Anchor" href="#35-静态类修饰"></a> 35、静态类修饰</h2>
<p>在Java中，<code>static</code>关键字用于修饰类的成员，包括方法、变量、块和内部类。使用<code>static</code>修饰的成员属于类本身，而不是类的实例。这意味着无论创建多少个类的实例，<code>static</code>成员在内存中只有一个副本。以下是<code>static</code>修饰的不同成员的详细解释：</p>
<ol>
<li class="lvl-3">
<p><strong>静态变量（Static Variables）</strong></p>
<ul class="lvl-2">
<li class="lvl-6">
<p><strong>定义</strong>：使用<code>static</code>关键字修饰的变量称为静态变量，也称为类变量。</p>
</li>
<li class="lvl-6">
<p><strong>特点</strong>：</p>
<ul class="lvl-4">
<li class="lvl-10">所有实例共享同一个静态变量。</li>
<li class="lvl-10">静态变量在类加载时初始化，优先于实例变量。</li>
<li class="lvl-10">可以通过类名直接访问，无需创建类的实例。</li>
</ul>
</li>
<li class="lvl-6">
<p><strong>示例</strong>：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>静态方法（Static Methods）</strong></p>
<ul class="lvl-2">
<li class="lvl-6">
<p><strong>定义</strong>：使用<code>static</code>关键字修饰的方法称为静态方法，也称为类方法。</p>
</li>
<li class="lvl-6">
<p><strong>特点</strong>：</p>
<ul class="lvl-4">
<li class="lvl-10">可以通过类名直接调用，无需创建类的实例。</li>
<li class="lvl-10">静态方法只能访问静态成员，不能访问实例成员。</li>
</ul>
</li>
<li class="lvl-6">
<p><strong>示例</strong>：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">myStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a static method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>静态块（Static Blocks）</strong></p>
<ul class="lvl-2">
<li class="lvl-6">
<p><strong>定义</strong>：使用<code>static</code>关键字修饰的代码块称为静态块。</p>
</li>
<li class="lvl-6">
<p><strong>特点</strong>：</p>
<ul class="lvl-4">
<li class="lvl-10">静态块在类加载时执行，且只执行一次。</li>
<li class="lvl-10">通常用于初始化静态变量。</li>
</ul>
</li>
<li class="lvl-6">
<p><strong>示例</strong>：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static block executed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>静态内部类（Static Nested Classes）</strong></p>
<ul class="lvl-2">
<li class="lvl-6">
<p><strong>定义</strong>：使用<code>static</code>关键字修饰的内部类称为静态内部类。</p>
</li>
<li class="lvl-6">
<p><strong>特点</strong>：</p>
<ul class="lvl-4">
<li class="lvl-10">静态内部类不依赖于外部类的实例，可以直接通过外部类名访问。</li>
<li class="lvl-10">静态内部类可以访问外部类的静态成员，但不能访问实例成员。</li>
</ul>
</li>
<li class="lvl-6">
<p><strong>示例</strong>：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNestedClass</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This is a static nested class method.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>使用<code>static</code>修饰的成员在Java编程中非常常见，它们在不同的场景下提供了便利和优化。例如，静态方法常用于工具类中，提供一些通用的功能；静态变量用于记录类的全局状态；静态块用于执行一次性的初始化代码；静态内部类用于封装与外部类相关的辅助类，且不依赖于外部类的实例。</p>
<h2 id="36-java集合2~3道题"><a class="markdownIt-Anchor" href="#36-java集合2~3道题"></a> 36、java集合2~3道题</h2>
<p>Java集合框架（Java Collections Framework）是一组用于存储和操作对象集合的接口和类。它提供了多种数据结构，包括列表、集合、映射等，以及用于操作这些数据结构的算法。以下是Java集合框架中的一些主要接口和实现类：</p>
<h3 id="主要接口"><a class="markdownIt-Anchor" href="#主要接口"></a> 主要接口</h3>
<ol>
<li class="lvl-3">
<p><strong>Collection接口</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>子接口</strong>：
<ul class="lvl-4">
<li class="lvl-10"><strong>List接口</strong>：有序集合，允许重复元素。</li>
<li class="lvl-10"><strong>Set接口</strong>：无序集合，不包含重复元素。</li>
<li class="lvl-10"><strong>Queue接口</strong>：通常用于实现先进先出（FIFO）的数据结构。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Map接口</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>子接口</strong>：
<ul class="lvl-4">
<li class="lvl-10"><strong>SortedMap接口</strong>：维护键的自然顺序或指定的比较器顺序。</li>
<li class="lvl-10"><strong>NavigableMap接口</strong>：扩展了SortedMap，提供了导航方法。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="实现类"><a class="markdownIt-Anchor" href="#实现类"></a> 实现类</h3>
<ol>
<li class="lvl-3">
<p><strong>List接口的实现类</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6"><strong>ArrayList</strong>：基于动态数组实现，允许快速随机访问元素。</li>
<li class="lvl-6"><strong>LinkedList</strong>：基于双向链表实现，允许快速插入和删除元素。</li>
<li class="lvl-6"><strong>Vector</strong>：类似于ArrayList，但线程安全，支持同步访问。</li>
<li class="lvl-6"><strong>Stack</strong>：继承自Vector，实现了后进先出（LIFO）的行为。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Set接口的实现类</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6"><strong>HashSet</strong>：基于哈希表实现，不保证元素的顺序。</li>
<li class="lvl-6"><strong>LinkedHashSet</strong>：基于哈希表和链表实现，保持插入顺序。</li>
<li class="lvl-6"><strong>TreeSet</strong>：基于红黑树实现，保持自然顺序或指定的比较器顺序。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Queue接口的实现类</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6"><strong>LinkedList</strong>：实现了Queue接口，可以作为队列使用。</li>
<li class="lvl-6"><strong>PriorityQueue</strong>：基于优先堆实现，元素按照优先级排序。</li>
<li class="lvl-6"><strong>ArrayDeque</strong>：基于数组的双端队列实现，支持高效的插入和删除操作。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Map接口的实现类</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6"><strong>HashMap</strong>：基于哈希表实现，不保证键值对的顺序。</li>
<li class="lvl-6"><strong>LinkedHashMap</strong>：基于哈希表和链表实现，保持插入顺序。</li>
<li class="lvl-6"><strong>TreeMap</strong>：基于红黑树实现，保持键的自然顺序或指定的比较器顺序。</li>
<li class="lvl-6"><strong>Hashtable</strong>：类似于HashMap，但线程安全，支持同步访问。</li>
<li class="lvl-6"><strong>Properties</strong>：继承自Hashtable，用于存储属性集，键和值都是字符串。</li>
</ul>
</li>
</ol>
<h3 id="其他工具类"><a class="markdownIt-Anchor" href="#其他工具类"></a> 其他工具类</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Collections类</strong>：提供了操作集合的静态方法，如排序、查找、同步等。</p>
</li>
<li class="lvl-2">
<p><strong>Arrays类</strong>：提供了操作数组的静态方法，包括将数组转换为列表等。</p>
</li>
</ul>
<p>Java集合框架的设计遵循了接口和实现分离的原则，使得代码更加灵活和可扩展。通过使用不同的实现类，可以根据具体的需求选择最适合的数据结构。同时，集合框架还提供了丰富的算法，如排序、查找、同步等，方便开发者进行集合操作。</p>
<h2 id="37-redis相关-2~3道题"><a class="markdownIt-Anchor" href="#37-redis相关-2~3道题"></a> 37、redis相关 2~3道题</h2>
<h2 id="38-和区别"><a class="markdownIt-Anchor" href="#38-和区别"></a> 38、#{}和${}区别</h2>
<p>在Java中，<code>#&#123;&#125;和$&#123;&#125;</code> 是MyBatis框架中用于SQL语句占位符的两种不同语法，它们在处理参数时有不同的行为和用途。</p>
<ol>
<li class="lvl-3">
<p><strong><code>#&#123;&#125;</code>（预编译处理）</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>用途</strong>：用于将Java对象的属性值插入到SQL语句中，通常用于设置IN参数。</p>
</li>
<li class="lvl-5">
<p><strong>处理方式</strong>：MyBatis会将<code>#&#123;&#125;</code>中的内容视为一个参数，并使用PreparedStatement的<code>setXXX</code>方法来设置参数值。这种方式能够有效地防止SQL注入，因为参数值会被作为字符串处理，不会被解析为SQL代码的一部分。</p>
</li>
<li class="lvl-5">
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>#&#123;id&#125;</code>会被替换为一个预编译的参数占位符，如<code>?</code>，然后MyBatis会使用<code>setId</code>方法设置实际的ID值。</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong><code>$&#123;&#125;</code>（字符串替换）</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>用途</strong>：用于将Java对象的属性值直接插入到SQL语句中，通常用于动态生成SQL语句的一部分，如表名、列名等。</p>
</li>
<li class="lvl-5">
<p><strong>处理方式</strong>：MyBatis会将<code>$&#123;&#125;</code>中的内容直接替换为对应的字符串值，不做任何转义处理。这种方式可能会导致SQL注入漏洞，因为用户输入的内容会被直接拼接到SQL语句中。</p>
</li>
<li class="lvl-5">
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM $&#123;tableName&#125; WHERE id = #&#123;id&#125;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>$&#123;tableName&#125;</code>会被直接替换为<code>tableName</code>的字符串值，而<code>#&#123;id&#125;</code>则会被作为预编译的参数处理。</p>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用<code>#&#123;&#125;</code>可以防止SQL注入，适用于设置IN参数。</p>
</li>
<li class="lvl-2">
<p>使用<code>$&#123;&#125;</code>会直接替换字符串，适用于动态生成SQL语句的一部分，但需要谨慎使用，避免SQL注入风险。</p>
</li>
</ul>
<p>在实际开发中，应尽量使用<code>#&#123;&#125;</code>来传递参数，以确保SQL语句的安全性。只有在确实需要动态生成SQL语句的一部分（如表名、列名等）时，才使用<code>$&#123;&#125;</code>，并且要确保这些部分的值是可信的，不会被恶意用户篡改。</p>
<h2 id="39-mybatis-xml文件中标签问题"><a class="markdownIt-Anchor" href="#39-mybatis-xml文件中标签问题"></a> 39、mybatis xml文件中标签问题</h2>
<p>在MyBatis的XML映射文件中，标签是用来定义SQL语句和映射关系的。以下是一些常用的标签及其用途：</p>
<ol>
<li class="lvl-3">
<p><strong><code>&lt;mapper&gt;</code></strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>用途</strong>：定义一个映射器，通常对应一个Java接口。</li>
<li class="lvl-5"><strong>属性</strong>：
<ul class="lvl-4">
<li class="lvl-7"><code>namespace</code>：指定映射器的命名空间，通常是一个Java接口的全限定名。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong><code>&lt;select&gt;</code></strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>用途</strong>：定义一个查询语句。</li>
<li class="lvl-5"><strong>属性</strong>：
<ul class="lvl-4">
<li class="lvl-7"><code>id</code>：唯一标识这个查询语句，在Java接口中对应的方法名。</li>
<li class="lvl-7"><code>resultType</code>：指定查询结果映射到的Java类型。</li>
<li class="lvl-7"><code>parameterType</code>：指定输入参数的Java类型。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong><code>&lt;insert&gt;</code></strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>用途</strong>：定义一个插入语句。</li>
<li class="lvl-5"><strong>属性</strong>：
<ul class="lvl-4">
<li class="lvl-7"><code>id</code>：唯一标识这个插入语句，在Java接口中对应的方法名。</li>
<li class="lvl-7"><code>parameterType</code>：指定输入参数的Java类型。</li>
<li class="lvl-7"><code>useGeneratedKeys</code>：是否使用数据库生成的主键。</li>
<li class="lvl-7"><code>keyProperty</code>：指定Java对象中对应主键的属性。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong><code>&lt;update&gt;</code></strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>用途</strong>：定义一个更新语句。</li>
<li class="lvl-5"><strong>属性</strong>：
<ul class="lvl-4">
<li class="lvl-7"><code>id</code>：唯一标识这个更新语句，在Java接口中对应的方法名。</li>
<li class="lvl-7"><code>parameterType</code>：指定输入参数的Java类型。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong><code>&lt;delete&gt;</code></strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>用途</strong>：定义一个删除语句。</li>
<li class="lvl-5"><strong>属性</strong>：
<ul class="lvl-4">
<li class="lvl-7"><code>id</code>：唯一标识这个删除语句，在Java接口中对应的方法名。</li>
<li class="lvl-7"><code>parameterType</code>：指定输入参数的Java类型。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong><code>&lt;resultMap&gt;</code></strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>用途</strong>：定义结果集映射，用于复杂的结果集映射。</li>
<li class="lvl-5"><strong>属性</strong>：
<ul class="lvl-4">
<li class="lvl-7"><code>id</code>：唯一标识这个结果集映射。</li>
<li class="lvl-7"><code>type</code>：指定映射到的Java类型。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong><code>&lt;association&gt;</code></strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>用途</strong>：定义一对一的关联映射。</li>
<li class="lvl-5"><strong>属性</strong>：
<ul class="lvl-4">
<li class="lvl-7"><code>property</code>：指定Java对象中对应的属性。</li>
<li class="lvl-7"><code>javaType</code>：指定关联对象的Java类型。</li>
<li class="lvl-7"><code>column</code>：指定数据库表中的列名。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong><code>&lt;collection&gt;</code></strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>用途</strong>：定义一对多的关联映射。</li>
<li class="lvl-5"><strong>属性</strong>：
<ul class="lvl-4">
<li class="lvl-7"><code>property</code>：指定Java对象中对应的属性。</li>
<li class="lvl-7"><code>ofType</code>：指定集合中元素的Java类型。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong><code>&lt;sql&gt;</code></strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>用途</strong>：定义可重用的SQL代码片段。</li>
<li class="lvl-5"><strong>属性</strong>：
<ul class="lvl-4">
<li class="lvl-7"><code>id</code>：唯一标识这个SQL代码片段。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-4">
<p><strong><code>&lt;include&gt;</code></strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>用途</strong>：包含一个已定义的SQL代码片段。</li>
<li class="lvl-6"><strong>属性</strong>：
<ul class="lvl-4">
<li class="lvl-8"><code>refid</code>：引用的SQL代码片段的ID。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>这些标签帮助你定义和组织SQL语句，以及它们与Java对象之间的映射关系。通过合理使用这些标签，可以提高代码的可维护性和可读性。</p>
<h2 id="40-springbootapplication包含哪些注解"><a class="markdownIt-Anchor" href="#40-springbootapplication包含哪些注解"></a> 40、@springbootapplication包含哪些注解</h2>
<p><code>@SpringBootApplication</code> 是 Spring Boot 提供的一个注解，它是一个组合注解，包含了以下几个核心注解：</p>
<ol>
<li class="lvl-3">
<p><strong><code>@SpringBootConfiguration</code></strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>用途</strong>：这是一个配置类注解，类似于 Spring 框架中的 <code>@Configuration</code>，但它专门用于 Spring Boot 应用程序的配置。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong><code>@EnableAutoConfiguration</code></strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>用途</strong>：这个注解启用了 Spring Boot 的自动配置机制。Spring Boot 会根据类路径中的依赖和配置文件中的设置，自动配置 Spring 应用程序上下文。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong><code>@ComponentScan</code></strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>用途</strong>：这个注解启用了组件扫描，Spring Boot 会扫描注解所在类的包及其子包，查找并注册 Spring 组件，如 <code>@Controller</code>、<code>@Service</code>、<code>@Repository</code> 和 <code>@Component</code>。</li>
</ul>
</li>
</ol>
<p>通过使用 <code>@SpringBootApplication</code> 注解，你可以简化 Spring Boot 应用程序的配置，因为它集成了配置、自动配置和组件扫描的功能。通常，这个注解会应用在你的主应用程序类上，这个类中通常包含 <code>main</code> 方法来启动 Spring Boot 应用程序。</p>
<h2 id="41-linux文件赋权744是什么意思"><a class="markdownIt-Anchor" href="#41-linux文件赋权744是什么意思"></a> 41、Linux文件赋权744是什么意思</h2>
<p>在Linux系统中，文件和目录的权限通过一组数字来表示，这组数字被称为权限位。每个权限位代表不同的访问权限，分为三组：用户（User）、组（Group）和其他（Others）。每组权限位由三个数字组成，分别代表读（Read）、写（Write）和执行（Execute）权限。<br />
权限数字的含义如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>4：代表读权限（Read）</p>
</li>
<li class="lvl-2">
<p>2：代表写权限（Write）</p>
</li>
<li class="lvl-2">
<p>1：代表执行权限（Execute）</p>
</li>
</ul>
<p>这些数字可以相加来组合不同的权限。例如，7是4+2+1，表示读、写和执行权限；6是4+2，表示读和写权限；5是4+1，表示读和执行权限。<br />
当你说一个文件的权限是744时，这意味着：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>用户（User）</strong>：7，即4+2+1，表示用户拥有读、写和执行权限。</p>
</li>
<li class="lvl-2">
<p><strong>组（Group）</strong>：4，表示组成员拥有读权限。</p>
</li>
<li class="lvl-2">
<p><strong>其他（Others）</strong>：4，表示其他用户拥有读权限。</p>
</li>
</ul>
<p>总结来说，权限744意味着文件的所有者可以读、写和执行该文件，而组成员和其他用户只能读取该文件。</p>
<h2 id="42-linux查看当前实时进程的命令是什么"><a class="markdownIt-Anchor" href="#42-linux查看当前实时进程的命令是什么"></a> 42、Linux查看当前实时进程的命令是什么</h2>
<p>在Linux系统中，查看当前实时进程的命令是<code>ps</code>（process status）命令。<code>ps</code>命令可以显示系统中当前运行的进程的信息。要查看实时进程，可以使用<code>ps</code>命令的<code>-e</code>选项来显示所有进程，<code>-f</code>选项来显示完整的格式，或者使用<code>-aux</code>选项来显示所有进程的详细信息。<br />
例如，要查看所有进程的详细信息，可以使用以下命令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure>
<p>这个命令会显示所有进程的用户、进程ID（PID）、CPU使用率、内存使用率、启动时间、终端和命令等信息。</p>
<p>如果你想要实时监控进程的活动，可以使用<code>top</code>命令或者<code>htop</code>命令（如果已安装）。<code>top</code>命令提供了一个动态的、实时的视图，显示系统中运行的进程及其资源使用情况。<code>htop</code>是一个更高级的交互式进程查看器，提供了更友好的用户界面和更多的功能。</p>
<p>例如，要使用<code>top</code>命令，只需在终端中输入：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
<p>要使用<code>htop</code>命令，输入：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htop</span><br></pre></td></tr></table></figure>
<p>请注意，<code>htop</code>可能需要单独安装，因为它不是Linux发行版的标准工具。你可以使用包管理器来安装它，例如在Debian/Ubuntu系统中，可以使用以下命令安装：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install htop</span><br></pre></td></tr></table></figure>
<h2 id="43-vi编辑文件模式下删4行跟全删的命令分别是什么"><a class="markdownIt-Anchor" href="#43-vi编辑文件模式下删4行跟全删的命令分别是什么"></a> 43、vi编辑文件模式下删4行跟全删的命令分别是什么</h2>
<p>在vi编辑器中，删除行和删除整个文件的命令如下：</p>
<ol>
<li class="lvl-3">
<p>删除当前光标所在行：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>删除4行（从当前光标所在行开始向下删除4行）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4dd</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>删除整个文件（清空文件内容）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%d</span><br></pre></td></tr></table></figure>
<p>在执行此命令后，文件内容将被删除，但文件本身仍然存在。如果你想要删除文件本身，你需要使用操作系统的命令，如<code>rm</code>。例如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:wq! # 保存并退出vi</span><br><span class="line">rm filename # 删除文件</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>请注意，这些命令是在vi的命令模式下使用的。如果你在插入模式下，你需要先按<code>Esc</code>键返回到命令模式，然后再输入上述命令。</p>
<h2 id="44-数据库进行数据清理操作如何不影响dml操作"><a class="markdownIt-Anchor" href="#44-数据库进行数据清理操作如何不影响dml操作"></a> 44、数据库进行数据清理操作如何不影响dml操作</h2>
<p>在数据库进行数据清理操作时，通常需要确保这些操作不会影响到正在进行的DML（数据操作语言）操作，如INSERT、UPDATE和DELETE。为了实现这一点，可以采取以下几种策略：</p>
<ol>
<li class="lvl-3">
<p><strong>事务隔离级别</strong>：<br />
使用适当的事务隔离级别来防止数据清理操作与DML操作之间的冲突。例如，使用Serializable隔离级别可以确保事务在执行期间看到的数据不会被其他事务修改。</p>
</li>
<li class="lvl-3">
<p><strong>锁定机制</strong>：<br />
在执行数据清理操作时，可以使用锁定机制来锁定相关的表或行，防止其他事务对其进行修改。但是，这可能会导致其他事务等待，影响性能。</p>
</li>
<li class="lvl-3">
<p><strong>分区表</strong>：<br />
如果数据库支持分区表，可以将数据分成多个分区，然后对不活动的分区进行清理。这样可以减少对正在使用的数据的影响。</p>
</li>
<li class="lvl-3">
<p><strong>批量操作</strong>：<br />
将数据清理操作分成多个小批量执行，而不是一次性删除大量数据。这可以减少对数据库性能的影响，并降低锁竞争的可能性。</p>
</li>
<li class="lvl-3">
<p><strong>时间窗口</strong>：<br />
在数据库负载较低的时间窗口内执行数据清理操作，以减少对在线DML操作的影响。</p>
</li>
<li class="lvl-3">
<p><strong>复制和影子表</strong>：<br />
使用数据库复制功能或影子表来创建数据的副本，然后在副本上执行清理操作。清理完成后，可以将副本切换回主表。</p>
</li>
<li class="lvl-3">
<p><strong>使用存储过程或触发器</strong>：<br />
编写存储过程或触发器来自动执行数据清理操作，确保它们在不影响DML操作的情况下运行。</p>
</li>
<li class="lvl-3">
<p><strong>监控和调整</strong>：<br />
在执行数据清理操作时，监控数据库的性能和锁情况，根据需要调整操作的频率和范围。</p>
</li>
<li class="lvl-3">
<p><strong>备份和恢复</strong>：<br />
在执行大规模数据清理操作之前，确保有最新的备份，以便在出现问题时可以恢复数据。<br />
在执行任何数据清理操作之前，都应该仔细规划，并在测试环境中进行测试，以确保操作的安全性和有效性。此外，应该与数据库管理员和其他相关团队成员沟通，确保他们了解即将进行的操作，以便在必要时提供支持。</p>
</li>
</ol>
<h2 id="45-linux命令和权限问题"><a class="markdownIt-Anchor" href="#45-linux命令和权限问题"></a> 45、linux命令和权限问题</h2>
<p>在Linux系统中，命令和权限管理是确保系统安全和稳定运行的关键。以下是一些关于Linux命令和权限的基本概念和操作：</p>
<h3 id="基本命令"><a class="markdownIt-Anchor" href="#基本命令"></a> 基本命令</h3>
<ol>
<li class="lvl-3">
<p><strong>文件和目录操作</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>ls</code>：列出目录内容。</li>
<li class="lvl-5"><code>cd</code>：更改目录。</li>
<li class="lvl-5"><code>pwd</code>：显示当前工作目录。</li>
<li class="lvl-5"><code>mkdir</code>：创建目录。</li>
<li class="lvl-5"><code>rm</code>：删除文件或目录。</li>
<li class="lvl-5"><code>cp</code>：复制文件或目录。</li>
<li class="lvl-5"><code>mv</code>：移动或重命名文件或目录。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>文件查看和编辑</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>cat</code>：显示文件内容。</li>
<li class="lvl-5"><code>less</code>：分页显示文件内容。</li>
<li class="lvl-5"><code>vim</code> 或 <code>nano</code>：文本编辑器，用于创建和编辑文件。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>系统信息和管理</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>uname</code>：显示系统信息。</li>
<li class="lvl-5"><code>top</code> 或 <code>htop</code>：显示系统进程。</li>
<li class="lvl-5"><code>df</code>：显示磁盘空间使用情况。</li>
<li class="lvl-5"><code>free</code>：显示内存使用情况。</li>
<li class="lvl-5"><code>ps</code>：显示进程状态。</li>
<li class="lvl-5"><code>kill</code>：终止进程。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>用户和权限管理</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>useradd</code> 或 <code>adduser</code>：添加用户。</li>
<li class="lvl-5"><code>userdel</code>：删除用户。</li>
<li class="lvl-5"><code>passwd</code>：更改用户密码。</li>
<li class="lvl-5"><code>chmod</code>：更改文件或目录权限。</li>
<li class="lvl-5"><code>chown</code>：更改文件或目录所有者。</li>
<li class="lvl-5"><code>chgrp</code>：更改文件或目录所属组。</li>
</ul>
</li>
</ol>
<h3 id="权限管理"><a class="markdownIt-Anchor" href="#权限管理"></a> 权限管理</h3>
<p>Linux权限系统基于用户、组和其他用户（others）的三类权限，每类权限有读（r）、写（w）和执行（x）三种权限。</p>
<ol>
<li class="lvl-3">
<p><strong>查看权限</strong>：<br />
使用 <code>ls -l</code> 命令可以查看文件或目录的权限。</p>
</li>
<li class="lvl-3">
<p><strong>更改权限</strong>：<br />
使用 <code>chmod</code> 命令可以更改文件或目录的权限。例如：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>chmod 755 file.txt</code>：设置文件的权限为所有者可读写执行，组和其他用户可读执行。</li>
<li class="lvl-5"><code>chmod u+x file.txt</code>：给文件的所有者添加执行权限。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>更改所有者和组</strong>：<br />
使用 <code>chown</code> 和 <code>chgrp</code> 命令可以更改文件或目录的所有者和组。例如：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>chown user:group file.txt</code>：更改文件的所有者为&quot;user&quot;，组为&quot;group&quot;。</li>
<li class="lvl-5"><code>chgrp group file.txt</code>：更改文件的组为&quot;group&quot;。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>sudo权限</strong>：<br />
使用 <code>sudo</code> 命令可以以超级用户权限执行命令。例如：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>sudo apt-get update</code>：以超级用户权限更新包列表。</li>
</ul>
</li>
</ol>
<h3 id="注意事项-4"><a class="markdownIt-Anchor" href="#注意事项-4"></a> 注意事项</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>在执行任何可能影响系统稳定性的命令之前，应该确保你了解该命令的作用和潜在影响。</p>
</li>
<li class="lvl-2">
<p>使用 <code>sudo</code> 时要非常小心，因为错误的命令可能会导致系统损坏。</p>
</li>
<li class="lvl-2">
<p>定期备份重要数据，以防万一。</p>
</li>
<li class="lvl-2">
<p>学习和理解Linux命令和权限系统是Linux系统管理的基础，建议通过官方文档和在线教程进行深入学习。</p>
</li>
</ul>
<p>通过理解和掌握这些基本的Linux命令和权限管理知识，你可以更有效地管理和维护Linux系统。</p>
<h2 id="46-java基础语法-接口-抽象类-继承关系"><a class="markdownIt-Anchor" href="#46-java基础语法-接口-抽象类-继承关系"></a> 46、java基础语法 接口、抽象类、继承关系</h2>
<p>在Java编程语言中，接口、抽象类和继承关系是面向对象编程（OOP）的重要概念。它们允许开发者实现代码的重用、扩展和多态性。下面是这些概念的简要介绍：</p>
<h3 id="接口interface-2"><a class="markdownIt-Anchor" href="#接口interface-2"></a> 接口（Interface）</h3>
<p>接口是一种完全抽象的类，它只包含抽象方法和常量。接口用于定义类的行为，但不提供方法的具体实现。一个类可以实现多个接口，从而实现多重继承的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象类abstract-class-2"><a class="markdownIt-Anchor" href="#抽象类abstract-class-2"></a> 抽象类（Abstract Class）</h3>
<p>抽象类是一个不能被实例化的类，它可能包含抽象方法（没有实现的方法）和具体方法（有实现的方法）。抽象类用于提供一个基类，子类可以继承并实现抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mammal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">giveBirth</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breathe</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Breathing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承关系inheritance"><a class="markdownIt-Anchor" href="#继承关系inheritance"></a> 继承关系（Inheritance）</h3>
<p>继承是OOP的一个关键特性，它允许一个类（子类）继承另一个类（父类）的属性和方法。子类可以重写父类的方法，也可以添加新的方法和属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重继承与接口"><a class="markdownIt-Anchor" href="#多重继承与接口"></a> 多重继承与接口</h3>
<p>Java不支持多重继承，即一个类不能直接继承多个类。但是，一个类可以实现多个接口，从而实现多重继承的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>, Flyable &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Chirp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Flying...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项-5"><a class="markdownIt-Anchor" href="#注意事项-5"></a> 注意事项</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>接口中的方法默认是抽象的，而抽象类中的方法可以是抽象的也可以是具体的。</p>
</li>
<li class="lvl-2">
<p>一个类可以继承一个抽象类并实现多个接口。</p>
</li>
<li class="lvl-2">
<p>抽象类可以有构造器，而接口不能有构造器。</p>
</li>
<li class="lvl-2">
<p>接口中的变量默认是<code>public static final</code>的，而抽象类中的变量可以有不同的访问修饰符。</p>
</li>
</ul>
<p>通过理解和使用接口、抽象类和继承关系，开发者可以创建出更加模块化、可扩展和易于维护的代码。</p>
<p>1、字符串小写加反转<br />
2、2的幂等<br />
3、预计循环类型， 递归<br />
4、冒泡排序</p>
<p>常见题型：</p>
<p>JAVA基础题型<br />
SQL优化题型<br />
Linux命令题型</p>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2025-02-25</span>
            
                <span>该篇文章被 up</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/Java/'>
                            Java
                        </a>
                    
                        <a href='/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/'>
                            面试题
                        </a>
                    
                </span>
             
             
        
        </i>
    </div>
    <br>
    
    

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 2025 UP 

            
                

            
                
                    / <a href="/"> Home </a>
                

            
                
                    / <a href="/ch"> Channel </a>
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery/lightgallery.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
    </body>
</html>
<script src="/js/emojiHandler.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    wrapEmojis('.paper');
  });
</script>