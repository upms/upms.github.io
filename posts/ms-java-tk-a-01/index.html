<!DOCTYPE html>
<html lang="en">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="Java 面试题库-A（含答案）" />
    <meta name="hexo-theme-A4" content="v1.9.8" />
    <link rel="alternate icon" type="image/webp" href="/img/blank.png">
    <title></title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
    
   
<link rel="stylesheet" href="/css/lightgallery-bundle.min.css">


   
        
<link rel="stylesheet" href="/css/custom.css">

    
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkai/dist/LXGWWenKai-Regular/result.css' /> 
<meta name="generator" content="Hexo 7.3.0"></head>
    
    

    
    



    

    
    




    
    


    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        
            
                <div class="left-toc-container">
                    <nav id="toc" class="bs-docs-sidebar"></nav>
                </div>
            
        
        <div class="paper">

            

            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <style>
            .header-img {
                width: 56px;
                height: auto;
                object-fit: cover; /* 保持图片比例 */
                transition: transform 0.3s ease-in-out; 
                border-radius: 0; 
            }
            
        </style>
        <img 
            alt="^-^" 
            cache-control="max-age=86400" 
            class="header-img" 
            src="/img/blank.png" 
        />
        <div class="header-content">
            <a class="logo" href="/"></a> 
            <span class="description"></span> 
        </div>
    </div>
    
   
    <ul class="nav">
        
    </ul>
</div>

                    
                    

                    
                    

                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    Java 面试题库-A（含答案）
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                    <span>最近更新：2025-06-20</span> 
                
                
                    
                        &nbsp; | &nbsp;
                    
                     <span>字数总计：12.4k</span>
                
                
                
            </div>
    

    <div class="post-md">
        
        <div class=".article-gallery"><h2 id="01云计算的服务模式不包括以下哪个"><a class="markdownIt-Anchor" href="#01云计算的服务模式不包括以下哪个"></a> 01.云计算的服务模式不包括以下哪个？</h2>
<p>云计算的服务模式主要包括以下三种：</p>
<ol>
<li class="lvl-3">
<p><strong>IaaS（基础设施即服务）</strong>：提供虚拟化的计算资源，如虚拟机、存储和网络。</p>
</li>
<li class="lvl-3">
<p><strong>PaaS（平台即服务）</strong>：提供开发和部署应用的平台，包括操作系统、数据库和开发工具。</p>
</li>
<li class="lvl-3">
<p><strong>SaaS（软件即服务）</strong>：提供通过互联网访问的应用程序，用户无需管理底层基础设施。</p>
</li>
</ol>
<p>以下选项通常<strong>不属于</strong>云计算的服务模式：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>DaaS（数据即服务）</strong>：虽然DaaS是一种云服务，但它通常被视为SaaS或PaaS的一部分，而不是独立的云计算服务模式。</p>
</li>
<li class="lvl-2">
<p><strong>On-premises（本地部署）</strong>：这是传统的本地部署模式，不属于云计算的范畴。</p>
</li>
</ul>
<p>因此，<strong>On-premises（本地部署）</strong> 不属于云计算的服务模式。</p>
<h2 id="02group-和having-用法"><a class="markdownIt-Anchor" href="#02group-和having-用法"></a> 02.group 和having 用法？</h2>
<p>在SQL中，<code>GROUP BY</code> 和 <code>HAVING</code> 是用于对查询结果进行分组和过滤的关键字。它们通常与聚合函数（如 <code>COUNT</code>、<code>SUM</code>、<code>AVG</code>、<code>MAX</code>、<code>MIN</code> 等）一起使用。</p>
<h3 id="1-group-by"><a class="markdownIt-Anchor" href="#1-group-by"></a> 1. <strong>GROUP BY</strong></h3>
<p><code>GROUP BY</code> 用于将结果集按一个或多个列进行分组，通常与聚合函数一起使用，以便对每个组进行计算。</p>
<h4 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法：</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, aggregate_function(column2)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1;</span><br></pre></td></tr></table></figure>
<h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例：</h4>
<p>假设有一个 <code>orders</code> 表，包含以下数据：</p>
<table>
<thead>
<tr>
<th>order_id</th>
<th>customer_id</th>
<th>amount</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>101</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>102</td>
<td>200</td>
</tr>
<tr>
<td>3</td>
<td>101</td>
<td>150</td>
</tr>
<tr>
<td>4</td>
<td>103</td>
<td>300</td>
</tr>
</tbody>
</table>
<p>如果我们想计算每个客户的订单总金额，可以使用 <code>GROUP BY</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure>
<h4 id="结果"><a class="markdownIt-Anchor" href="#结果"></a> 结果</h4>
<table>
<thead>
<tr>
<th>customer_id</th>
<th>total_amount</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>250</td>
</tr>
<tr>
<td>102</td>
<td>200</td>
</tr>
<tr>
<td>103</td>
<td>300</td>
</tr>
</tbody>
</table>
<h3 id="2-having"><a class="markdownIt-Anchor" href="#2-having"></a> 2. <strong>HAVING</strong></h3>
<p><code>HAVING</code> 用于过滤分组后的结果集。它与 <code>WHERE</code> 类似，但 <code>WHERE</code> 是在分组前过滤行，而 <code>HAVING</code> 是在分组后过滤组。</p>
<h4 id="语法-2"><a class="markdownIt-Anchor" href="#语法-2"></a> 语法</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, aggregate_function(column2)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>
<h4 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h4>
<p>继续使用上面的 <code>orders</code> 表，如果我们只想查询订单总金额大于 200 的客户，可以使用 <code>HAVING</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(amount) <span class="operator">&gt;</span> <span class="number">200</span>;</span><br></pre></td></tr></table></figure>
<h4 id="结果-2"><a class="markdownIt-Anchor" href="#结果-2"></a> 结果</h4>
<table>
<thead>
<tr>
<th>customer_id</th>
<th>total_amount</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>250</td>
</tr>
<tr>
<td>103</td>
<td>300</td>
</tr>
</tbody>
</table>
<h3 id="3-group-by-和-having-的结合使用"><a class="markdownIt-Anchor" href="#3-group-by-和-having-的结合使用"></a> 3. <strong>GROUP BY 和 HAVING 的结合使用</strong></h3>
<p><code>GROUP BY</code> 和 <code>HAVING</code> 通常一起使用，以便对分组后的结果进行过滤。</p>
<h4 id="示例-3"><a class="markdownIt-Anchor" href="#示例-3"></a> 示例：</h4>
<p>假设我们想查询订单数量大于 1 的客户：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">COUNT</span>(order_id) <span class="keyword">AS</span> order_count</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(order_id) <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="结果-3"><a class="markdownIt-Anchor" href="#结果-3"></a> 结果</h4>
<table>
<thead>
<tr>
<th>customer_id</th>
<th>order_count</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>2</td>
</tr>
</tbody>
</table>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>GROUP BY</strong>：用于按列分组，通常与聚合函数一起使用。</p>
</li>
<li class="lvl-2">
<p><strong>HAVING</strong>：用于过滤分组后的结果集，条件中通常包含聚合函数。</p>
</li>
<li class="lvl-2">
<p><strong>WHERE</strong> 和 <strong>HAVING</strong> 的区别：</p>
<ul class="lvl-2">
<li class="lvl-4"><code>WHERE</code> 在分组前过滤行。</li>
<li class="lvl-4"><code>HAVING</code> 在分组后过滤组。</li>
</ul>
</li>
</ul>
<p>通过合理使用 <code>GROUP BY</code> 和 <code>HAVING</code>，可以对数据进行更复杂的分析和查询。</p>
<h2 id="03分布式数据库的可扩展性不包括哪个"><a class="markdownIt-Anchor" href="#03分布式数据库的可扩展性不包括哪个"></a> 03.分布式数据库的可扩展性不包括哪个？</h2>
<p>分布式数据库的可扩展性通常包括以下几个方面：</p>
<ol>
<li class="lvl-3">
<p><strong>水平扩展（Horizontal Scaling）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">通过增加更多的节点来扩展系统的处理能力和存储容量。</li>
<li class="lvl-5">例如，添加更多的服务器来分担负载。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>垂直扩展（Vertical Scaling）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">通过增加单个节点的资源（如CPU、内存、存储）来提升性能。</li>
<li class="lvl-5">例如，升级服务器的硬件配置。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>数据分片（Sharding）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">将数据分散存储在多个节点上，以提高查询性能和处理能力。</li>
<li class="lvl-5">例如，按用户ID将数据分布到不同的数据库实例。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>负载均衡（Load Balancing）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">将请求均匀分布到多个节点上，以避免单个节点过载。</li>
<li class="lvl-5">例如，使用负载均衡器来分配查询请求。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>高可用性（High Availability）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">通过复制和故障转移机制确保系统在部分节点失效时仍能正常运行。</li>
<li class="lvl-5">例如，使用主从复制和自动故障切换。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>弹性扩展（Elastic Scaling）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">根据负载动态调整资源，以应对流量波动。</li>
<li class="lvl-5">例如，云数据库服务可以根据需求自动扩展或缩减资源。</li>
</ul>
</li>
</ol>
<h3 id="不包括的方面"><a class="markdownIt-Anchor" href="#不包括的方面"></a> 不包括的方面</h3>
<p>分布式数据库的可扩展性<strong>不包括</strong>以下方面：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>单点性能优化（Single-node Performance Optimization）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">虽然单点性能优化可以提升单个节点的性能，但它并不直接涉及系统的扩展性。</li>
<li class="lvl-4">例如，优化单个数据库的查询性能或索引设计。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>数据一致性（Data Consistency）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">数据一致性是分布式数据库的重要特性，但它与可扩展性无直接关系。</li>
<li class="lvl-4">例如，强一致性或最终一致性的实现。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>安全性（Security）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">安全性是数据库的重要特性，但它与可扩展性无直接关系。</li>
<li class="lvl-4">例如，数据加密、访问控制等。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>事务管理（Transaction Management）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">事务管理是数据库的核心功能，但它与可扩展性无直接关系。</li>
<li class="lvl-4">例如，分布式事务的实现。</li>
</ul>
</li>
</ul>
<h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3>
<p>分布式数据库的可扩展性主要关注系统的扩展能力，包括水平扩展、垂直扩展、数据分片、负载均衡、高可用性和弹性扩展。而单点性能优化、数据一致性、安全性和事务管理虽然重要，但不属于可扩展性的范畴。</p>
<h2 id="04主键满足数据库三范式的第几范式"><a class="markdownIt-Anchor" href="#04主键满足数据库三范式的第几范式"></a> 04.主键满足数据库三范式的第几范式？</h2>
<p>主键（Primary Key）是数据库设计中的一个重要概念，它与数据库范式（Normalization）密切相关。主键本身并不直接对应某个范式，但它<strong>是实现数据库范式的基础</strong>，尤其是在满足第一范式（1NF）和第二范式（2NF）时起到关键作用。</p>
<hr />
<h3 id="1-主键的作用"><a class="markdownIt-Anchor" href="#1-主键的作用"></a> 1. <strong>主键的作用</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>唯一标识</strong>：主键用于唯一标识表中的每一行数据。</p>
</li>
<li class="lvl-2">
<p><strong>非空</strong>：主键列的值不能为 <code>NULL</code>。</p>
</li>
<li class="lvl-2">
<p><strong>不可重复</strong>：主键列的值必须唯一。</p>
</li>
</ul>
<hr />
<h3 id="2-主键与数据库范式的关系"><a class="markdownIt-Anchor" href="#2-主键与数据库范式的关系"></a> 2. <strong>主键与数据库范式的关系</strong></h3>
<h4 id="第一范式1nf"><a class="markdownIt-Anchor" href="#第一范式1nf"></a> <strong>第一范式（1NF）</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>要求</strong>：表中的每一列都是不可再分的原子值，且每一行都是唯一的。</p>
</li>
<li class="lvl-2">
<p><strong>主键的作用</strong>：主键是实现第一范式的关键，因为它确保了每一行的唯一性。</p>
</li>
<li class="lvl-2">
<p><strong>示例</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">不符合 1NF 的表：
<table>
<thead>
<tr>
<th>学生ID</th>
<th>学生姓名</th>
<th>课程</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>张三</td>
<td>数学, 英语</td>
</tr>
<tr>
<td>2</td>
<td>李四</td>
<td>物理</td>
</tr>
</tbody>
</table>
</li>
<li class="lvl-4">符合 1NF 的表（通过主键确保唯一性）：
<table>
<thead>
<tr>
<th>学生ID</th>
<th>学生姓名</th>
<th>课程</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>张三</td>
<td>数学</td>
</tr>
<tr>
<td>1</td>
<td>张三</td>
<td>英语</td>
</tr>
<tr>
<td>2</td>
<td>李四</td>
<td>物理</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<h4 id="第二范式2nf"><a class="markdownIt-Anchor" href="#第二范式2nf"></a> <strong>第二范式（2NF）</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>要求</strong>：在满足 1NF 的基础上，所有非主键列必须完全依赖于主键，而不是部分依赖。</p>
</li>
<li class="lvl-2">
<p><strong>主键的作用</strong>：如果表中有复合主键（由多个列组成），则需要确保非主键列完全依赖于整个主键，而不是部分主键。</p>
</li>
<li class="lvl-2">
<p><strong>示例</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">不符合 2NF 的表：
<table>
<thead>
<tr>
<th>学生ID</th>
<th>课程ID</th>
<th>学生姓名</th>
<th>课程名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>101</td>
<td>张三</td>
<td>数学</td>
</tr>
<tr>
<td>1</td>
<td>102</td>
<td>张三</td>
<td>英语</td>
</tr>
<tr>
<td>2</td>
<td>101</td>
<td>李四</td>
<td>数学</td>
</tr>
</tbody>
</table>
<ul class="lvl-4">
<li class="lvl-6">问题：<code>学生姓名</code> 只依赖于 <code>学生ID</code>，而 <code>课程名称</code> 只依赖于 <code>课程ID</code>，存在部分依赖。</li>
</ul>
</li>
<li class="lvl-4">符合 2NF 的表（拆分表）：
<ul class="lvl-4">
<li class="lvl-6">学生表：
<table>
<thead>
<tr>
<th>学生ID</th>
<th>学生姓名</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>张三</td>
</tr>
<tr>
<td>2</td>
<td>李四</td>
</tr>
</tbody>
</table>
</li>
<li class="lvl-6">课程表：
<table>
<thead>
<tr>
<th>课程ID</th>
<th>课程名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>数学</td>
</tr>
<tr>
<td>102</td>
<td>英语</td>
</tr>
</tbody>
</table>
</li>
<li class="lvl-6">选课表：
<table>
<thead>
<tr>
<th>学生ID</th>
<th>课程ID</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>101</td>
</tr>
<tr>
<td>1</td>
<td>102</td>
</tr>
<tr>
<td>2</td>
<td>101</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="第三范式3nf"><a class="markdownIt-Anchor" href="#第三范式3nf"></a> <strong>第三范式（3NF）</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>要求</strong>：在满足 2NF 的基础上，所有非主键列之间不能有传递依赖。</p>
</li>
<li class="lvl-2">
<p><strong>主键的作用</strong>：主键仍然是确保数据唯一性和依赖关系的基础。</p>
</li>
<li class="lvl-2">
<p><strong>示例</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">不符合 3NF 的表：
<table>
<thead>
<tr>
<th>学生ID</th>
<th>学生姓名</th>
<th>学院ID</th>
<th>学院名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>张三</td>
<td>101</td>
<td>理学院</td>
</tr>
<tr>
<td>2</td>
<td>李四</td>
<td>102</td>
<td>文学院</td>
</tr>
</tbody>
</table>
<ul class="lvl-4">
<li class="lvl-6">问题：<code>学院名称</code> 依赖于 <code>学院ID</code>，而 <code>学院ID</code> 依赖于 <code>学生ID</code>，存在传递依赖。</li>
</ul>
</li>
<li class="lvl-4">符合 3NF 的表（拆分表）：
<ul class="lvl-4">
<li class="lvl-6">学生表：
<table>
<thead>
<tr>
<th>学生ID</th>
<th>学生姓名</th>
<th>学院ID</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>张三</td>
<td>101</td>
</tr>
<tr>
<td>2</td>
<td>李四</td>
<td>102</td>
</tr>
</tbody>
</table>
</li>
<li class="lvl-6">学院表：
<table>
<thead>
<tr>
<th>学院ID</th>
<th>学院名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>理学院</td>
</tr>
<tr>
<td>102</td>
<td>文学院</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="3-总结"><a class="markdownIt-Anchor" href="#3-总结"></a> 3. <strong>总结</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>主键本身并不直接对应某个范式</strong>，但它是实现数据库范式的基础。</p>
</li>
<li class="lvl-2">
<p><strong>第一范式（1NF）</strong>：主键确保每一行的唯一性。</p>
</li>
<li class="lvl-2">
<p><strong>第二范式（2NF）</strong>：主键（尤其是复合主键）确保非主键列完全依赖于整个主键。</p>
</li>
<li class="lvl-2">
<p><strong>第三范式（3NF）</strong>：主键确保非主键列之间没有传递依赖。</p>
</li>
</ul>
<p>因此，主键是数据库设计中的核心概念，贯穿于数据库范式的各个阶段。</p>
<h2 id="05数据库默认的事物传播类型是哪个"><a class="markdownIt-Anchor" href="#05数据库默认的事物传播类型是哪个"></a> 05.数据库默认的事物传播类型是哪个？</h2>
<p>在 MySQL 和 Oracle 数据库中，<strong>事务传播行为</strong>并不是数据库本身的特性，而是由应用程序框架（如 Spring）或应用程序逻辑控制的。数据库本身只提供事务的基本支持（如 <code>BEGIN</code>、<code>COMMIT</code>、<code>ROLLBACK</code>），而事务的传播行为是由应用程序框架定义的。</p>
<hr />
<h3 id="1-mysql-和-oracle-数据库的事务支持"><a class="markdownIt-Anchor" href="#1-mysql-和-oracle-数据库的事务支持"></a> 1. <strong>MySQL 和 Oracle 数据库的事务支持</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>MySQL</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">默认情况下，MySQL 使用自动提交模式（<code>autocommit</code>），即每条 SQL 语句都会自动作为一个事务提交。</li>
<li class="lvl-4">可以通过 <code>BEGIN</code> 或 <code>START TRANSACTION</code> 显式开启事务，然后通过 <code>COMMIT</code> 或 <code>ROLLBACK</code> 结束事务。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>Oracle</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">Oracle 数据库默认也是自动提交模式，但可以通过设置 <code>AUTOCOMMIT</code> 为 <code>OFF</code> 来禁用自动提交。</li>
<li class="lvl-4">使用 <code>BEGIN</code> 或 <code>START TRANSACTION</code> 开启事务，通过 <code>COMMIT</code> 或 <code>ROLLBACK</code> 结束事务。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="2-事务传播行为的定义"><a class="markdownIt-Anchor" href="#2-事务传播行为的定义"></a> 2. <strong>事务传播行为的定义</strong></h3>
<p>事务传播行为是由应用程序框架（如 Spring）定义的，常见的传播行为包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>REQUIRED</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新事务。</p>
</li>
<li class="lvl-2">
<p><code>REQUIRES_NEW</code>：总是创建一个新事务，如果当前存在事务，则挂起当前事务。</p>
</li>
<li class="lvl-2">
<p><code>SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。</p>
</li>
<li class="lvl-2">
<p>其他传播行为（如 <code>MANDATORY</code>、<code>NOT_SUPPORTED</code>、<code>NEVER</code>、<code>NESTED</code>）。</p>
</li>
</ul>
<hr />
<h3 id="3-默认传播行为"><a class="markdownIt-Anchor" href="#3-默认传播行为"></a> 3. <strong>默认传播行为</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Spring 框架</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">在 Spring 中，默认的事务传播行为是 <code>REQUIRED</code>。</li>
<li class="lvl-4">示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span> <span class="comment">// 默认传播行为是 REQUIRED</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>MySQL 和 Oracle 数据库</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">数据库本身没有“传播行为”的概念，传播行为是由应用程序框架控制的。</li>
<li class="lvl-4">如果直接使用 JDBC 或原生 SQL，需要手动管理事务的边界（如 <code>BEGIN</code>、<code>COMMIT</code>、<code>ROLLBACK</code>）。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4. <strong>总结</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>MySQL 和 Oracle 数据库</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">数据库本身只提供事务的基本支持（如 <code>BEGIN</code>、<code>COMMIT</code>、<code>ROLLBACK</code>）。</li>
<li class="lvl-4">默认情况下，MySQL 和 Oracle 使用自动提交模式（<code>autocommit</code>）。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>事务传播行为</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">是由应用程序框架（如 Spring）定义的。</li>
<li class="lvl-4">在 Spring 中，默认的传播行为是 <code>REQUIRED</code>。</li>
</ul>
</li>
</ul>
<p>如果需要使用特定的事务传播行为，需要在应用程序框架中配置，而不是在数据库中配置。</p>
<h2 id="06数据库事物读未提交是哪个read-uncommitted"><a class="markdownIt-Anchor" href="#06数据库事物读未提交是哪个read-uncommitted"></a> 06.数据库事物读未提交是哪个？（read uncommitted）</h2>
<p>在数据库事务的隔离级别中，<strong>读未提交（Read Uncommitted）</strong> 是最低的事务隔离级别。它允许一个事务读取另一个事务尚未提交的数据，可能会导致<strong>脏读（Dirty Read）</strong>、<strong>不可重复读（Non-Repeatable Read）</strong> 和 <strong>幻读（Phantom Read）</strong> 等问题。</p>
<hr />
<h3 id="1-读未提交read-uncommitted的特点"><a class="markdownIt-Anchor" href="#1-读未提交read-uncommitted的特点"></a> 1. <strong>读未提交（Read Uncommitted）的特点</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>定义</strong>：一个事务可以读取另一个事务未提交的数据。</p>
</li>
<li class="lvl-2">
<p><strong>问题</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>脏读（Dirty Read）</strong>：读取到未提交的数据，如果该事务回滚，则读取到的数据是无效的。</li>
<li class="lvl-4"><strong>不可重复读（Non-Repeatable Read）</strong>：同一事务中多次读取同一数据，结果不一致。</li>
<li class="lvl-4"><strong>幻读（Phantom Read）</strong>：同一事务中多次查询，结果集不一致（新增或删除的数据导致）。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="2-读未提交的示例"><a class="markdownIt-Anchor" href="#2-读未提交的示例"></a> 2. <strong>读未提交的示例</strong></h3>
<p>假设有两个事务：<code>事务A</code> 和 <code>事务B</code>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>事务A</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> balance <span class="operator">=</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 修改数据但未提交</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong>事务B</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 读取到未提交的数据（balance = 100）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果 <code>事务A</code> 回滚，<code>事务B</code> 读取到的数据（<code>balance = 100</code>）就是无效的，这就是<strong>脏读</strong>。</p>
<hr />
<h3 id="3-设置读未提交隔离级别"><a class="markdownIt-Anchor" href="#3-设置读未提交隔离级别"></a> 3. <strong>设置读未提交隔离级别</strong></h3>
<p>在 MySQL 和 Oracle 中，可以通过以下方式设置事务的隔离级别为 <strong>读未提交</strong>。</p>
<h4 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> <strong>MySQL</strong>：</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br></pre></td></tr></table></figure>
<h4 id="oracle"><a class="markdownIt-Anchor" href="#oracle"></a> <strong>Oracle</strong>：</h4>
<p>Oracle 不支持 <strong>读未提交</strong> 隔离级别，最低的隔离级别是 <strong>读已提交（Read Committed）</strong>。</p>
<hr />
<h3 id="4-读未提交的适用场景"><a class="markdownIt-Anchor" href="#4-读未提交的适用场景"></a> 4. <strong>读未提交的适用场景</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>对数据一致性要求不高的场景</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">例如，某些统计分析的场景，允许读取到未提交的数据。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>性能要求较高的场景</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">读未提交的隔离级别最低，并发性能最好，但数据一致性无法保证。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="5-数据库事务隔离级别对比"><a class="markdownIt-Anchor" href="#5-数据库事务隔离级别对比"></a> 5. <strong>数据库事务隔离级别对比</strong></h3>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读（Dirty Read）</th>
<th>不可重复读（Non-Repeatable Read）</th>
<th>幻读（Phantom Read）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>读未提交</strong></td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td><strong>读已提交</strong></td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td><strong>可重复读</strong></td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td><strong>串行化</strong></td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="6-总结"><a class="markdownIt-Anchor" href="#6-总结"></a> 6. <strong>总结</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>读未提交（Read Uncommitted）</strong> 是最低的事务隔离级别，允许读取未提交的数据。</p>
</li>
<li class="lvl-2">
<p>它会导致<strong>脏读</strong>、<strong>不可重复读</strong> 和 <strong>幻读</strong> 等问题。</p>
</li>
<li class="lvl-2">
<p>适用于对数据一致性要求不高、但对性能要求较高的场景。</p>
</li>
<li class="lvl-2">
<p>在 MySQL 中可以通过 <code>SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED</code> 设置，但 Oracle 不支持该隔离级别。</p>
</li>
</ul>
<h2 id="07多选题fetch-和pull用法"><a class="markdownIt-Anchor" href="#07多选题fetch-和pull用法"></a> 07.【多选题】fetch 和pull用法？</h2>
<p><code>fetch</code> 和 <code>pull</code> 是 Git 中常用的两个命令，它们的作用和用法有所不同，但都与从远程仓库获取代码有关。以下是它们的详细说明和用法：</p>
<hr />
<h3 id="1-git-fetch"><a class="markdownIt-Anchor" href="#1-git-fetch"></a> 1. <strong><code>git fetch</code></strong></h3>
<p><code>git fetch</code> 用于从远程仓库下载最新的提交记录和分支信息，但不会自动合并到本地分支。</p>
<h4 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> <strong>作用</strong>：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>从远程仓库获取最新的提交记录和分支信息。</p>
</li>
<li class="lvl-2">
<p>更新本地仓库的远程跟踪分支（如 <code>origin/main</code>），但不会修改本地分支（如 <code>main</code>）。</p>
</li>
</ul>
<h4 id="用法"><a class="markdownIt-Anchor" href="#用法"></a> <strong>用法</strong>：</h4>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;远程仓库名&gt;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>&lt;远程仓库名&gt;</code>：通常是 <code>origin</code>，表示远程仓库的别名。</p>
</li>
</ul>
<h4 id="示例-4"><a class="markdownIt-Anchor" href="#示例-4"></a> <strong>示例</strong>：</h4>
<ol>
<li class="lvl-3">
<p>获取远程仓库的所有更新：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>获取特定分支的更新：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin main</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>查看远程分支的更新：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="结果-4"><a class="markdownIt-Anchor" href="#结果-4"></a> <strong>结果</strong>：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>远程仓库的最新提交会被下载到本地，但不会影响本地分支。</p>
</li>
<li class="lvl-2">
<p>可以使用 <code>git log origin/main</code> 查看远程分支的更新。</p>
</li>
</ul>
<hr />
<h3 id="2-git-pull"><a class="markdownIt-Anchor" href="#2-git-pull"></a> 2. <strong><code>git pull</code></strong></h3>
<p><code>git pull</code> 用于从远程仓库下载最新的提交记录并自动合并到当前本地分支。</p>
<h4 id="作用-2"><a class="markdownIt-Anchor" href="#作用-2"></a> <strong>作用</strong>：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>从远程仓库获取最新的提交记录。</p>
</li>
<li class="lvl-2">
<p>自动将远程分支的更新合并到当前本地分支。</p>
</li>
</ul>
<h4 id="用法-2"><a class="markdownIt-Anchor" href="#用法-2"></a> <strong>用法</strong>：</h4>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>&lt;远程仓库名&gt;</code>：通常是 <code>origin</code>。</p>
</li>
<li class="lvl-2">
<p><code>&lt;远程分支名&gt;</code>：要拉取的远程分支名称。</p>
</li>
</ul>
<h4 id="示例-5"><a class="markdownIt-Anchor" href="#示例-5"></a> <strong>示例</strong>：</h4>
<ol>
<li class="lvl-3">
<p>拉取远程仓库的 <code>main</code> 分支并合并到当前分支：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>拉取远程仓库的当前分支（默认）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="结果-5"><a class="markdownIt-Anchor" href="#结果-5"></a> <strong>结果</strong>：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>远程仓库的最新提交会被下载并自动合并到当前本地分支。</p>
</li>
<li class="lvl-2">
<p>如果存在冲突，需要手动解决冲突后再提交。</p>
</li>
</ul>
<hr />
<h3 id="3-fetch-和-pull-的区别"><a class="markdownIt-Anchor" href="#3-fetch-和-pull-的区别"></a> 3. <strong><code>fetch</code> 和 <code>pull</code> 的区别</strong></h3>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>git fetch</code></th>
<th><code>git pull</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>作用</strong></td>
<td>下载远程仓库的最新提交记录和分支信息</td>
<td>下载远程仓库的最新提交记录并合并到本地分支</td>
</tr>
<tr>
<td><strong>是否修改本地分支</strong></td>
<td>不会修改本地分支</td>
<td>会自动合并到当前本地分支</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>查看远程仓库的更新</td>
<td>获取远程仓库的更新并合并到本地</td>
</tr>
<tr>
<td><strong>冲突处理</strong></td>
<td>不会产生冲突</td>
<td>可能会产生冲突，需要手动解决</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="4-工作流程示例"><a class="markdownIt-Anchor" href="#4-工作流程示例"></a> 4. <strong>工作流程示例</strong></h3>
<h4 id="使用-fetch-的工作流程"><a class="markdownIt-Anchor" href="#使用-fetch-的工作流程"></a> <strong>使用 <code>fetch</code> 的工作流程</strong>：</h4>
<ol>
<li class="lvl-3">
<p>获取远程仓库的更新：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>查看远程分支的更新：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log origin/main</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>手动合并远程分支到本地分支：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/main</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="使用-pull-的工作流程"><a class="markdownIt-Anchor" href="#使用-pull-的工作流程"></a> <strong>使用 <code>pull</code> 的工作流程</strong>：</h4>
<ol>
<li class="lvl-3">
<p>直接拉取并合并远程分支：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>如果有冲突，解决冲突后提交：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Merge remote changes&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr />
<h3 id="5-总结"><a class="markdownIt-Anchor" href="#5-总结"></a> 5. <strong>总结</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>git fetch</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">用于获取远程仓库的最新提交记录和分支信息。</li>
<li class="lvl-4">不会修改本地分支，适合查看远程仓库的更新。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong><code>git pull</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">用于获取远程仓库的最新提交记录并自动合并到本地分支。</li>
<li class="lvl-4">适合快速同步远程仓库的更新。</li>
</ul>
</li>
</ul>
<p>根据具体需求选择合适的命令：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果需要查看远程仓库的更新而不修改本地分支，使用 <code>git fetch</code>。</p>
</li>
<li class="lvl-2">
<p>如果需要快速同步远程仓库的更新并合并到本地分支，使用 <code>git pull</code>。</p>
</li>
</ul>
<h2 id="08编程题给一个数组包括正数和负数要求忽略正负按大小排序"><a class="markdownIt-Anchor" href="#08编程题给一个数组包括正数和负数要求忽略正负按大小排序"></a> 08.【编程题】给一个数组，包括正数和负数，要求忽略正负，按大小排序</h2>
<p>要实现一个忽略正负、按绝对值大小排序的数组，可以使用编程语言提供的排序函数，并在排序时比较元素的绝对值。以下是使用 <strong>Java</strong> 的实现示例：</p>
<hr />
<h3 id="java-实现"><a class="markdownIt-Anchor" href="#java-实现"></a> <strong>Java 实现</strong></h3>
<p>Java 可以使用 <code>Arrays.sort()</code> 方法，并通过自定义比较器来实现按绝对值排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">3</span>, -<span class="number">1</span>, -<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, -<span class="number">2</span>&#125;;</span><br><span class="line">        sortByAbsoluteValue(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));  <span class="comment">// 输出: [0, -1, 2, -2, 3, -4]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortByAbsoluteValue</span><span class="params">(Integer[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Arrays.sort 并传入自定义比较器</span></span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(Math.abs(a), Math.abs(b));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解释"><a class="markdownIt-Anchor" href="#解释"></a> <strong>解释</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>Arrays.sort(arr, new Comparator&lt;Integer&gt;() &#123; ... &#125;)</code>：对数组 <code>arr</code> 进行排序，排序规则由自定义的 <code>Comparator</code> 定义。</p>
</li>
<li class="lvl-2">
<p><code>Integer.compare(Math.abs(a), Math.abs(b))</code>：比较两个整数的绝对值。</p>
</li>
</ul>
<hr />
<h3 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> <strong>总结</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>核心思想</strong>：在排序时比较元素的绝对值。</p>
</li>
<li class="lvl-2">
<p><strong>实现方式</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">Java：使用 <code>Arrays.sort()</code> 和自定义 <code>Comparator</code>。</li>
</ul>
</li>
</ul>
<p>以上实现均能正确地将数组按绝对值大小排序，同时保留原始元素的正负符号。</p>
<h2 id="09数据库的四种隔离级别"><a class="markdownIt-Anchor" href="#09数据库的四种隔离级别"></a> 09.数据库的四种隔离级别</h2>
<p>MySQL 支持不同的事务隔离级别，控制事务间的可见性：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>READ UNCOMMITTED</strong>：最低级别，允许读取未提交的数据。</p>
</li>
<li class="lvl-2">
<p><strong>READ COMMITTED</strong>：只能读取已提交的数据。</p>
</li>
<li class="lvl-2">
<p><strong>REPEATABLE READ</strong>（默认）：确保事务内多次读取结果一致。</p>
</li>
<li class="lvl-2">
<p><strong>SERIALIZABLE</strong>：最高级别，完全隔离，事务串行执行。</p>
</li>
</ul>
<h2 id="10truncate的属于什么操作"><a class="markdownIt-Anchor" href="#10truncate的属于什么操作"></a> 10.truncate的属于什么操作？</h2>
<p><code>TRUNCATE</code> 是 SQL 中的一种数据操作语言（<strong>DML</strong>，Data Manipulation Language）命令，用于<strong>快速删除表中的所有数据</strong>。与 <code>DELETE</code> 命令不同，<code>TRUNCATE</code> 不会逐行删除数据，而是直接释放表的数据页，因此效率更高。</p>
<hr />
<h3 id="1-truncate-的特点"><a class="markdownIt-Anchor" href="#1-truncate-的特点"></a> 1. <strong><code>TRUNCATE</code> 的特点</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>删除所有数据</strong>：<code>TRUNCATE</code> 会删除表中的所有数据，但保留表结构（如表定义、索引、约束等）。</p>
</li>
<li class="lvl-2">
<p><strong>不可回滚</strong>：<code>TRUNCATE</code> 操作通常不可回滚（取决于数据库的实现，某些数据库支持事务中的 <code>TRUNCATE</code> 回滚）。</p>
</li>
<li class="lvl-2">
<p><strong>不触发触发器</strong>：<code>TRUNCATE</code> 不会触发 <code>DELETE</code> 触发器。</p>
</li>
<li class="lvl-2">
<p><strong>重置自增值</strong>：对于带有自增列（如 <code>AUTO_INCREMENT</code> 或 <code>IDENTITY</code>）的表，<code>TRUNCATE</code> 会重置自增值。</p>
</li>
<li class="lvl-2">
<p><strong>高效</strong>：<code>TRUNCATE</code> 直接释放数据页，比 <code>DELETE</code> 更快。</p>
</li>
</ul>
<hr />
<h3 id="2-truncate-的语法"><a class="markdownIt-Anchor" href="#2-truncate-的语法"></a> 2. <strong><code>TRUNCATE</code> 的语法</strong></h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure>
<h4 id="示例-6"><a class="markdownIt-Anchor" href="#示例-6"></a> 示例：</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> employees;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>删除 <code>employees</code> 表中的所有数据，但保留表结构。</p>
</li>
</ul>
<hr />
<h3 id="3-truncate-与-delete-的区别"><a class="markdownIt-Anchor" href="#3-truncate-与-delete-的区别"></a> 3. <strong><code>TRUNCATE</code> 与 <code>DELETE</code> 的区别</strong></h3>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>TRUNCATE</code></th>
<th><code>DELETE</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>删除方式</strong></td>
<td>直接释放数据页，删除所有数据</td>
<td>逐行删除数据</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td>高效</td>
<td>较低</td>
</tr>
<tr>
<td><strong>可回滚</strong></td>
<td>通常不可回滚（取决于数据库实现）</td>
<td>可回滚</td>
</tr>
<tr>
<td><strong>触发触发器</strong></td>
<td>不触发</td>
<td>触发</td>
</tr>
<tr>
<td><strong>重置自增值</strong></td>
<td>重置</td>
<td>不重置</td>
</tr>
<tr>
<td><strong>条件删除</strong></td>
<td>不支持</td>
<td>支持（通过 <code>WHERE</code> 子句）</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="4-truncate-的适用场景"><a class="markdownIt-Anchor" href="#4-truncate-的适用场景"></a> 4. <strong><code>TRUNCATE</code> 的适用场景</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>需要快速清空表中的所有数据。</p>
</li>
<li class="lvl-2">
<p>不需要逐行删除数据。</p>
</li>
<li class="lvl-2">
<p>不需要触发 <code>DELETE</code> 触发器。</p>
</li>
<li class="lvl-2">
<p>需要重置自增列的值。</p>
</li>
</ul>
<hr />
<h3 id="5-注意事项"><a class="markdownIt-Anchor" href="#5-注意事项"></a> 5. <strong>注意事项</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>权限要求</strong>：<code>TRUNCATE</code> 通常需要较高的权限（如 <code>DROP</code> 权限）。</p>
</li>
<li class="lvl-2">
<p><strong>不可恢复</strong>：<code>TRUNCATE</code> 操作通常不可恢复，执行前需谨慎。</p>
</li>
<li class="lvl-2">
<p><strong>外键约束</strong>：某些数据库（如 MySQL 的 InnoDB）在有外键约束时可能不允许 <code>TRUNCATE</code>。</p>
</li>
</ul>
<hr />
<h3 id="6-总结-2"><a class="markdownIt-Anchor" href="#6-总结-2"></a> 6. <strong>总结</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>TRUNCATE</code></strong> 是一种高效的删除操作，用于快速清空表中的所有数据。</p>
</li>
<li class="lvl-2">
<p>它属于 <strong>DML（数据操作语言）</strong>，但与 <code>DELETE</code> 相比，<code>TRUNCATE</code> 更高效且不触发触发器。</p>
</li>
<li class="lvl-2">
<p>适用于需要快速清空表数据的场景，但需注意其不可回滚的特性。</p>
</li>
</ul>
<h2 id="11数据库聚簇索引和非聚簇索引的问题"><a class="markdownIt-Anchor" href="#11数据库聚簇索引和非聚簇索引的问题"></a> 11.数据库聚簇索引和非聚簇索引的问题</h2>
<p><strong>聚簇索引（Clustered Index）</strong> 和 <strong>非聚簇索引（Non-Clustered Index）</strong> 是数据库中两种重要的索引类型，它们在存储方式和查询性能上有显著区别。以下是它们的详细对比和常见问题：</p>
<hr />
<h3 id="1-聚簇索引clustered-index"><a class="markdownIt-Anchor" href="#1-聚簇索引clustered-index"></a> 1. <strong>聚簇索引（Clustered Index）</strong></h3>
<h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> <strong>定义</strong>：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>聚簇索引决定了表中数据的物理存储顺序。</p>
</li>
<li class="lvl-2">
<p>一个表只能有一个聚簇索引，因为数据只能按一种方式物理排序。</p>
</li>
</ul>
<h4 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> <strong>特点</strong>：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>数据与索引一起存储</strong>：聚簇索引的叶子节点直接存储数据行。</p>
</li>
<li class="lvl-2">
<p><strong>物理排序</strong>：表中的数据按聚簇索引的键值顺序存储。</p>
</li>
<li class="lvl-2">
<p><strong>高效查询</strong>：对于范围查询和排序操作，聚簇索引非常高效。</p>
</li>
<li class="lvl-2">
<p><strong>主键默认是聚簇索引</strong>：在大多数数据库（如 MySQL InnoDB）中，主键默认是聚簇索引。</p>
</li>
</ul>
<h4 id="示例-7"><a class="markdownIt-Anchor" href="#示例-7"></a> <strong>示例</strong>：</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,  <span class="comment">-- 聚簇索引</span></span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    age <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>id</code> 列是聚簇索引，数据按 <code>id</code> 的顺序存储。</p>
</li>
</ul>
<hr />
<h3 id="2-非聚簇索引non-clustered-index"><a class="markdownIt-Anchor" href="#2-非聚簇索引non-clustered-index"></a> 2. <strong>非聚簇索引（Non-Clustered Index）</strong></h3>
<h4 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> <strong>定义</strong>：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>非聚簇索引是一种独立于数据存储的索引结构。</p>
</li>
<li class="lvl-2">
<p>一个表可以有多个非聚簇索引。</p>
</li>
</ul>
<h4 id="特点-2"><a class="markdownIt-Anchor" href="#特点-2"></a> <strong>特点</strong>：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>索引与数据分离</strong>：非聚簇索引的叶子节点存储的是指向数据行的指针（如主键值或行地址）。</p>
</li>
<li class="lvl-2">
<p><strong>逻辑排序</strong>：索引按键值排序，但数据不按索引顺序存储。</p>
</li>
<li class="lvl-2">
<p><strong>适合查询单条记录</strong>：对于精确查找，非聚簇索引效率较高。</p>
</li>
<li class="lvl-2">
<p><strong>需要额外存储空间</strong>：非聚簇索引需要额外的存储空间来存储索引结构。</p>
</li>
</ul>
<h4 id="示例-8"><a class="markdownIt-Anchor" href="#示例-8"></a> <strong>示例</strong>：</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> employees(name);  <span class="comment">-- 非聚簇索引</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>name</code> 列是非聚簇索引，索引按 <code>name</code> 排序，但数据仍按 <code>id</code> 的顺序存储。</p>
</li>
</ul>
<hr />
<h3 id="3-聚簇索引-vs-非聚簇索引"><a class="markdownIt-Anchor" href="#3-聚簇索引-vs-非聚簇索引"></a> 3. <strong>聚簇索引 vs 非聚簇索引</strong></h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>聚簇索引</th>
<th>非聚簇索引</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数量</strong></td>
<td>一个表只能有一个</td>
<td>一个表可以有多个</td>
</tr>
<tr>
<td><strong>数据存储</strong></td>
<td>索引的叶子节点存储数据行</td>
<td>索引的叶子节点存储指向数据行的指针</td>
</tr>
<tr>
<td><strong>物理排序</strong></td>
<td>数据按索引键值物理排序</td>
<td>数据不按索引键值物理排序</td>
</tr>
<tr>
<td><strong>查询性能</strong></td>
<td>范围查询和排序操作高效</td>
<td>精确查找操作高效</td>
</tr>
<tr>
<td><strong>存储空间</strong></td>
<td>不需要额外存储空间</td>
<td>需要额外存储空间</td>
</tr>
<tr>
<td><strong>默认索引</strong></td>
<td>主键默认是聚簇索引</td>
<td>需要显式创建</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="4-常见问题"><a class="markdownIt-Anchor" href="#4-常见问题"></a> 4. <strong>常见问题</strong></h3>
<h4 id="问题-1一个表可以有多个聚簇索引吗"><a class="markdownIt-Anchor" href="#问题-1一个表可以有多个聚簇索引吗"></a> <strong>问题 1：一个表可以有多个聚簇索引吗？</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>答案</strong>：不可以。一个表只能有一个聚簇索引，因为数据只能按一种方式物理排序。</p>
</li>
</ul>
<h4 id="问题-2聚簇索引和非聚簇索引哪个更快"><a class="markdownIt-Anchor" href="#问题-2聚簇索引和非聚簇索引哪个更快"></a> <strong>问题 2：聚簇索引和非聚簇索引哪个更快？</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>答案</strong>：取决于查询类型：</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>聚簇索引</strong>：在范围查询和排序操作中更快，因为数据按索引顺序存储。</li>
<li class="lvl-4"><strong>非聚簇索引</strong>：在精确查找操作中更快，因为索引结构更小，查找更快。</li>
</ul>
</li>
</ul>
<h4 id="问题-3主键一定是聚簇索引吗"><a class="markdownIt-Anchor" href="#问题-3主键一定是聚簇索引吗"></a> <strong>问题 3：主键一定是聚簇索引吗？</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>答案</strong>：在大多数数据库（如 MySQL InnoDB）中，主键默认是聚簇索引。但某些数据库（如 SQL Server）允许将非主键列设置为聚簇索引。</p>
</li>
</ul>
<h4 id="问题-4非聚簇索引的叶子节点存储什么"><a class="markdownIt-Anchor" href="#问题-4非聚簇索引的叶子节点存储什么"></a> <strong>问题 4：非聚簇索引的叶子节点存储什么？</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>答案</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">如果表有聚簇索引，非聚簇索引的叶子节点存储聚簇索引的键值。</li>
<li class="lvl-4">如果表没有聚簇索引，非聚簇索引的叶子节点存储数据行的物理地址。</li>
</ul>
</li>
</ul>
<h4 id="问题-5如何选择聚簇索引的列"><a class="markdownIt-Anchor" href="#问题-5如何选择聚簇索引的列"></a> <strong>问题 5：如何选择聚簇索引的列？</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>答案</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">选择唯一性高、更新频率低的列（如主键）。</li>
<li class="lvl-4">选择常用于范围查询或排序的列。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="5-实际应用场景"><a class="markdownIt-Anchor" href="#5-实际应用场景"></a> 5. <strong>实际应用场景</strong></h3>
<h4 id="聚簇索引的应用场景"><a class="markdownIt-Anchor" href="#聚簇索引的应用场景"></a> <strong>聚簇索引的应用场景</strong>：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>主键列。</p>
</li>
<li class="lvl-2">
<p>常用于范围查询或排序的列（如日期列）。</p>
</li>
</ul>
<h4 id="非聚簇索引的应用场景"><a class="markdownIt-Anchor" href="#非聚簇索引的应用场景"></a> <strong>非聚簇索引的应用场景</strong>：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>常用于查询条件的列（如 <code>WHERE</code> 子句中的列）。</p>
</li>
<li class="lvl-2">
<p>需要创建多个索引的列。</p>
</li>
</ul>
<hr />
<h3 id="6-总结-3"><a class="markdownIt-Anchor" href="#6-总结-3"></a> 6. <strong>总结</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>聚簇索引</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">决定数据的物理存储顺序。</li>
<li class="lvl-4">一个表只能有一个聚簇索引。</li>
<li class="lvl-4">适合范围查询和排序操作。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>非聚簇索引</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">独立于数据存储，存储指向数据行的指针。</li>
<li class="lvl-4">一个表可以有多个非聚簇索引。</li>
<li class="lvl-4">适合精确查找操作。</li>
</ul>
</li>
</ul>
<p>根据实际需求合理选择聚簇索引和非聚簇索引，可以显著提高数据库的查询性能。</p>
<h2 id="12springboot启动读取的配置顺序"><a class="markdownIt-Anchor" href="#12springboot启动读取的配置顺序"></a> 12.springboot启动读取的配置顺序</h2>
<h2 id="13spring-aop关于通知的选择题"><a class="markdownIt-Anchor" href="#13spring-aop关于通知的选择题"></a> 13.spring AOP关于通知的选择题。</h2>
<h2 id="14autowired与resource注解的区别默认按什么装配"><a class="markdownIt-Anchor" href="#14autowired与resource注解的区别默认按什么装配"></a> 14.@Autowired与@Resource注解的区别(默认按什么装配)</h2>
<h2 id="15linux中-765权限的文件应该标记为什么例如-rwxrw-r-x"><a class="markdownIt-Anchor" href="#15linux中-765权限的文件应该标记为什么例如-rwxrw-r-x"></a> 15.Linux中 765权限的文件，应该标记为什么，例如-rwxrw-r-x</h2>
<h2 id="16关于redis持久化得选择题"><a class="markdownIt-Anchor" href="#16关于redis持久化得选择题"></a> 16.关于redis持久化得选择题</h2>
<h2 id="17例如836-7-21排序后的结果1-236-78"><a class="markdownIt-Anchor" href="#17例如836-7-21排序后的结果1-236-78"></a> 17.例如[8,3,6,-7,-2,1]排序后的结果[1,-2,3,6,-7,8]</h2>
<h2 id="18mysql数据库having用法"><a class="markdownIt-Anchor" href="#18mysql数据库having用法"></a> 18.mysql数据库having用法</h2>
<h2 id="19privatepublicprotected作用域"><a class="markdownIt-Anchor" href="#19privatepublicprotected作用域"></a> 19.private,public,protected作用域</h2>
<h2 id="20保密学习在行方哪个平台进行"><a class="markdownIt-Anchor" href="#20保密学习在行方哪个平台进行"></a> 20.保密学习在行方哪个平台进行?</h2>
<h2 id="21数据安全问题"><a class="markdownIt-Anchor" href="#21数据安全问题"></a> 21.数据安全问题</h2>
<h2 id="22数据库三大范式"><a class="markdownIt-Anchor" href="#22数据库三大范式"></a> 22.数据库三大范式</h2>
<h2 id="23对称加密算法有哪些"><a class="markdownIt-Anchor" href="#23对称加密算法有哪些"></a> 23.对称加密算法有哪些</h2>
<h2 id="24updatedelete注意事项"><a class="markdownIt-Anchor" href="#24updatedelete注意事项"></a> 24.update/delete注意事项</h2>
<h2 id="25redis默认日志"><a class="markdownIt-Anchor" href="#25redis默认日志"></a> 25.redis默认日志</h2>
<h2 id="26spring事务相关比如默认事务事务失效原因-spring默认日志框架"><a class="markdownIt-Anchor" href="#26spring事务相关比如默认事务事务失效原因-spring默认日志框架"></a> 26.spring事务相关，比如默认事务，事务失效原因、spring默认日志框架</h2>
<h2 id="27aop原理"><a class="markdownIt-Anchor" href="#27aop原理"></a> 27.aop原理</h2>
<h2 id="28云计算包含哪些"><a class="markdownIt-Anchor" href="#28云计算包含哪些"></a> 28.云计算包含哪些</h2>
<h2 id="29mybatis标签"><a class="markdownIt-Anchor" href="#29mybatis标签"></a> 29.mybatis标签</h2>
<h2 id="30gbase-sql正确性"><a class="markdownIt-Anchor" href="#30gbase-sql正确性"></a> 30.gbase sql正确性</h2>
<h2 id="31linux操作相关指令"><a class="markdownIt-Anchor" href="#31linux操作相关指令"></a> 31.linux操作相关指令</h2>
<h2 id="32数据库索引失效"><a class="markdownIt-Anchor" href="#32数据库索引失效"></a> 32.数据库索引失效</h2>
<h2 id="33观察者模式描述多选题"><a class="markdownIt-Anchor" href="#33观察者模式描述多选题"></a> 33.观察者模式描述(多选题)</h2>
<h2 id="34mathround-15的值是多少"><a class="markdownIt-Anchor" href="#34mathround-15的值是多少"></a> 34.math.round(-1.5)的值是多少?</h2>
<h2 id="35tcp-http-udp分别位于底层的那一层a-传输层-b-应用层-c-会话层-d-网络层"><a class="markdownIt-Anchor" href="#35tcp-http-udp分别位于底层的那一层a-传输层-b-应用层-c-会话层-d-网络层"></a> 35.TCP、HTTP、UDP分别位于底层的那一层？A 传输层 B 应用层 C 会话层 D 网络层</h2>
<h2 id="36springboot中使用aop的接口有个选项是事务相关transactional"><a class="markdownIt-Anchor" href="#36springboot中使用aop的接口有个选项是事务相关transactional"></a> 36.springboot中使用aop的接口(有个选项是事务相关@Transactional)</h2>
<h2 id="37死锁的4个必要条件"><a class="markdownIt-Anchor" href="#37死锁的4个必要条件"></a> 37.死锁的4个必要条件</h2>
<h2 id="38mysql的隔离级别"><a class="markdownIt-Anchor" href="#38mysql的隔离级别"></a> 38.mysql的隔离级别</h2>
<h2 id="39mybaits中mapper是怎么传递参数的-sql的循环使用foreach-怎么进行结果映射的-sql的索引使用"><a class="markdownIt-Anchor" href="#39mybaits中mapper是怎么传递参数的-sql的循环使用foreach-怎么进行结果映射的-sql的索引使用"></a> 39.mybaits中mapper是怎么传递参数的、sql的循环使用foreach、怎么进行结果映射的、sql的索引使用</h2>
<h2 id="40java的特性-抽象继承封装-多态"><a class="markdownIt-Anchor" href="#40java的特性-抽象继承封装-多态"></a> 40.Java的特性 抽象继承封装 多态</h2>
<h2 id="41class类的初始化方式"><a class="markdownIt-Anchor" href="#41class类的初始化方式"></a> 41.class类的初始化方式</h2>
<h2 id="42哪个命令可以跳出多层嵌套循环-abreak-bcontinue-cgoto"><a class="markdownIt-Anchor" href="#42哪个命令可以跳出多层嵌套循环-abreak-bcontinue-cgoto"></a> 42.哪个命令可以跳出多层嵌套循环()? A:break B:continue C:goto</h2>
<h2 id="43可以使联合索引abc失效的有-aa-bab-cabc-dbc"><a class="markdownIt-Anchor" href="#43可以使联合索引abc失效的有-aa-bab-cabc-dbc"></a> 43.可以使联合索引(a,b,c)失效的有()? A:a  B:a,b  C:a,b,c  D:b,c</h2>
<h2 id="44哪个属于ddl操作aselect-bupdate-ctruncate-dcreate"><a class="markdownIt-Anchor" href="#44哪个属于ddl操作aselect-bupdate-ctruncate-dcreate"></a> 44.哪个属于DDL操作()？A:select B:update C:truncate D:create</h2>
<h2 id="45数组经过两次排序后可以从小到大排序使用的是什么排序a插入-b-冒泡-c-快速-d-选择"><a class="markdownIt-Anchor" href="#45数组经过两次排序后可以从小到大排序使用的是什么排序a插入-b-冒泡-c-快速-d-选择"></a> 45.数组经过两次排序后可以从小到大排序，使用的是什么排序？A:插入 B 冒泡 C 快速 D 选择</h2>
<h2 id="46变量使用哪个特殊符号会出现sql注入-a-b"><a class="markdownIt-Anchor" href="#46变量使用哪个特殊符号会出现sql注入-a-b"></a> 46.变量使用哪个特殊符号会出现Sql注入? A # B＄</h2>
<h2 id="47编写sql语句正确先后顺序是什么where-group-by-havingorder-by"><a class="markdownIt-Anchor" href="#47编写sql语句正确先后顺序是什么where-group-by-havingorder-by"></a> 47.编写sql语句正确先后顺序是什么？where &gt;group by &gt;having&gt;order by</h2>
<h2 id="48单例模式满足条件"><a class="markdownIt-Anchor" href="#48单例模式满足条件"></a> 48.单例模式满足条件？</h2>
<h2 id="49访问修饰符publicprivateprotecteddefault-的访问权限是什么"><a class="markdownIt-Anchor" href="#49访问修饰符publicprivateprotecteddefault-的访问权限是什么"></a> 49.访问修饰符public,private,protected,default  的访问权限是什么？</h2>
<h2 id="50git如何解决冲突"><a class="markdownIt-Anchor" href="#50git如何解决冲突"></a> 50.git如何解决冲突？</h2>
<h2 id="51count1count主键count哪个查询效率高"><a class="markdownIt-Anchor" href="#51count1count主键count哪个查询效率高"></a> 51.count(1),count(主键)，count(*)哪个查询效率高？</h2>
<h2 id="52count1-count-count列-null值差异"><a class="markdownIt-Anchor" href="#52count1-count-count列-null值差异"></a> 52.count(1) count(*) count(列) null值差异</h2>
<h2 id="53多线程加锁方式"><a class="markdownIt-Anchor" href="#53多线程加锁方式"></a> 53.多线程加锁方式</h2>
<h2 id="54sass-mass-pass-rass考察"><a class="markdownIt-Anchor" href="#54sass-mass-pass-rass考察"></a> 54.sass mass  pass rass考察</h2>
<h2 id="55arraylist和linklist是不是继承list-arraylist-是不是线程安全"><a class="markdownIt-Anchor" href="#55arraylist和linklist是不是继承list-arraylist-是不是线程安全"></a> 55.arraylist和linklist是不是继承list、arraylist 是不是线程安全</h2>
<h2 id="56springboot的多选题关于启动时加载配置文件springboot默认日志框架logback"><a class="markdownIt-Anchor" href="#56springboot的多选题关于启动时加载配置文件springboot默认日志框架logback"></a> 56.【springboot的多选题】关于启动时加载配置文件，springboot默认日志框架logback</h2>
<h2 id="57多选题下列是对称加密的有哪些"><a class="markdownIt-Anchor" href="#57多选题下列是对称加密的有哪些"></a> 57.【多选题】下列是对称加密的有哪些？</h2>
<h2 id="58多选题哪些外部设备不能插入主机"><a class="markdownIt-Anchor" href="#58多选题哪些外部设备不能插入主机"></a> 58.【多选题】哪些外部设备不能插入主机</h2>
<h2 id="59根据场景写sql根据group-by"><a class="markdownIt-Anchor" href="#59根据场景写sql根据group-by"></a> 59.根据场景写SQL，根据group by</h2>
<h2 id="60maven查看依赖树的命令"><a class="markdownIt-Anchor" href="#60maven查看依赖树的命令"></a> 60.maven查看依赖树的命令</h2>
<h2 id="61finally在return后是否执行相关问题"><a class="markdownIt-Anchor" href="#61finally在return后是否执行相关问题"></a> 61.finally在return后是否执行相关问题</h2>
<h2 id="62switch的参数类型"><a class="markdownIt-Anchor" href="#62switch的参数类型"></a> 62.switch的参数类型</h2>
<h2 id="63跨域脚本xss哪些防御措施"><a class="markdownIt-Anchor" href="#63跨域脚本xss哪些防御措施"></a> 63.跨域脚本XSS哪些防御措施</h2>
<h2 id="64多态的表现形式"><a class="markdownIt-Anchor" href="#64多态的表现形式"></a> 64.多态的表现形式</h2>
<h2 id="65switch-case语句中不使用break后的计算值问题"><a class="markdownIt-Anchor" href="#65switch-case语句中不使用break后的计算值问题"></a> 65.Switch-case语句中不使用break后的计算值问题</h2>
<h2 id="66jdbc创建连接的语句顺序"><a class="markdownIt-Anchor" href="#66jdbc创建连接的语句顺序"></a> 66.JDBC创建连接的语句顺序</h2>
<h2 id="67那些sq1高斯数据库执行失败"><a class="markdownIt-Anchor" href="#67那些sq1高斯数据库执行失败"></a> 67.那些sq1高斯数据库执行失败?</h2>
<h2 id="68高斯db能执行的sql"><a class="markdownIt-Anchor" href="#68高斯db能执行的sql"></a> 68.高斯DB能执行的sql</h2>
<h2 id="69springboot自动装配原理"><a class="markdownIt-Anchor" href="#69springboot自动装配原理"></a> 69.springboot自动装配原理</h2>
<h2 id="70事务默认传播类型"><a class="markdownIt-Anchor" href="#70事务默认传播类型"></a> 70.事务默认传播类型</h2>
<h2 id="71mybatis传多参数的几种方式"><a class="markdownIt-Anchor" href="#71mybatis传多参数的几种方式"></a> 71.Mybatis传多参数的几种方式</h2>
<h2 id="72多选题spring注入方式构造方法-set-注解字段"><a class="markdownIt-Anchor" href="#72多选题spring注入方式构造方法-set-注解字段"></a> 72.【多选题】spring注入方式：构造方法、set、注解字段</h2>
<h2 id="73以下那种不是thread的方法"><a class="markdownIt-Anchor" href="#73以下那种不是thread的方法"></a> 73.以下那种不是Thread的方法</h2>
<h2 id="74switch-case-default-输出打印的主要考case满足条件以后还会继续执行吗"><a class="markdownIt-Anchor" href="#74switch-case-default-输出打印的主要考case满足条件以后还会继续执行吗"></a> 74.switch case default 输出打印的，主要考case满足条件以后还会继续执行吗</h2>
<h2 id="75哪种方式可以防止跨域请求"><a class="markdownIt-Anchor" href="#75哪种方式可以防止跨域请求"></a> 75.哪种方式可以防止跨域请求</h2>
<p>防止跨域请求（Cross-Origin Request）通常不是目标，因为跨域请求是现代Web应用中常见的需求。相反，目标是安全地处理跨域请求，防止恶意行为。以下是几种常见的方式来管理和控制跨域请求：</p>
<h3 id="1-cors跨域资源共享"><a class="markdownIt-Anchor" href="#1-cors跨域资源共享"></a> 1. CORS（跨域资源共享）</h3>
<ul class="lvl-0">
<li class="lvl-5">
<p>CORS 是一种W3C标准，允许服务器明确指定哪些外部域可以访问其资源。</p>
</li>
<li class="lvl-5">
<p>服务器可以通过设置HTTP响应头来控制跨域请求：</p>
<ul class="lvl-2">
<li class="lvl-7"><code>Access-Control-Allow-Origin</code>: 指定允许访问资源的域名，<code>*</code> 表示允许所有域名。</li>
<li class="lvl-7"><code>Access-Control-Allow-Methods</code>: 指定允许的HTTP方法（如GET、POST等）。</li>
<li class="lvl-7"><code>Access-Control-Allow-Headers</code>: 指定允许的请求头。</li>
<li class="lvl-7"><code>Access-Control-Allow-Credentials</code>: 指定是否允许发送凭据（如cookies）。</li>
</ul>
</li>
<li class="lvl-5">
<p>通过合理配置CORS，可以限制跨域请求的来源、方法和头信息，防止恶意请求。</p>
</li>
</ul>
<h3 id="2-jsonpjson-with-padding"><a class="markdownIt-Anchor" href="#2-jsonpjson-with-padding"></a> 2. JSONP（JSON with Padding）</h3>
<ul class="lvl-0">
<li class="lvl-5">
<p>JSONP 是一种绕过同源策略的旧方法，通过动态创建<code>&lt;script&gt;</code>标签来加载跨域数据。</p>
</li>
<li class="lvl-5">
<p>由于JSONP存在安全风险（如XSS攻击），现代应用通常不再推荐使用。</p>
</li>
</ul>
<h3 id="3-代理服务器"><a class="markdownIt-Anchor" href="#3-代理服务器"></a> 3. 代理服务器</h3>
<ul class="lvl-0">
<li class="lvl-5">
<p>使用代理服务器可以避免跨域问题。客户端请求同域下的代理服务器，代理服务器再请求目标服务器并返回结果。</p>
</li>
<li class="lvl-5">
<p>这种方式可以隐藏跨域请求，但需要额外的服务器资源。</p>
</li>
</ul>
<h3 id="4-same-origin-policy同源策略"><a class="markdownIt-Anchor" href="#4-same-origin-policy同源策略"></a> 4. Same-Origin Policy（同源策略）</h3>
<ul class="lvl-0">
<li class="lvl-5">
<p>浏览器默认遵循同源策略，阻止跨域请求。如果不需要跨域请求，可以依赖浏览器的同源策略来阻止跨域访问。</p>
</li>
<li class="lvl-5">
<p>同源策略限制不同协议、域名或端口之间的请求。</p>
</li>
</ul>
<h3 id="5-csrf-token"><a class="markdownIt-Anchor" href="#5-csrf-token"></a> 5. CSRF Token</h3>
<ul class="lvl-0">
<li class="lvl-5">
<p>为了防止跨站请求伪造（CSRF）攻击，可以使用CSRF Token。</p>
</li>
<li class="lvl-5">
<p>服务器生成一个唯一的Token，嵌入到表单或请求头中，客户端在请求时携带该Token，服务器验证Token的合法性。</p>
</li>
</ul>
<h3 id="6-限制请求来源"><a class="markdownIt-Anchor" href="#6-限制请求来源"></a> 6. 限制请求来源</h3>
<ul class="lvl-0">
<li class="lvl-5">
<p>服务器可以通过检查请求头中的<code>Origin</code>或<code>Referer</code>字段，判断请求是否来自允许的域名，拒绝非法来源的请求。</p>
</li>
</ul>
<h3 id="7-使用https"><a class="markdownIt-Anchor" href="#7-使用https"></a> 7. 使用HTTPS</h3>
<ul class="lvl-0">
<li class="lvl-5">
<p>使用HTTPS可以防止中间人攻击，确保跨域请求的安全性。</p>
</li>
</ul>
<h3 id="8-content-security-policy-csp"><a class="markdownIt-Anchor" href="#8-content-security-policy-csp"></a> 8. Content Security Policy (CSP)</h3>
<ul class="lvl-0">
<li class="lvl-5">
<p>通过设置CSP头，可以限制页面加载的外部资源（如脚本、样式、图片等），防止恶意跨域请求。</p>
</li>
</ul>
<h3 id="总结-4"><a class="markdownIt-Anchor" href="#总结-4"></a> 总结</h3>
<p>如果需要完全阻止跨域请求，可以依赖浏览器的同源策略或服务器端的限制。但更常见的做法是通过CORS、代理服务器或CSRF Token等方式安全地处理跨域请求，而不是完全阻止。</p>
<h2 id="76git-pull合并本地代码fetch不合并"><a class="markdownIt-Anchor" href="#76git-pull合并本地代码fetch不合并"></a> 76.git pull合并本地代码，fetch不合并</h2>
<h2 id="77redis-配置文件"><a class="markdownIt-Anchor" href="#77redis-配置文件"></a> 77.REDIS 配置文件</h2>
<h2 id="78范围查询用什么索引"><a class="markdownIt-Anchor" href="#78范围查询用什么索引"></a> 78.范围查询⽤什么索引。</h2>
<h2 id="79java创建实例有哪些注入方式"><a class="markdownIt-Anchor" href="#79java创建实例有哪些注入方式"></a> 79.Java创建实例有哪些注⼊⽅式。</h2>
<h2 id="80try-catch-捕获到异常后输出内容"><a class="markdownIt-Anchor" href="#80try-catch-捕获到异常后输出内容"></a> 80.Try catch 捕获到异常后，输出内容。</h2>
<h2 id="81三范式的基本概念"><a class="markdownIt-Anchor" href="#81三范式的基本概念"></a> 81.三范式的基本概念。</h2>
<h2 id="82truncate-属于什么语言-ddl-dcl-dml"><a class="markdownIt-Anchor" href="#82truncate-属于什么语言-ddl-dcl-dml"></a> 82.truncate 属于什么语言 DDL  DCL  DML</h2>
<p><code>TRUNCATE</code> 属于 <strong>DML（Data Manipulation Language，数据操作语言）</strong>。</p>
<h3 id="详细说明"><a class="markdownIt-Anchor" href="#详细说明"></a> 详细说明</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>DML（数据操作语言）</strong>：用于操作数据库中的数据，常见的命令包括 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 和 <code>TRUNCATE</code>。<code>TRUNCATE</code> 用于快速删除表中的所有数据，但保留表结构。</p>
</li>
<li class="lvl-2">
<p><strong>DDL（数据定义语言）</strong>：用于定义或修改数据库结构，例如 <code>CREATE</code>、<code>ALTER</code>、<code>DROP</code> 等。</p>
</li>
<li class="lvl-2">
<p><strong>DCL（数据控制语言）</strong>：用于控制数据库访问权限，例如 <code>GRANT</code>、<code>REVOKE</code> 等。</p>
</li>
</ul>
<p>虽然 <code>TRUNCATE</code> 会删除数据，但它不会触发 <code>DELETE</code> 触发器，且通常比 <code>DELETE</code> 更快，因此被归类为 DML 而不是 DDL。</p>
<h2 id="83mysql-count函数和sum函数的使用"><a class="markdownIt-Anchor" href="#83mysql-count函数和sum函数的使用"></a> 83.Mysql count函数和sum函数的使用</h2>
<p>在 MySQL 中，<code>COUNT</code> 和 <code>SUM</code> 是两个常用的聚合函数，分别用于统计行数和计算数值列的总和。以下是它们的具体用法和示例：</p>
<hr />
<h3 id="1-count-函数"><a class="markdownIt-Anchor" href="#1-count-函数"></a> 1. <strong><code>COUNT</code> 函数</strong></h3>
<p><code>COUNT</code> 函数用于统计符合条件的行数。</p>
<h4 id="语法-3"><a class="markdownIt-Anchor" href="#语法-3"></a> 语法：</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">COUNT</span>(expression)</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>expression</code> 可以是列名、<code>*</code>（表示所有行）或常量。</p>
</li>
<li class="lvl-2">
<p><code>COUNT(*)</code> 统计所有行，包括 <code>NULL</code> 值。</p>
</li>
<li class="lvl-2">
<p><code>COUNT(column_name)</code> 统计指定列中非 <code>NULL</code> 值的行数。</p>
</li>
</ul>
<h4 id="示例-9"><a class="markdownIt-Anchor" href="#示例-9"></a> 示例：</h4>
<ol>
<li class="lvl-3">
<p>统计表中所有行的数量：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>统计某一列中非 <code>NULL</code> 值的行数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(salary) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>结合 <code>WHERE</code> 条件统计：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;Sales&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>统计不同值的数量（结合 <code>DISTINCT</code>）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> department) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr />
<h3 id="2-sum-函数"><a class="markdownIt-Anchor" href="#2-sum-函数"></a> 2. <strong><code>SUM</code> 函数</strong></h3>
<p><code>SUM</code> 函数用于计算数值列的总和。</p>
<h4 id="语法-4"><a class="markdownIt-Anchor" href="#语法-4"></a> 语法：</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SUM</span>(expression)</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>expression</code> 必须是数值类型的列或表达式。</p>
</li>
<li class="lvl-2">
<p><code>SUM</code> 会忽略 <code>NULL</code> 值。</p>
</li>
</ul>
<h4 id="示例-10"><a class="markdownIt-Anchor" href="#示例-10"></a> 示例：</h4>
<ol>
<li class="lvl-3">
<p>计算某一列的总和：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>结合 <code>WHERE</code> 条件计算总和：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;Sales&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>计算多列的总和：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary <span class="operator">+</span> bonus) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>结合 <code>GROUP BY</code> 分组计算总和：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, <span class="built_in">SUM</span>(salary) </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr />
<h3 id="3-count-和-sum-的区别"><a class="markdownIt-Anchor" href="#3-count-和-sum-的区别"></a> 3. <strong><code>COUNT</code> 和 <code>SUM</code> 的区别</strong></h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>适用数据类型</th>
<th>是否忽略 <code>NULL</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>COUNT</code></td>
<td>统计行数或非 <code>NULL</code> 值的数量</td>
<td>任意类型</td>
<td>是</td>
</tr>
<tr>
<td><code>SUM</code></td>
<td>计算数值列的总和</td>
<td>数值类型（如整数、浮点数）</td>
<td>是</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="4-综合示例"><a class="markdownIt-Anchor" href="#4-综合示例"></a> 4. <strong>综合示例</strong></h3>
<p>假设有一个 <code>orders</code> 表，包含以下数据：</p>
<table>
<thead>
<tr>
<th>order_id</th>
<th>customer_id</th>
<th>amount</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>101</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>102</td>
<td>200</td>
</tr>
<tr>
<td>3</td>
<td>101</td>
<td>150</td>
</tr>
<tr>
<td>4</td>
<td>103</td>
<td>NULL</td>
</tr>
</tbody>
</table>
<ol>
<li class="lvl-3">
<p>统计订单总数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure>
<p>结果：<code>4</code></p>
</li>
<li class="lvl-3">
<p>统计有效订单数量（<code>amount</code> 列非 <code>NULL</code>）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(amount) <span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure>
<p>结果：<code>3</code></p>
</li>
<li class="lvl-3">
<p>计算订单总金额：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(amount) <span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure>
<p>结果：<code>450</code></p>
</li>
<li class="lvl-3">
<p>按客户分组统计订单数量和总金额：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> order_count, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<table>
<thead>
<tr>
<th>customer_id</th>
<th>order_count</th>
<th>total_amount</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>2</td>
<td>250</td>
</tr>
<tr>
<td>102</td>
<td>1</td>
<td>200</td>
</tr>
<tr>
<td>103</td>
<td>1</td>
<td>NULL</td>
</tr>
</tbody>
</table>
</li>
</ol>
<hr />
<p>通过 <code>COUNT</code> 和 <code>SUM</code>，可以轻松实现数据统计和汇总功能。</p>
<h2 id="84transactional-失效场景"><a class="markdownIt-Anchor" href="#84transactional-失效场景"></a> 84.@Transactional 失效场景</h2>
<p>在 Spring 中，<code>@Transactional</code> 注解用于声明事务管理。然而，在某些场景下，<code>@Transactional</code> 可能会失效，导致事务无法正常工作。以下是一些常见的失效场景及其原因：</p>
<hr />
<h3 id="1-transactional-注解应用于非-public-方法"><a class="markdownIt-Anchor" href="#1-transactional-注解应用于非-public-方法"></a> 1. <strong><code>@Transactional</code> 注解应用于非 <code>public</code> 方法</strong></h3>
<p>Spring 的事务管理默认只对 <code>public</code> 方法生效。如果 <code>@Transactional</code> 注解应用于 <code>private</code>、<code>protected</code> 或 <code>package-visible</code> 方法，事务将不会生效。</p>
<h4 id="示例-11"><a class="markdownIt-Anchor" href="#示例-11"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 事务不会生效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法：</h4>
<p>确保 <code>@Transactional</code> 注解仅用于 <code>public</code> 方法。</p>
<hr />
<h3 id="2-方法内部调用导致代理失效"><a class="markdownIt-Anchor" href="#2-方法内部调用导致代理失效"></a> 2. <strong>方法内部调用导致代理失效</strong></h3>
<p>Spring 的事务管理基于 AOP 代理实现。如果在同一个类中，一个非事务方法调用另一个事务方法，事务将不会生效，因为代理对象无法拦截内部调用。</p>
<h4 id="示例-12"><a class="markdownIt-Anchor" href="#示例-12"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        innerMethod(); <span class="comment">// 事务不会生效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 事务操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解决方法-2"><a class="markdownIt-Anchor" href="#解决方法-2"></a> 解决方法：</h4>
<ol>
<li class="lvl-3">
<p>将事务方法移到另一个类中。</p>
</li>
<li class="lvl-3">
<p>使用 <code>AopContext.currentProxy()</code> 获取当前代理对象并调用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    ((UserService) AopContext.currentProxy()).innerMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr />
<h3 id="3-异常被捕获且未抛出"><a class="markdownIt-Anchor" href="#3-异常被捕获且未抛出"></a> 3. <strong>异常被捕获且未抛出</strong></h3>
<p><code>@Transactional</code> 默认只在抛出未检查异常（<code>RuntimeException</code> 及其子类）或错误时回滚事务。如果异常被捕获且未重新抛出，事务将不会回滚。</p>
<h4 id="示例-13"><a class="markdownIt-Anchor" href="#示例-13"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 数据库操作</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 捕获异常但未抛出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解决方法-3"><a class="markdownIt-Anchor" href="#解决方法-3"></a> 解决方法：</h4>
<ol>
<li class="lvl-3">
<p>在捕获异常后重新抛出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 数据库操作</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e); <span class="comment">// 重新抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>使用 <code>@Transactional(rollbackFor = Exception.class)</code> 指定回滚的异常类型。</p>
</li>
</ol>
<hr />
<h3 id="4-事务传播行为配置不当"><a class="markdownIt-Anchor" href="#4-事务传播行为配置不当"></a> 4. <strong>事务传播行为配置不当</strong></h3>
<p><code>@Transactional</code> 的传播行为（<code>propagation</code>）配置不当可能导致事务失效。例如，如果方法配置为 <code>Propagation.NOT_SUPPORTED</code>，则不会开启事务。</p>
<h4 id="示例-14"><a class="markdownIt-Anchor" href="#示例-14"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 不会开启事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解决方法-4"><a class="markdownIt-Anchor" href="#解决方法-4"></a> 解决方法：</h4>
<p>根据业务需求正确配置传播行为。</p>
<hr />
<h3 id="5-数据库引擎不支持事务"><a class="markdownIt-Anchor" href="#5-数据库引擎不支持事务"></a> 5. <strong>数据库引擎不支持事务</strong></h3>
<p>某些数据库引擎（如 MySQL 的 MyISAM）不支持事务。如果使用这些引擎，<code>@Transactional</code> 将失效。</p>
<h4 id="解决方法-5"><a class="markdownIt-Anchor" href="#解决方法-5"></a> 解决方法：</h4>
<p>将数据库引擎切换为支持事务的引擎（如 InnoDB）。</p>
<hr />
<h3 id="6-transactional-注解未启用"><a class="markdownIt-Anchor" href="#6-transactional-注解未启用"></a> 6. <strong><code>@Transactional</code> 注解未启用</strong></h3>
<p>如果 Spring 的事务管理未启用，<code>@Transactional</code> 注解将不会生效。</p>
<h4 id="解决方法-6"><a class="markdownIt-Anchor" href="#解决方法-6"></a> 解决方法：</h4>
<p>确保在配置类或 XML 配置中启用了事务管理：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用注解驱动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 配置数据源和事务管理器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>使用 XML 配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr />
<h3 id="7-事务管理器未正确配置"><a class="markdownIt-Anchor" href="#7-事务管理器未正确配置"></a> 7. <strong>事务管理器未正确配置</strong></h3>
<p>如果未正确配置事务管理器（如 <code>PlatformTransactionManager</code>），事务将无法正常工作。</p>
<h4 id="解决方法-7"><a class="markdownIt-Anchor" href="#解决方法-7"></a> 解决方法：</h4>
<p>确保正确配置事务管理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="8-多线程环境下事务失效"><a class="markdownIt-Anchor" href="#8-多线程环境下事务失效"></a> 8. <strong>多线程环境下事务失效</strong></h3>
<p>在多线程环境下，事务可能无法跨线程传播，导致事务失效。</p>
<h4 id="示例-15"><a class="markdownIt-Anchor" href="#示例-15"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 事务不会生效</span></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解决方法-8"><a class="markdownIt-Anchor" href="#解决方法-8"></a> 解决方法：</h4>
<p>避免在多线程环境下直接操作事务，或将事务操作放在主线程中执行。</p>
<hr />
<h3 id="9-transactional-注解的-rollbackfor-配置错误"><a class="markdownIt-Anchor" href="#9-transactional-注解的-rollbackfor-配置错误"></a> 9. <strong><code>@Transactional</code> 注解的 <code>rollbackFor</code> 配置错误</strong></h3>
<p>默认情况下，<code>@Transactional</code> 只在抛出 <code>RuntimeException</code> 时回滚事务。如果抛出了检查异常（checked exception），事务不会回滚。</p>
<h4 id="示例-16"><a class="markdownIt-Anchor" href="#示例-16"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 数据库操作</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(); <span class="comment">// 事务不会回滚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解决方法-9"><a class="markdownIt-Anchor" href="#解决方法-9"></a> 解决方法：</h4>
<p>显式指定 <code>rollbackFor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 数据库操作</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(); <span class="comment">// 事务会回滚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="10-事务超时或只读配置不当"><a class="markdownIt-Anchor" href="#10-事务超时或只读配置不当"></a> 10. <strong>事务超时或只读配置不当</strong></h3>
<p>如果事务超时（<code>timeout</code>）或只读（<code>readOnly</code>）配置不当，可能导致事务失效。</p>
<h4 id="示例-17"><a class="markdownIt-Anchor" href="#示例-17"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(timeout = 1)</span> <span class="comment">// 超时时间过短</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 长时间操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解决方法-10"><a class="markdownIt-Anchor" href="#解决方法-10"></a> 解决方法：</h4>
<p>根据业务需求合理配置 <code>timeout</code> 和 <code>readOnly</code>。</p>
<hr />
<h3 id="总结-5"><a class="markdownIt-Anchor" href="#总结-5"></a> 总结</h3>
<p><code>@Transactional</code> 失效的常见原因包括：</p>
<ol>
<li class="lvl-3">
<p>方法非 <code>public</code>。</p>
</li>
<li class="lvl-3">
<p>方法内部调用。</p>
</li>
<li class="lvl-3">
<p>异常被捕获且未抛出。</p>
</li>
<li class="lvl-3">
<p>传播行为配置不当。</p>
</li>
<li class="lvl-3">
<p>数据库引擎不支持事务。</p>
</li>
<li class="lvl-3">
<p>事务管理未启用。</p>
</li>
<li class="lvl-3">
<p>事务管理器未正确配置。</p>
</li>
<li class="lvl-3">
<p>多线程环境下事务失效。</p>
</li>
<li class="lvl-3">
<p><code>rollbackFor</code> 配置错误。</p>
</li>
<li class="lvl-4">
<p>事务超时或只读配置不当。</p>
</li>
</ol>
<p>通过排查这些问题，可以有效避免 <code>@Transactional</code> 失效的情况。</p>
<h2 id="85switch-case-条件可以使用什么类型"><a class="markdownIt-Anchor" href="#85switch-case-条件可以使用什么类型"></a> 85.Switch case 条件可以使用什么类型</h2>
<p>在 Java 中，<code>switch-case</code> 语句的条件表达式（即 <code>switch</code> 后的表达式）可以使用以下类型：</p>
<hr />
<h3 id="1-基本数据类型"><a class="markdownIt-Anchor" href="#1-基本数据类型"></a> 1. <strong>基本数据类型</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>byte</code></p>
</li>
<li class="lvl-2">
<p><code>short</code></p>
</li>
<li class="lvl-2">
<p><code>int</code></p>
</li>
<li class="lvl-2">
<p><code>char</code></p>
</li>
</ul>
<h4 id="示例-18"><a class="markdownIt-Anchor" href="#示例-18"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Monday&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Tuesday&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Wednesday&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Invalid day&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="2-包装类型从-java-5-开始支持"><a class="markdownIt-Anchor" href="#2-包装类型从-java-5-开始支持"></a> 2. <strong>包装类型（从 Java 5 开始支持）</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>Byte</code></p>
</li>
<li class="lvl-2">
<p><code>Short</code></p>
</li>
<li class="lvl-2">
<p><code>Integer</code></p>
</li>
<li class="lvl-2">
<p><code>Character</code></p>
</li>
</ul>
<h4 id="示例-19"><a class="markdownIt-Anchor" href="#示例-19"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span> (num) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;One&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Two&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="3-枚举类型从-java-5-开始支持"><a class="markdownIt-Anchor" href="#3-枚举类型从-java-5-开始支持"></a> 3. <strong>枚举类型（从 Java 5 开始支持）</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>enum</code></p>
</li>
</ul>
<h4 id="示例-20"><a class="markdownIt-Anchor" href="#示例-20"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123; MONDAY, TUESDAY, WEDNESDAY &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Day</span> <span class="variable">day</span> <span class="operator">=</span> Day.WEDNESDAY;</span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">        System.out.println(<span class="string">&quot;Monday&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        System.out.println(<span class="string">&quot;Tuesday&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">        System.out.println(<span class="string">&quot;Wednesday&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Invalid day&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="4-字符串类型从-java-7-开始支持"><a class="markdownIt-Anchor" href="#4-字符串类型从-java-7-开始支持"></a> 4. <strong>字符串类型（从 Java 7 开始支持）</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>String</code></p>
</li>
</ul>
<h4 id="示例-21"><a class="markdownIt-Anchor" href="#示例-21"></a> 示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Apple&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;It&#x27;s an apple.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Banana&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;It&#x27;s a banana.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown fruit.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="5-不支持的类型"><a class="markdownIt-Anchor" href="#5-不支持的类型"></a> 5. <strong>不支持的类型</strong></h3>
<p>以下类型不能用于 <code>switch-case</code> 语句：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>long</code></p>
</li>
<li class="lvl-2">
<p><code>float</code></p>
</li>
<li class="lvl-2">
<p><code>double</code></p>
</li>
<li class="lvl-2">
<p><code>boolean</code></p>
</li>
<li class="lvl-2">
<p>自定义对象（除非是枚举类型）</p>
</li>
</ul>
<h4 id="示例错误用法"><a class="markdownIt-Anchor" href="#示例错误用法"></a> 示例（错误用法）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10L</span>;</span><br><span class="line"><span class="keyword">switch</span> (value) &#123; <span class="comment">// 编译错误：不支持 long 类型</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">10L</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Ten&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="6-注意事项"><a class="markdownIt-Anchor" href="#6-注意事项"></a> 6. <strong>注意事项</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>case</code> 标签必须是常量</strong>：<code>case</code> 后的值必须是编译时常量，不能是变量或表达式。</p>
</li>
<li class="lvl-2">
<p><strong><code>default</code> 分支可选</strong>：<code>default</code> 分支是可选的，用于处理未匹配的情况。</p>
</li>
<li class="lvl-2">
<p><strong><code>break</code> 语句</strong>：如果没有 <code>break</code>，程序会继续执行后续 <code>case</code> 分支（称为“贯穿”行为）。</p>
</li>
</ul>
<h4 id="示例贯穿行为"><a class="markdownIt-Anchor" href="#示例贯穿行为"></a> 示例（贯穿行为）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span> (num) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;One&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Two&quot;</span>); <span class="comment">// 会执行</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Three&quot;</span>); <span class="comment">// 会执行</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Other&quot;</span>); <span class="comment">// 会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="总结-6"><a class="markdownIt-Anchor" href="#总结-6"></a> 总结</h3>
<p><code>switch-case</code> 语句支持以下类型：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>基本数据类型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>char</code></p>
</li>
<li class="lvl-2">
<p>包装类型：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Character</code></p>
</li>
<li class="lvl-2">
<p>枚举类型：<code>enum</code></p>
</li>
<li class="lvl-2">
<p>字符串类型：<code>String</code></p>
</li>
</ul>
<p>不支持的类型包括 <code>long</code>、<code>float</code>、<code>double</code>、<code>boolean</code> 以及自定义对象（枚举除外）。</p>
<h2 id="86springboot简介"><a class="markdownIt-Anchor" href="#86springboot简介"></a> 86.Springboot简介</h2>
<h3 id="spring-boot-简介"><a class="markdownIt-Anchor" href="#spring-boot-简介"></a> Spring Boot 简介</h3>
<p><strong>Spring Boot</strong> 是 Spring 生态系统中的一个重要项目，旨在简化 Spring 应用的开发和部署。它通过提供默认配置和自动化配置，减少了开发者在搭建和配置 Spring 应用时的复杂性，使开发者能够快速构建独立、生产级的应用程序。</p>
<hr />
<h3 id="1-spring-boot-的核心特点"><a class="markdownIt-Anchor" href="#1-spring-boot-的核心特点"></a> 1. <strong>Spring Boot 的核心特点</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>快速启动</strong>：通过内嵌的 Tomcat、Jetty 或 Undertow 服务器，Spring Boot 应用可以直接运行，无需部署到外部服务器。</p>
</li>
<li class="lvl-2">
<p><strong>自动配置</strong>：Spring Boot 根据项目的依赖自动配置 Spring 框架和第三方库，减少了手动配置的工作量。</p>
</li>
<li class="lvl-2">
<p><strong>独立运行</strong>：Spring Boot 应用可以打包为可执行的 JAR 或 WAR 文件，直接通过 <code>java -jar</code> 命令运行。</p>
</li>
<li class="lvl-2">
<p><strong>无代码生成</strong>：Spring Boot 不需要生成额外的代码或 XML 配置文件，完全基于注解和约定。</p>
</li>
<li class="lvl-2">
<p><strong>生产就绪</strong>：提供健康检查、指标监控、外部化配置等生产级特性。</p>
</li>
</ul>
<hr />
<h3 id="2-spring-boot-的核心组件"><a class="markdownIt-Anchor" href="#2-spring-boot-的核心组件"></a> 2. <strong>Spring Boot 的核心组件</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Spring Boot Starter</strong>：一系列依赖描述符，简化 Maven/Gradle 依赖管理。例如：</p>
<ul class="lvl-2">
<li class="lvl-4"><code>spring-boot-starter-web</code>：用于构建 Web 应用。</li>
<li class="lvl-4"><code>spring-boot-starter-data-jpa</code>：用于集成 JPA 和数据库。</li>
<li class="lvl-4"><code>spring-boot-starter-test</code>：用于单元测试。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>Spring Boot Auto-Configuration</strong>：根据类路径中的依赖自动配置 Spring 应用。</p>
</li>
<li class="lvl-2">
<p><strong>Spring Boot Actuator</strong>：提供生产级监控和管理功能，如健康检查、指标收集等。</p>
</li>
<li class="lvl-2">
<p><strong>Spring Boot CLI</strong>：命令行工具，支持快速开发和运行 Groovy 脚本。</p>
</li>
</ul>
<hr />
<h3 id="3-spring-boot-的优势"><a class="markdownIt-Anchor" href="#3-spring-boot-的优势"></a> 3. <strong>Spring Boot 的优势</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>简化开发</strong>：通过默认配置和自动化配置，减少了开发者的工作量。</p>
</li>
<li class="lvl-2">
<p><strong>快速迭代</strong>：支持热部署和热加载，开发效率高。</p>
</li>
<li class="lvl-2">
<p><strong>微服务友好</strong>：Spring Boot 是构建微服务架构的理想选择，与 Spring Cloud 无缝集成。</p>
</li>
<li class="lvl-2">
<p><strong>丰富的生态系统</strong>：与 Spring 生态系统（如 Spring Data、Spring Security 等）完美集成。</p>
</li>
<li class="lvl-2">
<p><strong>社区支持</strong>：Spring Boot 拥有庞大的社区和丰富的文档资源。</p>
</li>
</ul>
<hr />
<h3 id="4-spring-boot-的典型应用场景"><a class="markdownIt-Anchor" href="#4-spring-boot-的典型应用场景"></a> 4. <strong>Spring Boot 的典型应用场景</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Web 应用开发</strong>：快速构建 RESTful API 或 MVC 应用。</p>
</li>
<li class="lvl-2">
<p><strong>微服务架构</strong>：作为微服务的基础框架，与 Spring Cloud 配合使用。</p>
</li>
<li class="lvl-2">
<p><strong>批处理应用</strong>：通过 Spring Batch 支持批处理任务。</p>
</li>
<li class="lvl-2">
<p><strong>数据访问应用</strong>：集成 JPA、MyBatis 等数据访问框架。</p>
</li>
<li class="lvl-2">
<p><strong>消息驱动应用</strong>：集成 RabbitMQ、Kafka 等消息中间件。</p>
</li>
</ul>
<hr />
<h3 id="5-spring-boot-的简单示例"><a class="markdownIt-Anchor" href="#5-spring-boot-的简单示例"></a> 5. <strong>Spring Boot 的简单示例</strong></h3>
<h4 id="示例-1创建一个简单的-spring-boot-web-应用"><a class="markdownIt-Anchor" href="#示例-1创建一个简单的-spring-boot-web-应用"></a> 示例 1：创建一个简单的 Spring Boot Web 应用</h4>
<ol>
<li class="lvl-3">
<p><strong>添加依赖</strong>（<code>pom.xml</code>）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>编写主类</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>运行应用</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">运行 <code>MyApplication</code> 类，Spring Boot 会启动内嵌的 Tomcat 服务器。</li>
<li class="lvl-5">访问 <code>http://localhost:8080/hello</code>，页面会显示 <code>Hello, Spring Boot!</code>。</li>
</ul>
</li>
</ol>
<hr />
<h4 id="示例-2配置文件的使用"><a class="markdownIt-Anchor" href="#示例-2配置文件的使用"></a> 示例 2：配置文件的使用</h4>
<p>Spring Boot 支持通过 <code>application.properties</code> 或 <code>application.yml</code> 文件进行配置。</p>
<ol>
<li class="lvl-3">
<p><strong><code>application.properties</code></strong>：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mydb</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong><code>application.yml</code></strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mydb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr />
<h3 id="6-spring-boot-的启动流程"><a class="markdownIt-Anchor" href="#6-spring-boot-的启动流程"></a> 6. <strong>Spring Boot 的启动流程</strong></h3>
<ol>
<li class="lvl-3">
<p>加载 <code>@SpringBootApplication</code> 注解标记的主类。</p>
</li>
<li class="lvl-3">
<p>扫描类路径下的组件（如 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 等）。</p>
</li>
<li class="lvl-3">
<p>根据依赖自动配置 Spring 应用（如数据源、Web 服务器等）。</p>
</li>
<li class="lvl-3">
<p>启动内嵌的 Web 服务器并运行应用。</p>
</li>
</ol>
<hr />
<h3 id="7-spring-boot-的生态系统"><a class="markdownIt-Anchor" href="#7-spring-boot-的生态系统"></a> 7. <strong>Spring Boot 的生态系统</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Spring Cloud</strong>：用于构建分布式系统和微服务架构。</p>
</li>
<li class="lvl-2">
<p><strong>Spring Data</strong>：简化数据访问操作，支持关系型数据库和 NoSQL 数据库。</p>
</li>
<li class="lvl-2">
<p><strong>Spring Security</strong>：提供身份验证和授权功能。</p>
</li>
<li class="lvl-2">
<p><strong>Spring Batch</strong>：用于批处理任务。</p>
</li>
<li class="lvl-2">
<p><strong>Spring Integration</strong>：支持企业集成模式。</p>
</li>
</ul>
<hr />
<h3 id="8-spring-boot-的版本"><a class="markdownIt-Anchor" href="#8-spring-boot-的版本"></a> 8. <strong>Spring Boot 的版本</strong></h3>
<p>Spring Boot 的版本号格式为 <code>X.Y.Z</code>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>X</code>：主版本号，表示重大更新。</p>
</li>
<li class="lvl-2">
<p><code>Y</code>：次版本号，表示新特性或改进。</p>
</li>
<li class="lvl-2">
<p><code>Z</code>：修订版本号，表示 bug 修复。</p>
</li>
</ul>
<p>截至 2023 年，最新的稳定版本是 <strong>Spring Boot 3.x</strong>，基于 Spring Framework 6.x 和 Java 17+。</p>
<hr />
<h3 id="总结-7"><a class="markdownIt-Anchor" href="#总结-7"></a> 总结</h3>
<p>Spring Boot 是一个强大的框架，通过简化配置和提供默认值，极大地提高了开发效率。它适用于各种应用场景，从简单的 Web 应用到复杂的微服务架构。无论是初学者还是经验丰富的开发者，Spring Boot 都是一个值得学习和使用的工具。</p>
<h2 id="87arraylist与hashmap的区别"><a class="markdownIt-Anchor" href="#87arraylist与hashmap的区别"></a> 87.Arraylist与hashmap的区别</h2>
<p><code>ArrayList</code> 和 <code>HashMap</code> 是 Java 集合框架中两个常用的类，但它们的设计目的和使用场景完全不同。以下是它们的详细区别：</p>
<hr />
<h3 id="1-基本定义"><a class="markdownIt-Anchor" href="#1-基本定义"></a> 1. <strong>基本定义</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>ArrayList</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">是基于动态数组的实现。</li>
<li class="lvl-4">属于 <code>List</code> 接口的实现类。</li>
<li class="lvl-4">存储有序的元素集合，允许重复元素。</li>
<li class="lvl-4">通过索引访问元素。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong><code>HashMap</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">是基于哈希表的实现。</li>
<li class="lvl-4">属于 <code>Map</code> 接口的实现类。</li>
<li class="lvl-4">存储键值对（<code>key-value</code>），键不允许重复，值可以重复。</li>
<li class="lvl-4">通过键访问值。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="2-数据结构"><a class="markdownIt-Anchor" href="#2-数据结构"></a> 2. <strong>数据结构</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>ArrayList</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">内部使用数组存储元素。</li>
<li class="lvl-4">元素按插入顺序存储，可以通过索引快速访问。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong><code>HashMap</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">内部使用数组和链表（或红黑树）实现。</li>
<li class="lvl-4">通过哈希函数将键映射到数组的索引位置，解决哈希冲突时使用链表或红黑树。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="3-元素存储方式"><a class="markdownIt-Anchor" href="#3-元素存储方式"></a> 3. <strong>元素存储方式</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>ArrayList</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">存储单个元素。</li>
<li class="lvl-4">示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Banana&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong><code>HashMap</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">存储键值对。</li>
<li class="lvl-4">示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Apple&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;Banana&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="4-性能特点"><a class="markdownIt-Anchor" href="#4-性能特点"></a> 4. <strong>性能特点</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>ArrayList</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>查询</strong>：通过索引访问元素的时间复杂度为 <code>O(1)</code>。</li>
<li class="lvl-4"><strong>插入/删除</strong>：
<ul class="lvl-4">
<li class="lvl-6">在末尾插入或删除元素的时间复杂度为 <code>O(1)</code>。</li>
<li class="lvl-6">在中间插入或删除元素的时间复杂度为 <code>O(n)</code>（需要移动元素）。</li>
</ul>
</li>
<li class="lvl-4"><strong>适用场景</strong>：需要频繁按索引访问元素的场景。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong><code>HashMap</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>查询</strong>：通过键访问值的时间复杂度为 <code>O(1)</code>（平均情况）。</li>
<li class="lvl-4"><strong>插入/删除</strong>：插入或删除键值对的时间复杂度为 <code>O(1)</code>（平均情况）。</li>
<li class="lvl-4"><strong>适用场景</strong>：需要快速查找、插入或删除键值对的场景。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="5-允许的元素类型"><a class="markdownIt-Anchor" href="#5-允许的元素类型"></a> 5. <strong>允许的元素类型</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>ArrayList</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">可以存储任意类型的对象（包括 <code>null</code>）。</li>
<li class="lvl-4">示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;String&quot;</span>);</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line">list.add(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong><code>HashMap</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">键和值可以是任意类型的对象（键不能为 <code>null</code>，值可以为 <code>null</code>）。</li>
<li class="lvl-4">示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">123</span>);</span><br><span class="line">map.put(<span class="string">&quot;key3&quot;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="6-线程安全性"><a class="markdownIt-Anchor" href="#6-线程安全性"></a> 6. <strong>线程安全性</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>ArrayList</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">不是线程安全的。</li>
<li class="lvl-4">如果需要线程安全，可以使用 <code>Collections.synchronizedList</code> 或 <code>CopyOnWriteArrayList</code>。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong><code>HashMap</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">不是线程安全的。</li>
<li class="lvl-4">如果需要线程安全，可以使用 <code>Collections.synchronizedMap</code> 或 <code>ConcurrentHashMap</code>。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="7-扩容机制"><a class="markdownIt-Anchor" href="#7-扩容机制"></a> 7. <strong>扩容机制</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>ArrayList</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">初始容量为 10，当元素数量超过容量时，自动扩容为原来的 1.5 倍。</li>
<li class="lvl-4">示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    list.add(i); <span class="comment">// 当元素数量超过 10 时，会自动扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong><code>HashMap</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">初始容量为 16，负载因子为 0.75。当元素数量超过容量与负载因子的乘积时，自动扩容为原来的 2 倍。</li>
<li class="lvl-4">示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    map.put(i, <span class="string">&quot;value&quot;</span> + i); <span class="comment">// 当元素数量超过 12 时，会自动扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="8-遍历方式"><a class="markdownIt-Anchor" href="#8-遍历方式"></a> 8. <strong>遍历方式</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>ArrayList</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">可以使用索引遍历、迭代器遍历或增强 for 循环。</li>
<li class="lvl-4">示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强 for 循环</span></span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong><code>HashMap</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">可以使用键遍历、值遍历或键值对遍历。</li>
<li class="lvl-4">示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Apple&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;Banana&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历键</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历值</span></span><br><span class="line"><span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历键值对</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="9-适用场景"><a class="markdownIt-Anchor" href="#9-适用场景"></a> 9. <strong>适用场景</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>ArrayList</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">需要存储有序元素集合。</li>
<li class="lvl-4">需要频繁按索引访问元素。</li>
<li class="lvl-4">允许元素重复。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong><code>HashMap</code></strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">需要存储键值对。</li>
<li class="lvl-4">需要快速查找、插入或删除键值对。</li>
<li class="lvl-4">键不允许重复，值可以重复。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="总结-8"><a class="markdownIt-Anchor" href="#总结-8"></a> 总结</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>ArrayList</code></th>
<th><code>HashMap</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据结构</strong></td>
<td>动态数组</td>
<td>哈希表</td>
</tr>
<tr>
<td><strong>存储方式</strong></td>
<td>单个元素</td>
<td>键值对</td>
</tr>
<tr>
<td><strong>查询性能</strong></td>
<td>按索引访问：<code>O(1)</code></td>
<td>按键访问：<code>O(1)</code>（平均情况）</td>
</tr>
<tr>
<td><strong>插入/删除性能</strong></td>
<td>末尾操作：<code>O(1)</code>；中间操作：<code>O(n)</code></td>
<td><code>O(1)</code>（平均情况）</td>
</tr>
<tr>
<td><strong>允许重复</strong></td>
<td>允许元素重复</td>
<td>键不允许重复，值允许重复</td>
</tr>
<tr>
<td><strong>线程安全性</strong></td>
<td>非线程安全</td>
<td>非线程安全</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>有序集合、按索引访问</td>
<td>键值对存储、快速查找</td>
</tr>
</tbody>
</table>
<p>根据具体需求选择合适的集合类：如果需要有序集合，使用 <code>ArrayList</code>；如果需要键值对存储，使用 <code>HashMap</code>。</p>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2025-02-24</span>
            
                <span>该篇文章被 up</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/Java/'>
                            Java
                        </a>
                    
                        <a href='/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/'>
                            面试题
                        </a>
                    
                </span>
             
             
        
        </i>
    </div>
    <br>
    
    

     
</div>




                    

                    <div class="footer">
    
        <span> 
            © 2025 UP 

            
                

            
                
                    / <a href="/"> Home </a>
                

            
                
                    / <a href="/list"> Archive </a>
                

            
                
                    / <a href="/ch"> Channel </a>
                

            
                
                    / <a href="/sitemap.xml"> Sitemap </a>
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery/lightgallery.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


                </div>
            
            
                <!-- 回到顶部的按钮-->
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
    </body>
</html>
<script src="/js/emojiHandler.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        wrapEmojis('.paper');
    });
</script>
