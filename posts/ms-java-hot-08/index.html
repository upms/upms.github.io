<!DOCTYPE html>
<html lang="en">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="Java 热门面试题-08" />
    <meta name="hexo-theme-A4" content="v1.9.8" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title></title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
    
   
<link rel="stylesheet" href="/css/lightgallery-bundle.min.css">


   
        
<link rel="stylesheet" href="/css/custom.css">

    

<meta name="generator" content="Hexo 7.1.1"></head>
    
    

    
    



    

    
    




    
    

    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <style>
            .header-img {
                width: 56px;
                height: auto;
                object-fit: cover; /* 保持图片比例 */
                transition: transform 0.3s ease-in-out; 
                border-radius: 0; 
            }
            
        </style>
        <img 
            alt="^-^" 
            cache-control="max-age=86400" 
            class="header-img" 
            src="/img/favicon.webp" 
        />
        <div class="header-content">
            <a class="logo" href="/"></a> 
            <span class="description"></span> 
        </div>
    </div>
    
   
    <ul class="nav">
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    Java 热门面试题-08
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                    <span>最近更新：2025-05-27</span> 
                
                
                    
                        &nbsp; | &nbsp;
                    
                     <span>字数总计：12.4k</span>
                
                
                
            </div>
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-aop"><span class="post-toc-text"> 什么是 AOP？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#aop-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="post-toc-text"> AOP 的核心概念</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#aop-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="post-toc-text"> AOP 的实现方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="post-toc-text"> 示例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#spring-aop-%E7%A4%BA%E4%BE%8B"><span class="post-toc-text"> Spring AOP 示例</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93"><span class="post-toc-text"> 总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="post-toc-text"> 什么是服务降级？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#synchronized-%E5%92%8C-reentrantlock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="post-toc-text"> Synchronized 和 ReentrantLock 有什么区别？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#redis-%E7%9A%84-lua-%E8%84%9A%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="post-toc-text"> Redis 的 Lua 脚本功能是什么？如何使用？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#http-20-%E5%92%8C-30-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="post-toc-text"> HTTP 2.0 和 3.0 有什么区别？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="post-toc-text"> 单例模式有哪几种实现？如何保证线程安全？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#java-%E7%9A%84-synchronized-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="post-toc-text"> Java 的 synchronized 是怎么实现的？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E5%8A%9F%E8%83%BD"><span class="post-toc-text"> 如何设计一个秒杀功能？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9F%E7%9A%84-nio-%E8%80%8C%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8-netty-%E5%91%A2"><span class="post-toc-text"> 为什么不选择使用原生的 NIO 而选择使用 Netty 呢？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%9C%8B%E8%BF%87%E6%BA%90%E7%A0%81%E5%90%97%E8%AF%B4%E4%B8%8B-spring-%E7%94%B1%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E6%A8%A1%E5%9D%97%E7%BB%84%E6%88%90"><span class="post-toc-text"> 看过源码吗？说下 Spring 由哪些重要的模块组成？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-java-%E4%B8%AD%E7%9A%84%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="post-toc-text"> 如何优化 Java 中的锁的使用？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#redis-%E7%9A%84-pipeline-%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88"><span class="post-toc-text"> Redis 的 Pipeline 功能是什么？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F-id-%E5%8F%91%E5%8F%B7%E5%99%A8%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="post-toc-text"> 让你设计一个分布式 ID 发号器，怎么设计？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="post-toc-text"> 1. 设计目标</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="post-toc-text"> 2. 设计原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0"><span class="post-toc-text"> 3. 设计实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%89%A9%E5%B1%95"><span class="post-toc-text"> 4. 优化与扩展</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="post-toc-text"> 5. 总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9"><span class="post-toc-text"> 什么是服务雪崩？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#jvm-%E7%94%B1%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90"><span class="post-toc-text"> JVM 由哪些部分组成？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#redis-%E9%80%9A%E5%B8%B8%E5%BA%94%E7%94%A8%E4%BA%8E%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF"><span class="post-toc-text"> Redis 通常应用于哪些场景？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%9F%AD%E9%93%BE%E7%B3%BB%E7%BB%9F%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="post-toc-text"> 让你设计一个短链系统，怎么设计？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="post-toc-text"> 1. 问题描述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="post-toc-text"> 2. 系统设计</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#21-%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82"><span class="post-toc-text"> 2.1 功能需求</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#22-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B"><span class="post-toc-text"> 2.2 技术选型</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="post-toc-text"> 3. 实现细节</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#31-snowflake-id%E7%94%9F%E6%88%90%E5%99%A8"><span class="post-toc-text"> 3.1 Snowflake ID生成器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#32-base62%E7%BC%96%E7%A0%81"><span class="post-toc-text"> 3.2 Base62编码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#33-redis%E5%AD%98%E5%82%A8"><span class="post-toc-text"> 3.3 Redis存储</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#34-shortener%E7%B1%BB"><span class="post-toc-text"> 3.4 Shortener类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#35-flask-web%E6%9C%8D%E5%8A%A1"><span class="post-toc-text"> 3.5 Flask Web服务</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B5%8B%E8%AF%95"><span class="post-toc-text"> 4. 系统部署与测试</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#41-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="post-toc-text"> 4.1 环境准备</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#42-%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B"><span class="post-toc-text"> 4.2 测试流程</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-%E7%BB%93%E8%AE%BA"><span class="post-toc-text"> 5. 结论</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%B8%B8%E9%97%AE"><span class="post-toc-text"> 什么是循环依赖（常问）？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98%E7%9A%84%E4%B8%BB%E8%A6%81%E7%9B%AE%E6%A0%87%E6%98%AF%E4%BB%80%E4%B9%88"><span class="post-toc-text"> JVM 垃圾回收调优的主要目标是什么？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#redis-%E4%B8%AD%E7%9A%84-big-key-%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="post-toc-text"> Redis 中的 Big Key 问题是什么？如何解决？</span></a></li></ol>
            
        
        <div class=".article-gallery"><!-- 
什么是 AOP？
什么是服务降级？
Synchronized 和 ReentrantLock 有什么区别？
Redis 的 Lua 脚本功能是什么？如何使用？
HTTP 2.0 和 3.0 有什么区别？
单例模式有哪几种实现？如何保证线程安全？
Java 的 synchronized 是怎么实现的？
如何设计一个秒杀功能？
为什么不选择使用原生的 NIO 而选择使用 Netty 呢？
看过源码吗？说下 Spring 由哪些重要的模块组成？
如何优化 Java 中的锁的使用？
Redis 的 Pipeline 功能是什么？
让你设计一个分布式 ID 发号器，怎么设计？
什么是服务雪崩？
JVM 由哪些部分组成？
Redis 通常应用于哪些场景？
让你设计一个短链系统，怎么设计？
什么是循环依赖（常问）？
JVM 垃圾回收调优的主要目标是什么？
Redis 中的 Big Key 问题是什么？如何解决？

-->
<h2 id="什么是-aop"><a class="markdownIt-Anchor" href="#什么是-aop"></a> 什么是 AOP？</h2>
<p><strong>AOP（Aspect-Oriented Programming，面向切面编程）</strong> 是一种编程范式，旨在通过分离横切关注点（cross-cutting concerns）来提高代码的模块化。横切关注点是指那些跨越多个模块的功能，如日志记录、事务管理、安全控制等。AOP 通过将这些关注点从核心业务逻辑中分离出来，使代码更易于维护和扩展。</p>
<h3 id="aop-的核心概念"><a class="markdownIt-Anchor" href="#aop-的核心概念"></a> AOP 的核心概念</h3>
<ol>
<li class="lvl-3">
<p><strong>切面（Aspect）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">切面是横切关注点的模块化，通常包含通知和切点。</li>
<li class="lvl-5">例如，日志记录切面可以包含在方法执行前后记录日志的逻辑。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>连接点（Join Point）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">连接点是程序执行过程中的特定点，如方法调用、异常抛出等。</li>
<li class="lvl-5">AOP 框架可以在这些点上插入切面逻辑。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>通知（Advice）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">通知是切面在特定连接点执行的动作。</li>
<li class="lvl-5">常见的通知类型包括：
<ul class="lvl-4">
<li class="lvl-7"><strong>前置通知（Before）</strong>：在连接点之前执行。</li>
<li class="lvl-7"><strong>后置通知（After）</strong>：在连接点之后执行，无论是否抛出异常。</li>
<li class="lvl-7"><strong>返回通知（After-returning）</strong>：在连接点正常返回后执行。</li>
<li class="lvl-7"><strong>异常通知（After-throwing）</strong>：在连接点抛出异常后执行。</li>
<li class="lvl-7"><strong>环绕通知（Around）</strong>：在连接点前后执行，可以控制是否执行连接点。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>切点（Pointcut）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">切点是匹配连接点的表达式，用于定义哪些连接点会触发通知。</li>
<li class="lvl-5">例如，切点可以匹配所有以 <code>save</code> 开头的方法。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>引入（Introduction）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">引入允许向现有类添加新的方法或属性。</li>
<li class="lvl-5">例如，可以通过引入为所有业务类添加一个新的方法。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>目标对象（Target Object）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">目标对象是被一个或多个切面通知的对象。</li>
<li class="lvl-5">例如，一个业务类可能是目标对象。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>代理（Proxy）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">代理是 AOP 框架创建的对象，用于在目标对象的方法调用前后插入切面逻辑。</li>
<li class="lvl-5">例如，Spring AOP 使用 JDK 动态代理或 CGLIB 代理。</li>
</ul>
</li>
</ol>
<h3 id="aop-的实现方式"><a class="markdownIt-Anchor" href="#aop-的实现方式"></a> AOP 的实现方式</h3>
<ol>
<li class="lvl-3">
<p><strong>静态 AOP</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">在编译时或类加载时织入切面逻辑。</li>
<li class="lvl-5">例如，AspectJ 的编译时织入。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>动态 AOP</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">在运行时织入切面逻辑。</li>
<li class="lvl-5">例如，Spring AOP 使用动态代理。</li>
</ul>
</li>
</ol>
<h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3>
<h4 id="spring-aop-示例"><a class="markdownIt-Anchor" href="#spring-aop-示例"></a> Spring AOP 示例</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;execution(* com.example.service.*.*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfterReturning</span><span class="params">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After returning from method: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(pointcut = &quot;execution(* com.example.service.*.*(..))&quot;, throwing = &quot;error&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable error)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After throwing from method: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Exception: &quot;</span> + error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>AOP（面向切面编程）</strong> 通过分离横切关注点提高代码模块化。</p>
</li>
<li class="lvl-2">
<p><strong>核心概念</strong> 包括切面、连接点、通知、切点、引入、目标对象和代理。</p>
</li>
<li class="lvl-2">
<p><strong>实现方式</strong> 包括静态 AOP 和动态 AOP。</p>
</li>
</ul>
<p>AOP 使代码更易于维护和扩展，适合处理日志记录、事务管理、安全控制等横切关注点。</p>
<h2 id="什么是服务降级"><a class="markdownIt-Anchor" href="#什么是服务降级"></a> 什么是服务降级？</h2>
<p>服务降级的定义及其作用</p>
<ol>
<li class="lvl-3">
<p><strong>服务降级的定义</strong></p>
<p>服务降级是指在系统面临高负载或某些服务不可用时，通过简化服务功能或返回默认值来保证核心服务的可用性。这是一种权衡性能与功能的策略，旨在防止系统因部分服务故障而全面崩溃。</p>
</li>
<li class="lvl-3">
<p><strong>服务降级的场景</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>高并发访问</strong>：当系统访问量激增，某些服务响应时间变长或超时，为了保证整体系统的响应速度，可以对非核心服务进行降级。</li>
<li class="lvl-5"><strong>服务故障</strong>：当某个服务出现故障或不可用时，为了不影响整个系统，可以临时关闭或返回默认值。</li>
<li class="lvl-5"><strong>资源不足</strong>：当系统资源（如CPU、内存）紧张时，可以通过降级非关键服务来释放资源，保证核心服务的正常运行。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>服务降级的实现方式</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>返回默认值</strong>：当服务不可用时，返回预先定义的默认值或占位符。</li>
<li class="lvl-5"><strong>简化功能</strong>：减少服务的复杂度，只提供最基本的功能。</li>
<li class="lvl-5"><strong>限流降级</strong>：通过限制请求速率来防止系统过载，对超过限制的请求进行降级处理。</li>
<li class="lvl-5"><strong>熔断机制</strong>：当服务调用失败率达到一定阈值时，暂时熔断对该服务的调用，转而执行降级逻辑。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>服务降级的作用</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>保证系统稳定性</strong>：通过降级非核心服务，防止系统因部分服务故障而全面崩溃。</li>
<li class="lvl-5"><strong>提升用户体验</strong>：即使在高负载或服务故障情况下，也能保证核心功能的可用性，提升用户体验。</li>
<li class="lvl-5"><strong>资源优化</strong>：合理分配系统资源，保证关键服务的性能和响应速度。</li>
</ul>
</li>
</ol>
<p>服务降级是微服务架构中常用的一种容错策略，通过合理的服务降级策略，可以提高系统的稳定性和可靠性，确保在各种情况下都能提供良好的服务。</p>
<h2 id="synchronized-和-reentrantlock-有什么区别"><a class="markdownIt-Anchor" href="#synchronized-和-reentrantlock-有什么区别"></a> Synchronized 和 ReentrantLock 有什么区别？</h2>
<p>Synchronized 和 ReentrantLock 的区别</p>
<ol>
<li class="lvl-3">
<p><strong>锁的获取和释放方式</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>Synchronized</strong>：是Java中的内置关键字，用于同步代码块或方法。锁的获取和释放是自动的，当进入同步代码块时自动获取锁，当退出代码块或发生异常时自动释放锁。</p>
</li>
<li class="lvl-5">
<p><strong>ReentrantLock</strong>：是Java并发包中的一个类，需要显式地调用<code>lock()</code>方法来获取锁，调用<code>unlock()</code>方法来释放锁。这种方式更加灵活，但需要程序员手动管理锁的生命周期。</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>锁的类型</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>Synchronized</strong>：只能实现不可中断的独占锁，即一旦一个线程获取了锁，其他线程必须等待直到锁被释放。</p>
</li>
<li class="lvl-5">
<p><strong>ReentrantLock</strong>：可以实现可中断的独占锁，也可以实现共享锁（读写锁）。此外，ReentrantLock还支持公平锁和非公平锁的选择。</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>性能</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>Synchronized</strong>：在Java 6及以后的版本中，经过多次优化，性能已经非常接近ReentrantLock，但在某些特定场景下，ReentrantLock可能略优于Synchronized。</p>
</li>
<li class="lvl-5">
<p><strong>ReentrantLock</strong>：提供了更多的锁获取和释放的选项，可以根据具体需求进行优化，但在大多数情况下，性能与Synchronized相当。</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>功能扩展性</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>Synchronized</strong>：功能相对简单，只能实现基本的同步功能。</p>
</li>
<li class="lvl-5">
<p><strong>ReentrantLock</strong>：提供了更多的功能扩展，如尝试获取锁（<code>tryLock()</code>）、定时获取锁（<code>tryLock(long time, TimeUnit unit)</code>）、锁的新重入特性等。</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>死锁检测</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>Synchronized</strong>：不支持死锁检测。</p>
</li>
<li class="lvl-5">
<p><strong>ReentrantLock</strong>：可以通过<code>getHoldCount()</code>和<code>getQueueLength()</code>等方法进行死锁检测。</p>
</li>
</ul>
</li>
</ol>
<p>总结来说，Synchronized是Java中内置的同步机制，使用简单但功能有限；而ReentrantLock提供了更多的功能和灵活性，但需要程序员手动管理锁的生命周期。在实际应用中，可以根据具体需求选择合适的同步机制。</p>
<h2 id="redis-的-lua-脚本功能是什么如何使用"><a class="markdownIt-Anchor" href="#redis-的-lua-脚本功能是什么如何使用"></a> Redis 的 Lua 脚本功能是什么？如何使用？</h2>
<p>Redis 的 Lua 脚本功能及其使用方法</p>
<ol>
<li class="lvl-3">
<p><strong>什么是 Redis 的 Lua 脚本功能？</strong></p>
<p>Redis 的 Lua 脚本功能允许用户在 Redis 服务器端执行 Lua 脚本，从而实现一系列原子性的操作。Lua 是一种轻量级的脚本语言，嵌入到 Redis 中，提供了比单纯 Redis 命令更复杂的逻辑处理能力。</p>
</li>
<li class="lvl-3">
<p><strong>Lua 脚本的功能优势</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>原子性</strong>：Lua 脚本在 Redis 中的执行是原子性的，确保脚本中的所有命令要么全部执行成功，要么全部不执行，从而保证数据的一致性。</li>
<li class="lvl-5"><strong>事务性</strong>：脚本执行过程中自动开启事务，无需额外的事务支持。</li>
<li class="lvl-5"><strong>复杂逻辑处理</strong>：可以通过 Lua 脚本实现复杂的业务逻辑，利用 Lua 的强大功能进行数据处理和操作。</li>
<li class="lvl-5"><strong>缓存机制</strong>：经常执行的 Lua 脚本会被 Redis 缓存，提高执行效率。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>如何使用 Lua 脚本</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>EVAL 命令</strong>：使用 <code>EVAL</code> 命令执行 Lua 脚本。命令格式如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure>
<ul class="lvl-4">
<li class="lvl-7">
<p><code>script</code>：要执行的 Lua 脚本字符串。</p>
</li>
<li class="lvl-7">
<p><code>numkeys</code>：后续键的数量。</p>
</li>
<li class="lvl-7">
<p><code>key</code>：脚本中使用的键，通过 <code>KEYS[1]</code>, <code>KEYS[2]</code> 等访问。</p>
</li>
<li class="lvl-7">
<p><code>arg</code>：传递给脚本的参数，通过 <code>ARGV[1]</code>, <code>ARGV[2]</code> 等访问。</p>
</li>
</ul>
</li>
<li class="lvl-5">
<p><strong>脚本编写</strong>：在 Lua 脚本中使用 <code>redis.call</code> 或 <code>redis.pcall</code> 执行 Redis 命令。<code>redis.call</code> 在遇到错误时会中止脚本执行，而 <code>redis.pcall</code> 则会捕获错误并继续执行。</p>
</li>
<li class="lvl-5">
<p><strong>示例</strong>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 示例 Lua 脚本：将键 key1 的值增加 value，如果 key1 不存在，则设置为 value</span></span><br><span class="line"><span class="keyword">local</span> current = redis.call(<span class="string">&quot;GET&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> current <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;INCRBY&quot;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;SET&quot;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>执行该脚本的 Redis 命令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;local current = redis.call(&#x27;GET&#x27;, KEYS[1]); if current then return redis.call(&#x27;INCRBY&#x27;, KEYS[1], ARGV[1]); else return redis.call(&#x27;SET&#x27;, KEYS[1], ARGV[1]); end&quot; 1 key1 10</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>注意事项</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>原子性和事务性</strong>：Lua 脚本确保原子性执行，但需注意避免死锁和长时间阻塞。</li>
<li class="lvl-5"><strong>性能优化</strong>：保持脚本简洁，减少 <code>redis.call</code> 的次数，优化算法以提高执行效率。</li>
<li class="lvl-5"><strong>安全性</strong>：避免注入攻击，确保脚本参数的安全性。</li>
<li class="lvl-5"><strong>调试</strong>：使用 <code>redis.log</code> 记录调试信息，便于脚本的调试和维护。</li>
</ul>
</li>
</ol>
<p>总结来说，Redis 的 Lua 脚本功能提供了强大的服务器端脚本执行能力，允许用户实现复杂且原子性的操作，大大增强了 Redis 的功能性和灵活性。在使用时，需注意脚本的正确性、性能和安全性，遵循最佳实践，以编写高效、可靠的脚本。</p>
<h2 id="http-20-和-30-有什么区别"><a class="markdownIt-Anchor" href="#http-20-和-30-有什么区别"></a> HTTP 2.0 和 3.0 有什么区别？</h2>
<p>HTTP/2.0 与 HTTP/3.0 的主要区别</p>
<ol>
<li class="lvl-3">
<p><strong>传输层协议</strong></p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>HTTP/2.0</strong>：基于 TCP 协议。TCP 是一种可靠的、面向连接的传输协议，但存在头阻塞（head-of-line blocking）问题，且在高延迟或丢包环境下性能较差。</p>
</li>
<li class="lvl-2">
<p><strong>HTTP/3.0</strong>：基于 QUIC（Quick UDP Internet Connections）协议。QUIC 是一种基于 UDP 的协议，旨在提供比 TCP 更快的连接建立和更高效的错误恢复机制，减少了延迟和丢包对性能的影响。</p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p><strong>多路复用</strong></p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>HTTP/2.0</strong>：支持多路复用，即在单个 TCP 连接上可以同时传输多个请求和响应，但仍然存在头阻塞问题。</p>
</li>
<li class="lvl-2">
<p><strong>HTTP/3.0</strong>：也支持多路复用，但由于基于 QUIC，每个流都是独立的，避免了头阻塞问题，提高了并发性能。</p>
</li>
</ul>
<ol start="3">
<li class="lvl-3">
<p><strong>安全性</strong></p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>HTTP/2.0</strong>：推荐使用 TLS（Transport Layer Security）加密，但不是强制要求。</p>
</li>
<li class="lvl-2">
<p><strong>HTTP/3.0</strong>：强制要求使用 TLS 1.3 或更高版本，确保了连接的安全性。</p>
</li>
</ul>
<ol start="4">
<li class="lvl-3">
<p><strong>错误恢复</strong></p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>HTTP/2.0</strong>：依赖于 TCP 的重传机制，对丢包敏感，恢复速度较慢。</p>
</li>
<li class="lvl-2">
<p><strong>HTTP/3.0</strong>：QUIC 具有内置的前向错误纠正（FEC）和快速重传机制，能够更快地恢复丢包，减少重传延迟。</p>
</li>
</ul>
<ol start="5">
<li class="lvl-3">
<p><strong>连接迁移</strong></p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>HTTP/2.0</strong>：不支持连接迁移，当网络环境变化时，需要重新建立连接。</p>
</li>
<li class="lvl-2">
<p><strong>HTTP/3.0</strong>：QUIC 支持连接迁移，当设备从一个网络切换到另一个网络时，可以保持连接不断开，提高了用户体验。</p>
</li>
</ul>
<ol start="6">
<li class="lvl-3">
<p><strong>头部压缩</strong></p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>HTTP/2.0</strong>：使用 HPACK 算法压缩 HTTP 头部，减少了传输数据量。</p>
</li>
<li class="lvl-2">
<p><strong>HTTP/3.0</strong>：同样使用 HPACK 算法压缩头部，但在 QUIC 的基础上，进一步优化了头部的传输效率。</p>
</li>
</ul>
<ol start="7">
<li class="lvl-3">
<p><strong>发展和采用</strong></p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>HTTP/2.0</strong>：已经广泛部署和采用，大多数现代浏览器和服务器都支持 HTTP/2.0。</p>
</li>
<li class="lvl-2">
<p><strong>HTTP/3.0</strong>：仍在发展和推广阶段，但已经得到一些现代浏览器和服务器的支持，预计未来会逐渐普及。</p>
</li>
</ul>
<p>总结来说，HTTP/3.0 在传输层协议、错误恢复、连接迁移等方面对 HTTP/2.0 进行了改进，旨在提供更快、更可靠、更安全的网络传输体验。随着技术的发展和标准的推进，HTTP/3.0 有望成为未来网络通信的主流协议。</p>
<h2 id="单例模式有哪几种实现如何保证线程安全"><a class="markdownIt-Anchor" href="#单例模式有哪几种实现如何保证线程安全"></a> 单例模式有哪几种实现？如何保证线程安全？</h2>
<p>单例模式是一种设计模式，确保一个类只有一个实例，并提供一个全局访问点。单例模式有几种不同的实现方式，以下是其中几种常见的实现方法，以及如何保证线程安全：</p>
<ol>
<li class="lvl-3">
<p><strong>懒汉式（Lazy Initialization）</strong><br />
懒汉式单例模式的特点是在第一次使用时才创建实例。这种实现方式分为线程不安全和线程安全两种。</p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>线程不安全的懒汉式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种实现方式在多线程环境下不安全，因为多个线程可能同时进入 <code>if (instance == null)</code> 条件，导致创建多个实例。</p>
</li>
<li class="lvl-5">
<p><strong>线程安全的懒汉式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在 <code>getInstance</code> 方法上添加 <code>synchronized</code> 关键字，确保同一时间只有一个线程可以执行该方法，从而保证线程安全。但是，这种方式会降低性能，因为每次调用 <code>getInstance</code> 方法都会进行同步检查。</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>饿汉式（Eager Initialization）</strong><br />
饿汉式单例模式的特点是在类加载时就创建实例，确保线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种实现方式是线程安全的，因为实例在类加载时就已经创建，不需要额外的同步机制。但是，如果实例的创建成本很高，或者在某些情况下不需要使用该实例，这种实现方式可能会浪费资源。</p>
</li>
<li class="lvl-3">
<p><strong>双重检查锁定（Double-Checked Locking）</strong><br />
双重检查锁定是一种优化的懒汉式实现方式，旨在减少同步的开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在 <code>getInstance</code> 方法中添加双重检查，只有在 <code>instance</code> 为 <code>null</code> 时才进行同步，从而减少了同步的开销。<code>volatile</code> 关键字确保了实例的可见性，防止指令重排序。</p>
</li>
<li class="lvl-3">
<p><strong>静态内部类（Static Inner Class）</strong><br />
静态内部类是一种延迟加载且线程安全的实现方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态内部类在外部类被加载时不会被加载，只有当调用 <code>getInstance</code> 方法时，才会加载静态内部类并创建实例。这种方式是线程安全的，因为类加载器保证了静态内部类的初始化过程是线程安全的。</p>
</li>
<li class="lvl-3">
<p><strong>枚举（Enum）</strong><br />
枚举是一种简单且线程安全的实现方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 可以在这里添加其他方法或状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类型的实例在类加载时创建，确保了线程安全。此外，枚举还防止了反射和反序列化攻击，是一种推荐的单例实现方式。</p>
</li>
</ol>
<p>总结来说，单例模式有多种实现方式，每种方式都有其优缺点。在选择实现方式时，需要根据具体的需求和场景来决定。为了保证线程安全，可以使用同步机制、<code>volatile</code> 关键字、静态内部类或枚举等方式。</p>
<h2 id="java-的-synchronized-是怎么实现的"><a class="markdownIt-Anchor" href="#java-的-synchronized-是怎么实现的"></a> Java 的 synchronized 是怎么实现的？</h2>
<p>Java中的<code>synchronized</code>关键字用于实现线程同步，它通过使用对象的监视器（monitor）来控制对共享资源的访问。监视器是一种同步机制，每个Java对象都有一个与之关联的监视器。当一个线程想要执行一个<code>synchronized</code>方法或代码块时，它必须首先获得该对象的监视器。</p>
<p><code>synchronized</code>关键字可以应用于实例方法、静态方法或代码块。当应用于实例方法时，监视器是该实例对象；当应用于静态方法时，监视器是该类的Class对象；当应用于代码块时，监视器是代码块中指定的对象。</p>
<p>以下是<code>synchronized</code>关键字的几种使用方式：</p>
<ol>
<li class="lvl-3">
<p><strong>同步方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synchronizedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>synchronized</code>关键字修饰的是方法，表示该方法是同步的。任何线程在执行这个方法之前，必须先获得该对象的监视器。</p>
</li>
<li class="lvl-3">
<p><strong>同步静态方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synchronizedStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>synchronized</code>关键字修饰的是静态方法，表示该方法是同步的。任何线程在执行这个静态方法之前，必须先获得该类的Class对象的监视器。</p>
</li>
<li class="lvl-3">
<p><strong>同步代码块</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>synchronized</code>关键字修饰的是一个代码块，表示该代码块是同步的。任何线程在执行这个代码块之前，必须先获得<code>this</code>对象的监视器。</p>
</li>
</ol>
<p><code>synchronized</code>的实现涉及到操作系统的互斥量（mutex）或类似的同步原语。当一个线程尝试获取一个已经被其他线程持有的监视器时，它会被阻塞，直到持有监视器的线程释放它。释放监视器通常发生在方法执行完毕、代码块结束或遇到<code>return</code>语句时。</p>
<p><code>synchronized</code>的性能开销相对较高，因为它涉及到操作系统级别的互斥操作。因此，在性能敏感的应用中，应该谨慎使用<code>synchronized</code>，并考虑使用其他同步机制，如<code>ReentrantLock</code>或其他并发工具类。</p>
<h2 id="如何设计一个秒杀功能"><a class="markdownIt-Anchor" href="#如何设计一个秒杀功能"></a> 如何设计一个秒杀功能？</h2>
<p>设计一个秒杀功能需要考虑多个方面，包括高并发处理、公平性、性能优化、数据库设计等。以下是一个基本的秒杀功能设计思路：</p>
<ol>
<li class="lvl-3">
<p><strong>需求分析</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">确定秒杀的商品、秒杀时间、库存数量。</li>
<li class="lvl-5">确定是否需要用户登录、是否需要验证用户资格。</li>
<li class="lvl-5">确定秒杀成功的处理流程，如扣减库存、生成订单、发送通知等。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>系统架构设计</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">前端页面：展示秒杀商品信息，提供秒杀入口。</li>
<li class="lvl-5">后端服务：处理秒杀请求，包括验证用户资格、扣减库存、生成订单等。</li>
<li class="lvl-5">数据库：存储商品信息、库存、订单等数据。</li>
<li class="lvl-5">缓存：用于缓存热点数据，如商品信息、库存等，减少数据库压力。</li>
<li class="lvl-5">消息队列：用于异步处理秒杀成功的订单，提高系统吞吐量。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>技术选型</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">前端：HTML、CSS、JavaScript等。</li>
<li class="lvl-5">后端：Java、Spring Boot、MyBatis等。</li>
<li class="lvl-5">数据库：MySQL、Redis等。</li>
<li class="lvl-5">消息队列：RabbitMQ、Kafka等。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>代码实现</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">前端页面：展示秒杀商品信息，提供秒杀入口。</li>
<li class="lvl-5">后端服务：
<ul class="lvl-4">
<li class="lvl-7">用户验证：检查用户是否登录、是否有资格参与秒杀。</li>
<li class="lvl-7">库存检查：从缓存中获取商品库存，如果库存不足，直接返回失败。</li>
<li class="lvl-7">库存扣减：使用数据库的乐观锁或悲观锁机制扣减库存。</li>
<li class="lvl-7">订单生成：生成订单，记录秒杀成功的信息。</li>
<li class="lvl-7">发送通知：通过消息队列异步发送秒杀成功的通知。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>性能优化</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">使用缓存：缓存热点数据，减少数据库压力。</li>
<li class="lvl-5">使用消息队列：异步处理秒杀成功的订单，提高系统吞吐量。</li>
<li class="lvl-5">数据库优化：优化数据库表结构、索引等，提高查询和更新效率。</li>
<li class="lvl-5">系统扩容：根据预期的并发量，提前做好系统扩容准备。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>测试与部署</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">单元测试：对各个模块进行单元测试，确保代码的正确性。</li>
<li class="lvl-5">压力测试：模拟高并发场景，测试系统的性能和稳定性。</li>
<li class="lvl-5">部署上线：将系统部署到生产环境，进行灰度发布或全量发布。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>监控与运维</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">监控系统：实时监控系统的运行状态、性能指标等。</li>
<li class="lvl-5">日志管理：记录系统的运行日志，方便故障排查和分析。</li>
<li class="lvl-5">运维支持：提供运维支持，确保系统的稳定运行。</li>
</ul>
</li>
</ol>
<p>设计一个秒杀功能需要综合考虑多个方面，确保系统的高并发处理能力、公平性、性能优化等。同时，还需要进行充分的测试和监控，确保系统的稳定运行。</p>
<h2 id="为什么不选择使用原生的-nio-而选择使用-netty-呢"><a class="markdownIt-Anchor" href="#为什么不选择使用原生的-nio-而选择使用-netty-呢"></a> 为什么不选择使用原生的 NIO 而选择使用 Netty 呢？</h2>
<p>选择使用 Netty 而不是原生的 NIO（Non-Blocking I/O）主要有以下几个原因：</p>
<ol>
<li class="lvl-3">
<p><strong>简化开发</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">Netty 是一个基于 NIO 的客户端-服务器框架，它简化了网络应用的开发过程。Netty 提供了丰富的功能和工具，使得开发者可以专注于业务逻辑，而不必深入理解 NIO 的复杂性。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>性能优化</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">Netty 在性能上进行了大量的优化，包括内存管理、线程模型、缓冲区管理等方面。这些优化使得 Netty 在处理高并发和大数据量时表现得更加高效。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>丰富的特性</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">Netty 提供了许多开箱即用的特性，如心跳检测、连接管理、流量控制、协议支持（如 HTTP、WebSocket、TCP 等）等。这些特性使得 Netty 成为构建复杂网络应用的理想选择。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>社区支持和生态系统</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">Netty 拥有一个活跃的社区和丰富的生态系统。这意味着开发者可以轻松找到各种扩展和插件，也可以在遇到问题时获得及时的帮助和支持。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>稳定性和可靠性</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">Netty 经过了长时间的开发和测试，具有很高的稳定性和可靠性。它在处理各种异常情况和边缘案例时表现得非常 robust。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>易于集成</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">Netty 可以很容易地与其他框架和库集成，如 Spring、Netty、Akka 等。这使得开发者可以利用现有的技术栈来构建新的应用。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>线程模型</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">Netty 使用了一种称为 “EventLoop” 的线程模型，它允许多个 I/O 操作在同一个线程中执行，从而减少了线程切换的开销。这种模型在处理高并发时非常有效。</li>
</ul>
</li>
</ol>
<p>总之，虽然原生的 NIO 提供了底层的网络编程能力，但 Netty 通过提供更高层次的抽象和优化，使得网络应用的开发变得更加简单、高效和可靠。在设计秒杀功能时，选择 Netty 可以帮助开发者更好地应对高并发和复杂的需求。</p>
<h2 id="看过源码吗说下-spring-由哪些重要的模块组成"><a class="markdownIt-Anchor" href="#看过源码吗说下-spring-由哪些重要的模块组成"></a> 看过源码吗？说下 Spring 由哪些重要的模块组成？</h2>
<p>是的，Spring 框架是一个非常流行的 Java 开发框架，它由多个模块组成，每个模块都专注于特定的功能领域。以下是 Spring 框架中一些重要的模块：</p>
<ol>
<li class="lvl-3">
<p><strong>Spring Core</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">这是 Spring 框架的基础模块，提供了 IoC（控制反转）和 Dependency Injection（依赖注入）的核心功能。它还包括一些基本的 utility 类，如 BeanFactory。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Spring Context</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">Spring Context 模块构建在 Spring Core 之上，提供了 ApplicationContext，这是一个更高级的 BeanFactory，提供了国际化、事件传播、资源加载和上下文 awareness 的支持。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Spring AOP</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">Spring AOP 模块提供了面向切面编程的支持，允许开发者在不修改现有代码的情况下，向应用程序添加新的功能。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Spring JDBC</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">Spring JDBC 模块简化了 JDBC 的使用，提供了异常处理和数据访问对象（DAO）的支持，减少了数据库访问代码的样板。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Spring ORM</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">Spring ORM 模块提供了对各种对象关系映射（ORM）框架的支持，如 Hibernate、JPA 和 iBatis。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Spring Web</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">Spring Web 模块提供了对基于 Servlet 的 Web 应用程序的支持，包括处理 HTTP 请求和响应的工具。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Spring MVC</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">Spring MVC 是一个基于 Model-View-Controller（MVC）模式的 Web 框架，提供了处理 Web 请求的控制器、视图解析器和其他相关组件。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Spring Test</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">Spring Test 模块提供了测试 Spring 应用程序的工具，包括测试上下文、事务管理、 mocking 和 stubbing 的支持。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Spring Security</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">Spring Security 是一个用于构建安全性的框架，提供了认证、授权、密码编码、会话管理和其他安全相关功能。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>Spring Boot</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">Spring Boot 是一个用于简化 Spring 应用程序开发的框架，它提供了自动配置、起步依赖和命令行工具，使得开发者可以快速构建独立的、生产级别的 Spring 应用程序。</li>
</ul>
</li>
</ol>
<p>这些模块可以单独使用，也可以组合使用，以满足不同应用程序的需求。Spring 框架的模块化设计使得开发者可以根据需要选择合适的模块来构建应用程序。</p>
<h2 id="如何优化-java-中的锁的使用"><a class="markdownIt-Anchor" href="#如何优化-java-中的锁的使用"></a> 如何优化 Java 中的锁的使用？</h2>
<p>在 Java 中优化锁的使用对于提升应用程序的并发性和性能至关重要。以下是一系列优化策略的总结：</p>
<ol>
<li class="lvl-3">
<p><strong>减少锁的粒度</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>做法</strong>：缩小同步代码块的范围，仅对真正需要同步的代码进行锁定。</li>
<li class="lvl-5"><strong>好处</strong>：减少线程阻塞的时间，提高并发性。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>使用读写锁</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>做法</strong>：采用 <code>ReentrantReadWriteLock</code>，允许多个读取者同时访问共享资源，写入者独占访问。</li>
<li class="lvl-5"><strong>好处</strong>：在读操作远多于写操作的场景中，显著提高并发性。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>锁的细分技术</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>做法</strong>：将共享资源分割成多个段，每个段由独立的锁保护。</li>
<li class="lvl-5"><strong>好处</strong>：增加并发访问的能力，减少锁竞争。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>使用非阻塞同步机制</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>做法</strong>：利用 <code>ReentrantLock</code> 的 <code>tryLock</code> 方法尝试非阻塞地获取锁。</li>
<li class="lvl-5"><strong>好处</strong>：避免线程不必要的阻塞，减少等待时间。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>锁的超时机制</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>做法</strong>：使用 <code>tryLock(long time, TimeUnit unit)</code> 方法，设置锁的等待超时时间。</li>
<li class="lvl-5"><strong>好处</strong>：防止线程无限期等待锁，避免死锁的发生。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>使用并发集合类</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>做法</strong>：采用 <code>ConcurrentHashMap</code> 等并发集合类，减少显式锁的使用。</li>
<li class="lvl-5"><strong>好处</strong>：内置并发支持，简化同步逻辑。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>使用原子类</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>做法</strong>：利用 <code>AtomicInteger</code>、<code>AtomicLong</code> 等原子类进行原子操作。</li>
<li class="lvl-5"><strong>好处</strong>：避免锁的开销，提高性能。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>使用 <code>volatile</code> 关键字</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>做法</strong>：对变量使用 <code>volatile</code> 关键字，确保变量的可见性。</li>
<li class="lvl-5"><strong>好处</strong>：在某些场景下替代锁，简化同步机制。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>性能分析和 Profiling</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>做法</strong>：使用性能分析工具识别并发热点和性能瓶颈。</li>
<li class="lvl-5"><strong>好处</strong>：针对性地优化锁的使用，提升整体性能。</li>
</ul>
</li>
<li class="lvl-4">
<p><strong>代码 Review 和测试</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><strong>做法</strong>：进行代码审查和充分的并发测试，确保锁的正确使用。</li>
<li class="lvl-6"><strong>好处</strong>：避免死锁、活锁等并发问题，保证代码的正确性和稳定性。</li>
</ul>
</li>
</ol>
<p>通过综合运用上述策略，可以有效地优化 Java 中的锁的使用，提高应用程序的并发性和性能。</p>
<p><strong>通过减少锁的粒度、使用读写锁、锁的细分技术、非阻塞同步机制、锁的超时机制、并发集合类、原子类、volatile关键字、性能分析以及代码 review 和测试等策略，可以有效地优化 Java 中的锁的使用，提高应用程序的并发性和性能。</strong></p>
<h2 id="redis-的-pipeline-功能是什么"><a class="markdownIt-Anchor" href="#redis-的-pipeline-功能是什么"></a> Redis 的 Pipeline 功能是什么？</h2>
<p>Redis 的 Pipeline（管道）功能是一种优化技术，用于减少客户端与服务器之间的网络往返次数，从而提高数据传输效率。当客户端需要执行多个独立的命令时，可以通过 Pipeline 将这些命令批量发送给服务器，服务器处理完所有命令后一次性返回所有结果。</p>
<p><strong>Pipeline 的工作原理如下：</strong></p>
<ol>
<li class="lvl-3">
<p><strong>批量发送命令</strong>：客户端将多个命令依次写入一个缓冲区，然后一次性将这些命令发送给 Redis 服务器。</p>
</li>
<li class="lvl-3">
<p><strong>服务器处理命令</strong>：Redis 服务器接收到所有命令后，依次执行这些命令，并将每个命令的结果存储在响应缓冲区中。</p>
</li>
<li class="lvl-3">
<p><strong>一次性返回结果</strong>：所有命令执行完毕后，Redis 服务器一次性将所有结果发送回客户端。</p>
</li>
</ol>
<p><strong>Pipeline 的优势包括：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>减少网络延迟</strong>：通过批量发送和接收数据，减少了多次网络往返带来的延迟。</p>
</li>
<li class="lvl-2">
<p><strong>提高吞吐量</strong>：批量处理命令可以更高效地利用网络带宽，提高数据传输的吞吐量。</p>
</li>
<li class="lvl-2">
<p><strong>简化并发控制</strong>：Pipeline 可以在一定程度上简化并发控制，因为所有命令都是按顺序执行的。</p>
</li>
</ul>
<p><strong>使用 Pipeline 的注意事项：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>命令顺序</strong>：Pipeline 中的命令执行顺序是固定的，不能动态改变。</p>
</li>
<li class="lvl-2">
<p><strong>错误处理</strong>：如果 Pipeline 中的某个命令执行失败，后续命令仍然会执行，但错误信息会在响应中体现。</p>
</li>
<li class="lvl-2">
<p><strong>事务支持</strong>：Pipeline 本身不提供事务支持，但如果结合 MULTI/EXEC 命令，可以实现原子性操作。</p>
</li>
</ul>
<p><strong>示例代码（使用 Jedis 客户端）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisPipelineExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        jedis.flushAll(); <span class="comment">// 清空所有数据</span></span><br><span class="line">        <span class="comment">// 开始 Pipeline</span></span><br><span class="line">        jedis.multi();</span><br><span class="line">        jedis.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        jedis.set(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        jedis.set(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行 Pipeline</span></span><br><span class="line">        jedis.exec();</span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value1</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">value2</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;key2&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">value3</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;key3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;key1: &quot;</span> + value1);</span><br><span class="line">        System.out.println(<span class="string">&quot;key2: &quot;</span> + value2);</span><br><span class="line">        System.out.println(<span class="string">&quot;key3: &quot;</span> + value3);</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用 Pipeline，可以显著提升 Redis 客户端与服务器之间的通信效率，特别是在需要执行大量独立命令的场景下。</p>
<h2 id="让你设计一个分布式-id-发号器怎么设计"><a class="markdownIt-Anchor" href="#让你设计一个分布式-id-发号器怎么设计"></a> 让你设计一个分布式 ID 发号器，怎么设计？</h2>
<p>设计一个分布式ID发号器需要确保ID的全局唯一性、高并发性能、有序性以及系统的可扩展性和可靠性。以下是基于Snowflake算法的设计方案：</p>
<h3 id="1-设计目标"><a class="markdownIt-Anchor" href="#1-设计目标"></a> 1. 设计目标</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>全局唯一性</strong>：确保在分布式系统中生成的ID不会冲突。</p>
</li>
<li class="lvl-2">
<p><strong>高并发性能</strong>：支持每毫秒生成多个ID，满足高并发需求。</p>
</li>
<li class="lvl-2">
<p><strong>有序性</strong>：ID大致有序，便于范围查询和排序。</p>
</li>
<li class="lvl-2">
<p><strong>可扩展性</strong>：易于添加或减少节点，适应系统扩展。</p>
</li>
<li class="lvl-2">
<p><strong>可靠性</strong>：避免单点故障，确保系统稳定性。</p>
</li>
</ul>
<h3 id="2-设计原理"><a class="markdownIt-Anchor" href="#2-设计原理"></a> 2. 设计原理</h3>
<p>采用Snowflake算法生成64位长整型ID，结构分为以下部分：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>符号位</strong>：1位，固定为0。</p>
</li>
<li class="lvl-2">
<p><strong>时间戳</strong>：41位，表示毫秒级时间偏移量。</p>
</li>
<li class="lvl-2">
<p><strong>节点ID</strong>：10位，包括数据中心ID和机器ID。</p>
</li>
<li class="lvl-2">
<p><strong>序列号</strong>：12位，同一毫秒内的ID增量。</p>
</li>
</ul>
<h3 id="3-设计实现"><a class="markdownIt-Anchor" href="#3-设计实现"></a> 3. 设计实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DistributedIDGenerator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data_center_id, machine_id</span>):</span><br><span class="line">        <span class="comment"># 配置参数</span></span><br><span class="line">        self.data_center_id = data_center_id</span><br><span class="line">        self.machine_id = machine_id</span><br><span class="line">        self.sequence = <span class="number">0</span></span><br><span class="line">        self.last_timestamp = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># Snowflake算法常量</span></span><br><span class="line">        self.twepoch = <span class="number">1288834974657</span>  <span class="comment"># Twitter epoch时间</span></span><br><span class="line">        self.timestamp_left_shift = <span class="number">22</span></span><br><span class="line">        self.data_center_id_shift = <span class="number">17</span></span><br><span class="line">        self.machine_id_shift = <span class="number">12</span></span><br><span class="line">        self.sequence_mask = <span class="number">4095</span>  <span class="comment"># 12位序列号的掩码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_generate_timestamp</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;生成当前毫秒级时间戳&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_til_next_millis</span>(<span class="params">self, last_timestamp</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;等待时间戳更新&quot;&quot;&quot;</span></span><br><span class="line">        timestamp = self._generate_timestamp()</span><br><span class="line">        <span class="keyword">while</span> timestamp &lt;= last_timestamp:</span><br><span class="line">            timestamp = self._generate_timestamp()</span><br><span class="line">        <span class="keyword">return</span> timestamp</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next_id</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;生成下一个ID&quot;&quot;&quot;</span></span><br><span class="line">        timestamp = self._generate_timestamp()</span><br><span class="line">        <span class="comment"># 检查时间回拨</span></span><br><span class="line">        <span class="keyword">if</span> timestamp &lt; self.last_timestamp:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;Clock moved backwards. Refusing to generate ID&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> timestamp == self.last_timestamp:</span><br><span class="line">            self.sequence = (self.sequence + <span class="number">1</span>) &amp; self.sequence_mask</span><br><span class="line">            <span class="keyword">if</span> self.sequence == <span class="number">0</span>:</span><br><span class="line">                timestamp = self._til_next_millis(self.last_timestamp)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.sequence = <span class="number">0</span></span><br><span class="line">        self.last_timestamp = timestamp</span><br><span class="line">        <span class="comment"># 组装ID</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            ((timestamp - self.twepoch) &lt;&lt; self.timestamp_left_shift) |</span><br><span class="line">            (self.data_center_id &lt;&lt; self.data_center_id_shift) |</span><br><span class="line">            (self.machine_id &lt;&lt; self.machine_id_shift) |</span><br><span class="line">            self.sequence</span><br><span class="line">        )</span><br><span class="line"><span class="comment"># 示例使用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    generator = DistributedIDGenerator(data_center_id=<span class="number">1</span>, machine_id=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(generator.next_id())</span><br></pre></td></tr></table></figure>
<h3 id="4-优化与扩展"><a class="markdownIt-Anchor" href="#4-优化与扩展"></a> 4. 优化与扩展</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>时间戳回拨检测</strong>：在生成ID前检测系统时间是否回拨，确保时间单调递增。</p>
</li>
<li class="lvl-2">
<p><strong>动态节点ID分配</strong>：使用分布式配置中心动态分配数据中心ID和机器ID，提高系统的灵活性。</p>
</li>
<li class="lvl-2">
<p><strong>多数据中心支持</strong>：扩展算法以支持多个数据中心，每个数据中心分配独立的节点ID范围。</p>
</li>
<li class="lvl-2">
<p><strong>故障转移</strong>：实现节点故障转移机制，确保ID生成的连续性和可用性。</p>
</li>
</ul>
<h3 id="5-总结"><a class="markdownIt-Anchor" href="#5-总结"></a> 5. 总结</h3>
<p>该分布式ID发号器基于Snowflake算法，通过合理分配节点ID和序列号，确保生成ID的全局唯一性和有序性。同时，通过检测时间回拨和动态分配节点ID等优化措施，提高了系统的可靠性和可扩展性。</p>
<h2 id="什么是服务雪崩"><a class="markdownIt-Anchor" href="#什么是服务雪崩"></a> 什么是服务雪崩？</h2>
<p>服务雪崩的定义</p>
<p>服务雪崩是指在微服务架构或分布式系统中，一个服务因为过载、故障或其他原因无法正常响应时，导致依赖该服务的其他服务不断重试请求，进而消耗大量资源，造成这些服务也变得缓慢或不可用。这种故障会像雪崩一样迅速蔓延，最终导致整个系统性能严重下降或完全崩溃。</p>
<p><strong>服务雪崩是指在微服务架构或分布式系统中，一个服务因为过载、故障或其他原因无法正常响应时，导致依赖该服务的其他服务不断重试请求，进而消耗大量资源，造成这些服务也变得缓慢或不可用。这种故障会像雪崩一样迅速蔓延，最终导致整个系统性能严重下降或完全崩溃。</strong></p>
<h2 id="jvm-由哪些部分组成"><a class="markdownIt-Anchor" href="#jvm-由哪些部分组成"></a> JVM 由哪些部分组成？</h2>
<p>Java 虚拟机（JVM）是 Java 程序运行的平台，其内部结构由以下几个主要部分组成：</p>
<ol>
<li class="lvl-3">
<p><strong>类加载器系统</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>功能</strong>：负责加载、链接和初始化类文件。</li>
<li class="lvl-5"><strong>子组件</strong>：
<ul class="lvl-4">
<li class="lvl-7"><strong>类加载器</strong>：加载类文件。</li>
<li class="lvl-7"><strong>链接器</strong>：验证、准备和解析类文件。</li>
<li class="lvl-7"><strong>初始化器</strong>：初始化类的静态变量和执行静态代码块。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>运行时数据区</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>功能</strong>：存储程序运行时所需的各种数据。</li>
<li class="lvl-5"><strong>子组件</strong>：
<ul class="lvl-4">
<li class="lvl-7"><strong>堆（Heap）</strong>：存储对象实例和数组。</li>
<li class="lvl-7"><strong>方法区（Method Area）</strong>：存储类的结构信息，如常量、字段和方法数据。</li>
<li class="lvl-7"><strong>虚拟机栈（Java Virtual Machine Stack）</strong>：每个线程有一个虚拟机栈，存储方法调用的栈帧。</li>
<li class="lvl-7"><strong>本地方法栈（Native Method Stack）</strong>：支持本地方法的调用。</li>
<li class="lvl-7"><strong>程序计数器（Program Counter Register）</strong>：指示当前线程执行的字节码指令。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>执行引擎</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>功能</strong>：执行字节码指令。</li>
<li class="lvl-5"><strong>子组件</strong>：
<ul class="lvl-4">
<li class="lvl-7"><strong>字节码解释器</strong>：逐条解释并执行字节码。</li>
<li class="lvl-7"><strong>字节码验证器</strong>：确保字节码的安全性和正确性。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>垃圾回收器（Garbage Collector）</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>功能</strong>：自动回收不再使用的对象，释放内存空间。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Just-In-Time (JIT) 编译器</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>功能</strong>：将热点字节码编译成本地机器代码，提高执行效率。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>本地接口（Native Interface，如 JNI）</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>功能</strong>：允许 Java 代码调用本地（非 Java）代码，实现与外部系统的交互。</li>
</ul>
</li>
</ol>
<p><strong>最终答案</strong><br />
JVM 由类加载器系统、运行时数据区、执行引擎、垃圾回收器、JIT 编译器和本地接口（如 JNI）组成。</p>
<h2 id="redis-通常应用于哪些场景"><a class="markdownIt-Anchor" href="#redis-通常应用于哪些场景"></a> Redis 通常应用于哪些场景？</h2>
<p>Redis 的应用场景</p>
<p>Redis 是一个开源的内存数据结构存储系统，常被用作数据库、缓存和消息中间件。它支持多种数据结构，如字符串、哈希、列表、集合、有序集合、位图、HyperLogLogs 和地理空间索引等。以下是 Redis 通常应用于的一些场景：</p>
<ol>
<li class="lvl-3">
<p><strong>缓存层</strong>：Redis 最常见的用途是作为缓存层，用于存储频繁访问的数据，以减少对后端数据库的读取压力，提高应用的响应速度。</p>
</li>
<li class="lvl-3">
<p><strong>会话存储</strong>：在 Web 应用中，Redis 可以用来存储用户会话数据，确保用户在不同服务器之间切换时，会话信息的一致性和可用性。</p>
</li>
<li class="lvl-3">
<p><strong>消息队列</strong>：Redis 提供了列表数据结构，可以用来实现简单的消息队列，支持发布/订阅模式，适用于异步处理和任务队列。</p>
</li>
<li class="lvl-3">
<p><strong>实时分析</strong>：利用 Redis 的高性能和丰富的数据结构，可以进行实时数据分析和统计，如实时排行榜、在线用户数统计等。</p>
</li>
<li class="lvl-3">
<p><strong>排行榜和计数器</strong>：Redis 的原子操作和高性能使其非常适合实现排行榜和计数器功能，如网站的访问量统计、投票系统等。</p>
</li>
<li class="lvl-3">
<p><strong>分布式锁</strong>：通过 Redis 的原子操作，可以实现分布式锁，确保在分布式系统中对共享资源的互斥访问。</p>
</li>
<li class="lvl-3">
<p><strong>事务处理</strong>：Redis 支持事务，可以用来处理需要原子性的一系列操作，如订单处理、支付流程等。</p>
</li>
<li class="lvl-3">
<p><strong>地理空间应用</strong>：Redis 的地理空间索引功能可以用于地理位置相关的应用，如附近商家查找、轨迹记录等。</p>
</li>
<li class="lvl-3">
<p><strong>全文搜索</strong>：虽然 Redis 本身不提供全文搜索功能，但可以通过结合其他工具（如 Elasticsearch）实现高效的搜索解决方案。</p>
</li>
<li class="lvl-4">
<p><strong>配置管理</strong>：Redis 可以用来存储应用的配置信息，方便动态更新配置而无需重启应用。</p>
</li>
</ol>
<p>Redis 的灵活性和高性能使其在各种场景中都有广泛的应用。根据具体的需求和业务逻辑，可以选择合适的数据结构和功能来优化应用的性能和可扩展性。</p>
<h2 id="让你设计一个短链系统怎么设计"><a class="markdownIt-Anchor" href="#让你设计一个短链系统怎么设计"></a> 让你设计一个短链系统，怎么设计？</h2>
<h3 id="1-问题描述"><a class="markdownIt-Anchor" href="#1-问题描述"></a> 1. 问题描述</h3>
<p>设计一个短链系统，将长的URL转换为短的、易于记忆和分享的链接。</p>
<h3 id="2-系统设计"><a class="markdownIt-Anchor" href="#2-系统设计"></a> 2. 系统设计</h3>
<h4 id="21-功能需求"><a class="markdownIt-Anchor" href="#21-功能需求"></a> 2.1 功能需求</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>URL缩短</strong>：将长URL转换为短URL。</p>
</li>
<li class="lvl-2">
<p><strong>URL重定向</strong>：通过短URL跳转到对应的长URL。</p>
</li>
<li class="lvl-2">
<p><strong>唯一性保证</strong>：确保每个短URL唯一对应一个长URL。</p>
</li>
<li class="lvl-2">
<p><strong>高效存储</strong>：快速存储和检索URL映射关系。</p>
</li>
<li class="lvl-2">
<p><strong>错误处理</strong>：验证URL合法性，处理各种异常情况。</p>
</li>
</ul>
<h4 id="22-技术选型"><a class="markdownIt-Anchor" href="#22-技术选型"></a> 2.2 技术选型</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>ID生成</strong>：使用Snowflake算法生成唯一的64位ID。</p>
</li>
<li class="lvl-2">
<p><strong>编码方案</strong>：将Snowflake ID使用Base62编码转换为短URL，确保短URL长度适中且字符集包含字母和数字。</p>
</li>
<li class="lvl-2">
<p><strong>数据存储</strong>：采用Redis作为键值存储，利用其快速的读写能力存储短URL与长URL的映射关系。</p>
</li>
<li class="lvl-2">
<p><strong>Web服务</strong>：使用Flask框架搭建简单的HTTP服务，提供URL缩短和重定向的接口。</p>
</li>
</ul>
<h3 id="3-实现细节"><a class="markdownIt-Anchor" href="#3-实现细节"></a> 3. 实现细节</h3>
<h4 id="31-snowflake-id生成器"><a class="markdownIt-Anchor" href="#31-snowflake-id生成器"></a> 3.1 Snowflake ID生成器</h4>
<p>Snowflake算法生成唯一的64位ID，包含时间戳、数据中心ID、工作节点ID和序列号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SnowflakeGenerator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data_center_id, worker_id</span>):</span><br><span class="line">        self.data_center_id = data_center_id</span><br><span class="line">        self.worker_id = worker_id</span><br><span class="line">        self.sequence = <span class="number">0</span></span><br><span class="line">        self.last_timestamp = -<span class="number">1</span></span><br><span class="line">        self.lock = threading.Lock()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_id</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            timestamp = <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line">            <span class="keyword">if</span> timestamp &lt; self.last_timestamp:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&quot;Clock moved backwards.&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> timestamp == self.last_timestamp:</span><br><span class="line">                self.sequence = (self.sequence + <span class="number">1</span>) &amp; <span class="number">0xFFF</span></span><br><span class="line">                <span class="keyword">if</span> self.sequence == <span class="number">0</span>:</span><br><span class="line">                    timestamp = self.wait_next_millis(self.last_timestamp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.sequence = <span class="number">0</span></span><br><span class="line">            self.last_timestamp = timestamp</span><br><span class="line">            <span class="keyword">return</span> ((timestamp - <span class="number">1288834974657</span>) &lt;&lt; <span class="number">22</span>) | (self.data_center_id &lt;&lt; <span class="number">17</span>) | (self.worker_id &lt;&lt; <span class="number">12</span>) | self.sequence</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wait_next_millis</span>(<span class="params">self, last_timestamp</span>):</span><br><span class="line">        timestamp = <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">while</span> timestamp &lt;= last_timestamp:</span><br><span class="line">            timestamp = <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">return</span> timestamp</span><br></pre></td></tr></table></figure>
<h4 id="32-base62编码"><a class="markdownIt-Anchor" href="#32-base62编码"></a> 3.2 Base62编码</h4>
<p>将64位的Snowflake ID编码为11位的Base62字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">base62_encode</span>(<span class="params">num</span>):</span><br><span class="line">    alphabet = string.ascii_letters + string.digits</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> alphabet[<span class="number">0</span>]</span><br><span class="line">    arr = []</span><br><span class="line">    base = <span class="built_in">len</span>(alphabet)</span><br><span class="line">    <span class="keyword">while</span> num:</span><br><span class="line">        num, rem = <span class="built_in">divmod</span>(num, base)</span><br><span class="line">        arr.append(alphabet[rem])</span><br><span class="line">    arr.reverse()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(arr)</span><br></pre></td></tr></table></figure>
<h4 id="33-redis存储"><a class="markdownIt-Anchor" href="#33-redis存储"></a> 3.3 Redis存储</h4>
<p>使用Redis存储短URL与长URL的映射关系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, max_connections=<span class="number">10</span>)</span><br><span class="line">redis_client = redis.Redis(connection_pool=pool)</span><br></pre></td></tr></table></figure>
<h4 id="34-shortener类"><a class="markdownIt-Anchor" href="#34-shortener类"></a> 3.4 Shortener类</h4>
<p>封装URL缩短和获取长URL的功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shortener</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data_center_id, worker_id</span>):</span><br><span class="line">        self.snowflake_generator = SnowflakeGenerator(data_center_id, worker_id)</span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shorten_url</span>(<span class="params">self, long_url</span>):</span><br><span class="line">        snowflake_id = self.snowflake_generator.generate_id()</span><br><span class="line">        short_url = base62_encode(snowflake_id)</span><br><span class="line">        self.redis_client.<span class="built_in">set</span>(short_url, long_url.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> short_url</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_long_url</span>(<span class="params">self, short_url</span>):</span><br><span class="line">        long_url = self.redis_client.get(short_url)</span><br><span class="line">        <span class="keyword">return</span> long_url.decode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">if</span> long_url <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h4 id="35-flask-web服务"><a class="markdownIt-Anchor" href="#35-flask-web服务"></a> 3.5 Flask Web服务</h4>
<p>搭建Flask应用，提供URL缩短和重定向的接口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, redirect, jsonify</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">shortener = Shortener(data_center_id=<span class="number">0</span>, worker_id=<span class="number">0</span>)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/shorten&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shorten</span>():</span><br><span class="line">    long_url = request.form.get(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> long_url:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;URL is required&quot;</span>&#125;), <span class="number">400</span></span><br><span class="line">    short_url = shortener.shorten_url(long_url)</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;short_url&quot;</span>: short_url&#125;), <span class="number">200</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&lt;short_url&gt;&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">redirect_url</span>(<span class="params">short_url</span>):</span><br><span class="line">    long_url = shortener.get_long_url(short_url)</span><br><span class="line">    <span class="keyword">if</span> long_url:</span><br><span class="line">        <span class="keyword">return</span> redirect(long_url)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;URL not found&quot;</span>&#125;), <span class="number">404</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4-系统部署与测试"><a class="markdownIt-Anchor" href="#4-系统部署与测试"></a> 4. 系统部署与测试</h3>
<h4 id="41-环境准备"><a class="markdownIt-Anchor" href="#41-环境准备"></a> 4.1 环境准备</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>安装Python和Flask、Redis库。</p>
</li>
<li class="lvl-2">
<p>启动Redis服务器。</p>
</li>
</ul>
<h4 id="42-测试流程"><a class="markdownIt-Anchor" href="#42-测试流程"></a> 4.2 测试流程</h4>
<ol>
<li class="lvl-3">
<p><strong>缩短URL</strong>：</p>
 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d &quot;url=https://www.example.com&quot; http://127.0.0.1:5000/shorten</span><br></pre></td></tr></table></figure>
<p>返回：</p>
 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;short_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;abc123def45&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>访问短URL</strong>：</p>
 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:5000/abc123def45</span><br></pre></td></tr></table></figure>
<p>重定向到&quot;<a target="_blank" rel="noopener" href="https://www.example.com">https://www.example.com</a>&quot;。</p>
</li>
<li class="lvl-3">
<p><strong>错误处理</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">
<p>无效的URL：</p>
  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d &quot;url=invalid&quot; http://127.0.0.1:5000/shorten</span><br></pre></td></tr></table></figure>
<p>返回：</p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Invalid URL&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-6">
<p>不存在的短URL：</p>
  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:5000/abc123def48</span><br></pre></td></tr></table></figure>
<p>返回：</p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;URL not found&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="5-结论"><a class="markdownIt-Anchor" href="#5-结论"></a> 5. 结论</h3>
<p>通过上述设计和实现，成功构建了一个高效、稳定的短链系统，能够将长URL转换为短URL并实现正确的重定向。系统采用Snowflake算法保证ID的唯一性，Base62编码确保短URL的简洁性，Redis提供快速的存储和检索能力，Flask搭建简单的Web服务接口。系统经过基本测试，功能正常，满足需求。</p>
<h2 id="什么是循环依赖常问"><a class="markdownIt-Anchor" href="#什么是循环依赖常问"></a> 什么是循环依赖（常问）？</h2>
<p><strong>什么是循环依赖？</strong></p>
<p>循环依赖，也称为循环引用或相互依赖，是指在软件开发中，两个或多个模块、类或组件之间形成互相依赖的关系。具体来说，模块A依赖于模块B，而模块B又依赖于模块A，从而形成了一个闭环的依赖关系。</p>
<p>循环依赖的问题</p>
<p>循环依赖会导致 several 问题：</p>
<ol>
<li class="lvl-3">
<p><strong>编译错误</strong>：在编译阶段，循环依赖可能导致无法解析符号或类定义的问题。</p>
</li>
<li class="lvl-3">
<p><strong>运行时错误</strong>：在运行时，循环依赖可能引起栈溢出或空指针异常，因为对象无法正确初始化。</p>
</li>
<li class="lvl-3">
<p><strong>代码复杂性增加</strong>：为了解决循环依赖，开发者可能需要引入额外的逻辑，如延迟加载或中间类，从而增加代码的复杂性和维护难度。</p>
</li>
<li class="lvl-3">
<p><strong>可维护性降低</strong>：循环依赖使得模块之间的耦合度增高，修改其中一个模块可能会影响其他模块，降低了系统的可维护性和可扩展性。</p>
</li>
</ol>
<p>避免循环依赖的策略</p>
<p>为了预防和解决循环依赖问题，可以采取以下几种策略：</p>
<ol>
<li class="lvl-3">
<p><strong>重构代码</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">审查系统的架构，识别导致循环依赖的原因。</li>
<li class="lvl-5">重新设计模块之间的依赖关系，降低耦合度。</li>
<li class="lvl-5">将共同的依赖提取到一个新的模块中。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>使用依赖注入</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">通过构造函数或Setter方法注入依赖，避免在类的内部直接创建依赖对象。</li>
<li class="lvl-5">依赖注入框架可以帮助管理复杂的依赖关系。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>引入中间类</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">创建一个中间类来持有相互依赖的对象，从而打破循环依赖。</li>
<li class="lvl-5">中间类负责管理依赖关系，降低直接依赖的程度。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>使用接口或抽象类</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">定义接口或抽象类，让类依赖于抽象，而不是具体实现。</li>
<li class="lvl-5">通过依赖接口而不是实现类，降低耦合度。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>延迟加载</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">使用惰性加载来延迟依赖的初始化，避免在对象创建时立即引发循环依赖。</li>
<li class="lvl-5">通过属性或方法在需要时才创建依赖对象。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>使用工厂模式</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">通过工厂类来创建对象，并管理它们之间的依赖关系。</li>
<li class="lvl-5">工厂模式可以帮助隐藏对象的创建逻辑，降低直接依赖。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong><br />
循环依赖是软件设计中一个常见但需要避免的问题。它会导致代码的复杂性增加，维护难度加大，而且可能引发运行时错误。通过合理的系统设计和编程技巧，如重构代码、使用依赖注入、引入中间类、使用接口或抽象类、延迟加载以及工厂模式等，可以有效地预防和解决循环依赖问题，提高代码的可维护性和可扩展性。</p>
<p><strong>循环依赖是指在软件开发中，两个或多个模块互相依赖，形成闭环的依赖关系，这会导致编译和运行时错误、代码复杂性增加及可维护性降低。为了避免循环依赖，可以采用重构代码、依赖注入、引入中间类、使用接口或抽象类、延迟加载以及工厂模式等策略。</strong></p>
<h2 id="jvm-垃圾回收调优的主要目标是什么"><a class="markdownIt-Anchor" href="#jvm-垃圾回收调优的主要目标是什么"></a> JVM 垃圾回收调优的主要目标是什么？</h2>
<p>问题陈述: JVM垃圾回收调优的主要目标是什么？</p>
<ol>
<li class="lvl-3">
<p><strong>分析过程</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>性能提升</strong>：垃圾回收过程中，JVM会暂停应用程序的执行（停顿时间），频繁或过长的停顿会影响应用程序的响应速度和吞吐量。调优旨在减少这些停顿，提高性能。</p>
</li>
<li class="lvl-5">
<p><strong>内存管理</strong>：有效管理堆内存，合理分配和回收内存，避免内存泄漏和内存不足的问题，提高内存利用率。</p>
</li>
<li class="lvl-5">
<p><strong>选择合适的垃圾回收器</strong>：根据应用程序的需求（如低延迟或高吞吐量）选择合适的垃圾回收算法，并配置其参数，以满足特定的性能要求。</p>
</li>
<li class="lvl-5">
<p><strong>减少垃圾回收开销</strong>：优化垃圾回收过程，减少CPU资源和时间的消耗，提高整体效率。</p>
</li>
<li class="lvl-5">
<p><strong>提高可预测性</strong>：通过调优减少垃圾回收的不可预测性，使应用程序的性能更加稳定和可预测。</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>结论</strong><br />
综上所述，JVM垃圾回收调优的主要目标是优化垃圾回收过程，减少垃圾回收引起的停顿时间，提高内存利用率和应用程序的性能及稳定性。</p>
</li>
</ol>
<h2 id="redis-中的-big-key-问题是什么如何解决"><a class="markdownIt-Anchor" href="#redis-中的-big-key-问题是什么如何解决"></a> Redis 中的 Big Key 问题是什么？如何解决？</h2>
<ol>
<li class="lvl-3">
<p><strong>什么是 Redis 中的 Big Key 问题？</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>定义</strong>：Big Key 指的是在 Redis 中占用内存较多的键，例如包含大量元素的哈希表、列表、集合或有序集合。</li>
<li class="lvl-5"><strong>问题表现</strong>：
<ul class="lvl-4">
<li class="lvl-7"><strong>内存消耗过大</strong>：Big Key 会占用大量内存，导致 Redis 的内存使用量急剧增加。</li>
<li class="lvl-7"><strong>性能下降</strong>：操作 Big Key 时，如 <code>HGETALL</code> 或 <code>LRANGE</code>，会消耗大量 CPU 资源，降低 Redis 的响应速度。</li>
<li class="lvl-7"><strong>内存碎片增加</strong>：Big Key 可能导致内存碎片化，降低内存使用效率。</li>
<li class="lvl-7"><strong>持久化性能下降</strong>：Big Key 增加了 RDB 持久化的时间和磁盘 I/O 负担。</li>
<li class="lvl-7"><strong>复制性能下降</strong>：Big Key 增加了主从节点之间数据同步的时间和带宽消耗。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>如何检测 Big Key？</strong></p>
<ul class="lvl-2">
<li class="lvl-5">使用 <code>MEMORY USAGE</code> 命令查看特定键的内存占用情况。</li>
<li class="lvl-5">使用 <code>redis-cli --bigkeys</code> 命令扫描 Redis 中的大键。</li>
<li class="lvl-5">使用第三方工具如 RedisInsight 或自定义脚本进行检测。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>解决 Big Key 问题的方法</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>重新设计数据结构</strong>：</p>
<ul class="lvl-4">
<li class="lvl-7"><strong>拆分大键</strong>：将大的哈希表拆分成多个小的哈希表，或列表拆分成多个短列表。</li>
<li class="lvl-7"><strong>调整数据访问方式</strong>：在应用层面根据拆分规则访问对应的小键。</li>
</ul>
</li>
<li class="lvl-5">
<p><strong>使用 Redis 集群模式</strong>：</p>
<ul class="lvl-4">
<li class="lvl-7"><strong>数据分散</strong>：将数据分散到多个节点，避免单个节点内存占用过多。</li>
<li class="lvl-7"><strong>水平扩展</strong>：提高系统的扩展性和容错性。</li>
</ul>
</li>
<li class="lvl-5">
<p><strong>使用分页技术</strong>：</p>
<ul class="lvl-4">
<li class="lvl-7"><strong>限制数据加载量</strong>：每次操作只加载部分数据，减少内存和 CPU 的负担。</li>
<li class="lvl-7"><strong>优化性能</strong>：提升 Redis 的响应速度和整体性能。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>选择合适的解决方案</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><strong>根据内存资源</strong>：内存有限时考虑集群模式或拆分大键。</li>
<li class="lvl-5"><strong>根据性能需求</strong>：对性能要求高的场景优先拆分大键或使用分页技术。</li>
<li class="lvl-5"><strong>考虑开发复杂性</strong>：平衡方案的实施难度和收益，选择最适合业务场景的方案。</li>
</ul>
</li>
</ol>
<p>通过上述方法，可以有效检测和解决 Redis 中的 Big Key 问题，提升 Redis 的性能和稳定性。</p>
<p><strong>在 Redis 中，Big Key 指占用内存较多的键，如大量元素的哈希表或列表。它们导致内存消耗过大、性能下降、内存碎片增加及持久化、复制性能下降。检测 Big Key 可使用 <code>MEMORY USAGE</code> 或 <code>redis-cli --bigkeys</code>。解决方法包括重新设计数据结构（拆分 Big Key）、采用 Redis 集群模式分散数据，或使用分页技术限制数据加载量。根据具体情况选择合适方案，可有效提升 Redis 的性能和稳定性。</strong></p>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2025-02-08</span>
            
                <span>该篇文章被 up</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/Java/'>
                            Java
                        </a>
                    
                        <a href='/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/'>
                            面试题
                        </a>
                    
                </span>
             
             
        
        </i>
    </div>
    <br>
    
    

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 2025 UP 

            
                

            
                
                    / <a href="/"> Home </a>
                

            
                
                    / <a href="/ch"> Channel </a>
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery/lightgallery.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
    </body>
</html>
<script src="/js/emojiHandler.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    wrapEmojis('.paper');
  });
</script>